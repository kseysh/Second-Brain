## 지역성의 원리
• 프로그램은 언제든지 전체 주소 공간 중 일부만 접근함
• 시간 지역성
	• 최근에 접근한 항목은 곧 다시 접근될 가능성이 높음
	• 예: 반복문 안의 명령어, 유도 변수
• 공간 지역성
	• 최근에 접근한 항목 근처에 있는 항목도 곧 접근될 가능성이 높음
	• 예: 순차적인 명령어 접근, 배열 데이터
## 지역성을 활용하는 방법
• 메모리 계층 구조
	• 모든 데이터를 디스크에 저장 
	• 디스크에서 최근에 접근한(또는 근처의) 데이터를 더 작은 DRAM으로 복사
		• 주기억장치
	• DRAM에서 최근에 접근한(또는 근처의) 데이터를 더 작은 SRAM으로 복사
		• CPU에 연결된 캐시 메모리
## 메모리 계층 구조의 단계
• 블록(또는 라인): 복사의 단위
	• 하나 이상의 단어를 포함할 수 있음
• 접근한 데이터가 상위 계층에 있을 경우
	• 히트(hit): 접근이 상위 계층에서 만족됨
		• 히트율(hit ratio): 히트 횟수 / 총 접근 횟수
• 접근한 데이터가 없을 경우
	• 미스(miss): 블록을 하위 계층에서 복사해 옴
		• 소요 시간: 미스 패널티(miss penalty)
		• 미스율(miss ratio): 미스 횟수 / 총 접근 횟수
			= 1 - 히트율
	• 그 후 데이터는 상위 계층에서 제공됨
![[Pasted image 20250525200305.png|200]]
## 메모리 기술
• 정적 RAM(SRAM) - Cache
	• 접근 시간: 0.5ns ~ 5ns, 가격: GB당 $400 ~ $800
• 동적 RAM(DRAM) - Main memory
	• 접근 시간: 20ns ~ 50ns, 가격: GB당 $2 ~ $4
• 낸드 플래시(SSD)
	• 접근 시간: 250μs ~ 1000μs, 가격: GB당 $0.04 ~ $0.10
• 자기 디스크
	• 접근 시간: 2ms ~ 20ms, 가격: GB당 $0.01 ~ $0.02
• 이상적인 메모리
	• SRAM의 접근 시간
	• 디스크의 용량과 GB당 비용
## 캐시 메모리
• 캐시 메모리
	• CPU에 가장 가까운 메모리 계층
• 접근 순서 X1, …, Xn–1, Xn이 주어졌을 때
	• 데이터가 있는지 어떻게 알 수 있을까?
	• 어디에서 찾아야 할까?
![[Pasted image 20250525200320.png|200]]
## Direct Mapped Cache 
(주소마다 저장될 수 있는 칸을 고정)
• 위치는 주소에 따라 결정됨
• 직접 사상 방식: 선택지는 하나뿐
	• (블록 주소) modulo (캐시 블록 수)
		• 블록 수는 2의 거듭제곱
		• 주소의 하위 비트를 사용
![[Pasted image 20250525200334.png|200]]
## 태그와 유효 비트
• 특정 캐시 위치에 어떤 블록이 저장되어 있는지 어떻게 알까?
	• 데이터뿐 아니라 블록 주소도 함께 저장
	• 실제로는 상위 비트만 필요
	• 이를 태그(tag)라고 함
• 해당 위치에 데이터가 없으면?
	• 유효 비트(valid bit): 1 = 존재, 0 = 없음
	• 초기값은 0
주소의 하위 bits -> 위치를 찾기
주소의 상위 bits -> 맞는지 확인
valid bit -> 유효한지 확인