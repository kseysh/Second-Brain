###### Performance 정의 X가 Y보다 n배 빠르다
CPU Time<sub>Y</sub> / CPU Time<sub>X</sub> = n
###### CPU Time 계산 공식
CPU Time = ![[Pasted image 20250404170357.png|100]]
###### Clock Cycle 계산 공식
Instruction Count x CPI
###### Clock Cycle을 줄이기 위해서는
program code나 ISA와 compiler에 따라 달라진다.
###### CPI를 줄이기 위해서는
CPU 하드웨어에 따라 달라진다
Instruction마다 다르다
###### Amdahl's Law
자주 사용하는 case를 빠르게 해야 개선이 유의미하다
###### Idle 상황의 전력 효율을 줄여야 유의미한 결과가 나오는 이유
보통 컴퓨터는 Idle 상황에 놓여있는 경우가 많고, Amdahl's Law에 의해 Idle 상황에서의 전력 효율을 줄여야 전력효율 개선이 유의미할 수 있다.
###### ISA란?
hardware와 software간의 interface
###### Design Principle 4가지
- 간단한 것을 위해선 규칙적인 것이 좋다.
	- ex) I-Format, R-Format등이 정해져있음
- 작은 것이 더 빠르다
	- ex) memory도 빠르지만 빠른 계산을 위해 register를 사용한다.
- 자주 생기는 일을 빠르게 하라
	- ex) addi를 이용해 불필요하게 레지스터에 상수를 적재하지 않도록 한다.
- 좋은 설계에는 적당한 절충이 필요하다
	- ex) R-format이 규칙이지만, 규칙을 변형한 I-format도 쓰임
###### Sign Extension 진행법
부호를 유지하기 위해 가장 왼쪽 비트를 복제한다.
###### R-format
![[Pasted image 20250318161034.png|300]]
###### I-format
![[Pasted image 20250318161318.png|300]]
###### sll, srl
- `sll` : Shift left logical
	- 왼쪽으로 shift 후 0을 채운다.
	- 2<sup>i</sup>를 곱하는 것
- `srl` : Shift right logical
	- 오른쪽으로 shift 후 0을 채운다.
	- 2<sup>i</sup>로 나뉘는 것
###### J-Format
![[Pasted image 20250318200508.png|300]]
###### `while (save[i] == k) i += 1;` 변경
i: $s3
k: $s5
save: $s6
```
Loop: sll $t1, $s3, 2 (save의 시작 주소를 구하기 위해 4 x i를 shift 연산으로 구함)
	  add $t1, $t1, $s6 (save의 시작 주소와 t1을 더함 = save[i]의 주소)
	  lw $t0, 0($t1)
	  bne $t0, $s5, Exit
	  addi $s3, $s3, 1
	   j Loop
Exit: ...
```
###### 주로 최적화를 수행하는 곳
Basic Blocks: embeded branch가 없고, branch의 target이 아닌 순차적인 명령어
즉, 명령어가 sequential하게 실행되는 것을 보장하는 곳
###### slt, slti
 `slt rd, rs, rt`
- rs < rs라면, rd를 1로 만들고 아니면 0으로 만들어라
- R-format
 `slti rt, rs, constant`
- rs < constant라면, rt를 1로 만들고 아니면 0으로 만들어라
- I-format
###### blt, bge intruction이 없는 이유
- 하드웨어에서는 equal 비교보다 대소비교가 더 느리기 때문
- 컴퓨터는 한 clock마다 한 instruction을 수행하는 것을 기본으로 한다.
- 하지만 blt로 인해 느린 동작을 하면 clock의 단위를 늘릴 수 밖에 없고 이는 컴퓨터 성능을 낮출 수 있기 때문이다.
- 따라서, set, branch의 두 가지 동작으로 분리하였다.
###### Procedure Calling Step
1. 매개변수를 레지스터에 배치
2. 제어를 프로시저로 전달
3. 프로시저를 위한 저장 공간 확보
4. 프로시저 연산 수행
5. 호출 함수를 위해 결과를 레지스터에 저장
6. 호출한 위치로 복귀
###### callee-saved register
$t0 ~ $t1
###### caller-saved register
$s0 ~ $s1
###### gp, sp, fp, ra, v, a
- $a0 – $a3: arguments
- $v0, $v1: result values
- $gp: global pointer for static data
- $sp: stack pointer
	- stack 공간을 어디까지 사용하는지에 대한 포인터
	- stack 공간은 위에서 아래로 내려오므로, sp는 스택의 최하위 주소를 가짐
- $fp: frame pointer
- $ra: return address
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
