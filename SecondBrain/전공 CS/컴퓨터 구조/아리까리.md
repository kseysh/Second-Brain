##### Leaf Procedure
```c
int leaf_example (int g, h, i, j) { // $a0, ... , $a3에 저장됨
	int f; // $s0에 저장됨다.
	f = (g + h) - (i + j);
	return f; // $v0에 저장됨
}
```
###### A
```c
leaf_example:
	addi $sp, $sp, -4 // 스택 포인터를 4 빼줌 ($s0가 4byte이므로)
	sw $s0, 0($sp) // $s0를 stack에 저장
	add $t0, $a0, $a1
	add $t1, $a2, $a3
	sub $s0, $t0, $t1 // procedure body
	add $v0, $s0, $zero // Result
	lw $s0, 0($sp) 
	addi $sp, $sp, 4 // Restore $s0 
	jr $ra // Return
```
##### Non Leaf Procedure
```c
int fact (int n) { // $a0에 저장됨
	if (n < 1) return 1;
	else return n * fact(n - 1); // Result는 $v0에 저장됨
}
```
###### A
![[Pasted image 20250324174536.png|400]]
lw, sw 구분 잘 하기 
sp는 sw의 반대 순서로 한다.
##### Q
```cpp
void strcpy (char x[], char y[])
{
	int i;
	i = 0;
	while ((x[i]=y[i])!='\0'){
		i += 1;
	}
}
```
x = $a0
y = $a1
i = $s0
###### A
![[Pasted image 20250325142713.png|400]]
###### 일반 Divider 0000 0111 / 0010
![[Pasted image 20250403134631.png|400]]
##### Q
```c
float f2c (float fahr) {
  return ((5.0 / 9.0) * (fahr - 32.0));
}
```
•	fahr는 $f12, 결과는 $f0, 상수는 전역 메모리 영역에 저장
###### A
```
f2c:
  lwc1 $f16, const5($gp)
  lwc1 $f18, const9($gp)
  div.s $f16, $f16, $f18
  lwc1 $f18, const32($gp)
  sub.s $f18, $f12, $f18 // 모든 산술 연산 뒤 .s 붙여야 함!!
  mul.s $f0, $f16, $f18
  jr $ra
```

항상 restore 해주기
addi zero하지 않기
double은 짝수 레지스터를 사용해야 함