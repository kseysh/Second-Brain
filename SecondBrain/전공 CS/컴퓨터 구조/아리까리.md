###### Design Principle 4가지
- 간단한 것을 위해선 규칙적인 것이 좋다.
	- ex) I-Format, R-Format등이 정해져있음
- 작은 것이 더 빠르다
	- ex) memory도 빠르지만 빠른 계산을 위해 register를 사용한다.
- 자주 생기는 일을 빠르게 하라
	- ex) addi를 이용해 불필요하게 레지스터에 상수를 적재하지 않도록 한다.
- 좋은 설계에는 적당한 절충이 필요하다
	- ex) R-format이 규칙이지만, 규칙을 변형한 I-format도 쓰임
###### sll, srl
`sll $t1, $s1, constant`
- `sll` : Shift left logical
	- 왼쪽으로 shift 후 0을 채운다.
	- 2<sup>i</sup>를 곱하는 것
- `srl` : Shift right logical
	- *오른쪽으로 shift 후 0을 채운다.*
	- 2<sup>i</sup>로 나뉘는 것
###### `while (save[i] == k) i += 1;` 
i: $s3
k: $s5
save: $s6
```
Loop: sll $t1, $s3, 2 (save의 시작 주소를 구하기 위해 4 x i를 shift 연산으로 구함)
	  add $t1, $t1, $s6 (save의 시작 주소와 t1을 더함 = save[i]의 주소)
	  lw $t0, 0($t1)
	  bne $t0, $s5, Exit
	  addi $s3, $s3, 1
	   j Loop
Exit: ...
```
###### 주로 최적화를 수행하는 곳
Basic Blocks: embeded branch가 없고, branch의 target이 아닌 순차적인 명령어
즉, 명령어가 sequential하게 실행되는 것을 보장하는 곳
###### if ($s1 < $s2)
```
slt $t0, $s1, $s2
bne $t0, $zero, L
```
###### blt, bge intruction이 없는 이유
- 하드웨어에서는 equal 비교보다 대소비교가 더 느리기 때문
- 컴퓨터는 한 clock마다 한 instruction을 수행하는 것을 기본으로 한다.
- 하지만 blt로 인해 느린 동작을 하면 clock의 단위를 늘릴 수 밖에 없고 이는 컴퓨터 성능을 낮출 수 있기 때문이다.
- 따라서, set, branch의 두 가지 동작으로 분리하였다.
###### Procedure Calling Step
1. 매개변수를 레지스터에 배치
2. 제어를 프로시저로 전달
3. 프로시저를 위한 저장 공간 확보
4. 프로시저 연산 수행
5. 호출 함수를 위해 결과를 레지스터에 저장
6. 호출한 위치로 복귀
###### lui $s0, 61
load upper immediate
*16 bit 상수를 왼쪽으로 16 bit만큼 옮기고, 나머지를 0으로 채운다*.
레지스터가 32bit니까 가능
###### Branch Addressing
**PC-relative addressing**을 사용한다.
- 현재 PC에서 얼만큼 떨어져 있는지를 사용한다 (대부분의 branch는 비슷한 code 공간에 있기 때문)
- Target address = **현재 PC + offset x 4**
- 따라서 address에는 18bit까지 표현할 수 있다.
- instruction의 크기는 4byte이므로, 4의 배수가 아닌 값은 쓸모가 없다.
	- 따라서 constant address는 뒤에 00이 생략되어 있다.
- 실제 주소 크기는 word size인 32bit이다.
###### Jump Addressing
**(Pseudo)Direct jump addressing**을 사용한다. (J-Format은 address 부분이 크기 때문)
- Target address = **PC<sub>31...28</sub> + address x 4**
- 여기에서도 Branch Addressing과 같은 이유로 address에 4를 나눠 저장해둔다.
- 표현은 28bit까지 할 수 있는데 target 주소는 32bit이다.
	- 따라서, 4bit는 현재 PC의 상위 4bit로 채운다.
###### beq $s0, $s1, L2에서 Branch가 16bit offset으로 표현하기 너무 크다면
assembler가 code를 변경한다.
```
bne $s0, $s1, L2
j L1
L2: ....
```
###### `blt $t0, $t1, L`
=>
```
slt $at, $t0, $t1
bne $at, $zero, L
```
###### $at이란
assembler temporary
- 어셈블러가 어셈블리어를 기계어로 번역하면서 임시 레지스터가 필요할 때 사용되는 레지스터








