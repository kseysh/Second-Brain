###### Design Principle 4가지
- 간단한 것을 위해선 규칙적인 것이 좋다.
	- ex) I-Format, R-Format등이 정해져있음
- 작은 것이 더 빠르다
	- ex) memory도 빠르지만 빠른 계산을 위해 register를 사용한다.
- 자주 생기는 일을 빠르게 하라
	- ex) addi를 이용해 불필요하게 레지스터에 상수를 적재하지 않도록 한다.
- 좋은 설계에는 적당한 절충이 필요하다
	- ex) R-format이 규칙이지만, 규칙을 변형한 I-format도 쓰임
###### sll, srl
`sll $t1, $s1, constant`
- `sll` : Shift left logical
	- 왼쪽으로 shift 후 0을 채운다.
	- 2<sup>i</sup>를 곱하는 것
- `srl` : Shift right logical
	- *오른쪽으로 shift 후 0을 채운다.*
	- 2<sup>i</sup>로 나뉘는 것

###### 주로 최적화를 수행하는 곳
Basic Blocks: embeded branch가 없고, branch의 target이 아닌 순차적인 명령어
즉, 명령어가 sequential하게 실행되는 것을 보장하는 곳
###### blt, bge intruction이 없는 이유
- 하드웨어에서는 equal 비교보다 대소비교가 더 느리기 때문
- 컴퓨터는 한 clock마다 한 instruction을 수행하는 것을 기본으로 한다.
- 하지만 blt로 인해 느린 동작을 하면 clock의 단위를 늘릴 수 밖에 없고 이는 컴퓨터 성능을 낮출 수 있기 때문이다.
- 따라서, set, branch의 두 가지 동작으로 분리하였다.
###### lui $s0, 61
load upper immediate
*16 bit 상수를 왼쪽으로 16 bit만큼 옮기고, 나머지를 0으로 채운다*.
레지스터가 32bit니까 가능
###### Branch Addressing
**PC-relative addressing**을 사용하여 현재 PC에서 얼만큼 떨어져 있는지를 사용한다
- Target address = **현재 PC + offset x 4**
###### Jump Addressing
**(Pseudo)Direct jump addressing**을 사용한다.
- Target address = **PC<sub>31...28</sub> + address x 4**
###### $at이란
assembler temporary
- 어셈블러가 어셈블리어를 기계어로 번역하면서 임시 레지스터가 필요할 때 사용되는 레지스터








