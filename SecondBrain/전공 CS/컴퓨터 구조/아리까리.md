###### Design Principle 4가지
- 간단한 것을 위해선 규칙적인 것이 좋다.
	- ex) I-Format, R-Format등이 정해져있음
- 작은 것이 더 빠르다
	- ex) memory도 빠르지만 빠른 계산을 위해 register를 사용한다.
- 자주 생기는 일을 빠르게 하라
	- ex) addi를 이용해 불필요하게 레지스터에 상수를 적재하지 않도록 한다.
- 좋은 설계에는 적당한 절충이 필요하다
	- ex) R-format이 규칙이지만, 규칙을 변형한 I-format도 쓰임
###### sll, srl
`sll $t1, $s1, constant`
- `sll` : Shift left logical
	- 왼쪽으로 shift 후 0을 채운다.
	- 2<sup>i</sup>를 곱하는 것
- `srl` : Shift right logical
	- *오른쪽으로 shift 후 0을 채운다.*
	- 2<sup>i</sup>로 나뉘는 것

###### 주로 최적화를 수행하는 곳
Basic Blocks: embeded branch가 없고, branch의 target이 아닌 순차적인 명령어
즉, 명령어가 sequential하게 실행되는 것을 보장하는 곳
###### blt, bge intruction이 없는 이유
- 하드웨어에서는 equal 비교보다 대소비교가 더 느리기 때문
- 컴퓨터는 한 clock마다 한 instruction을 수행하는 것을 기본으로 한다.
- 하지만 blt로 인해 느린 동작을 하면 clock의 단위를 늘릴 수 밖에 없고 이는 컴퓨터 성능을 낮출 수 있기 때문이다.
- 따라서, set, branch의 두 가지 동작으로 분리하였다.
###### lui $s0, 61
load upper immediate
*16 bit 상수를 왼쪽으로 16 bit만큼 옮기고, 나머지를 0으로 채운다*.
레지스터가 32bit니까 가능
###### Branch Addressing
**PC-relative addressing**을 사용하여 현재 PC에서 얼만큼 떨어져 있는지를 사용한다
- Target address = **현재 PC + offset x 4**
###### Jump Addressing
**(Pseudo)Direct jump addressing**을 사용한다.
- Target address = **PC<sub>31...28</sub> + address x 4**
###### $at이란
assembler temporary
- 어셈블러가 어셈블리어를 기계어로 번역하면서 임시 레지스터가 필요할 때 사용되는 레지스터


###### Optimized Multiplier vs 일반 Multiplier
*add와 shift가 병렬적으로 실행*된다.
partial-product addition 당 한 사이클
ALU가 64->32bit
###### Optimized Divider vs 일반 Divider
ALU, Divisor가 64 -> 32bit
###### Mult, Div 정리
- 일반 Multiplier
	- Multiplier 왼 Multiplicand 오
	- Multiplicand가 이름이 커서 비트도 두 배
- Optimized Multiplier
	- Product 오
- 일반 Divider
	- Quotient 왼 Remainder 오
	- Rem-Div해서 0보다 크면 Quotient에 1
- Optimized Divider
	- Remainder 왼
###### Division에서 3가지 방식 중 어떤 방식을 사용하는지
- Long division
	- If divisor ≤ dividend bits
		- 몫에 1을 넣고, 뺄셈 수행
	- else
		- 몫에 0을 넣고, 다음 나눠지는 수의 비트를 내려옴
- restoring division
	- 이걸 사용
	- 일단 뺀 후, 나머지가 0보다 작아지면 나누는 수를 다시 더함
- signed division
	- 절댓값을 이용해 나눈 후 몫과 나머지의 부호를 필요에 따라 조정
###### 일반 Divider 0000 0111 / 0010
![[Pasted image 20250403134631.png|400]]

###### div, divu의 0 나눗셈, 어떻게 생겼는지
0 나눗셈을 체크하지 않음 (소프트웨어가 따로 처리해야 함)
div rs, rt 처럼 생겼고, 결과에 접근하기 위해 mfhi, mflo를 사용한다.
###### 1.000₂ × 2⁻¹ + –1.110₂ × 2⁻²를 FP Addition 과정을 설명하며 진행
1. 이진 소수점 정렬
	•	지수가 더 작은 수를 이동시킴
	•	1.000₂ × 2⁻¹ + –0.111₂ × 2⁻¹
2. Fraction 덧셈
	•	1.000₂ × 2⁻¹ + –0.111₂ × 2⁻¹ = 0.001₂ × 2⁻¹
3. 결과 정규화 및 오버/언더플로 검사
	•	1.000₂ × 2⁻⁴ (오버/언더플로 없음)
4. 반올림 및 필요 시 재정규화
	•	1.000₂ × 2⁻⁴ (변화 없음) = 0.0625
###### 1.000₂ × 2⁻¹ × –1.110₂ × 2⁻² (0.5 × –0.4375)를 FP Multiplication 과정을 설명하며 진행 (biased)
1.	Add exponents
	•	Unbiased: –1 + (–2) = –3
	•	biased: (–1 + 127) + (–2 + 127) = –3 + 254 – 127 = –3 + 127
2.	Multiply significands
	•	1.000₂ × 1.110₂ = 1.110₂ → 1.110₂ × 2⁻³
3.	결과 정규화 및 오버/언더플로 확인
	•	1.110₂ × 2⁻³ (변화 없음, 오버/언더플로 없음)
4.	반올림 및 필요 시 재정규화
	•	1.110₂ × 2⁻³ (변화 없음)
5.	부호 결정: 양수 × 음수 → 음수
	•	–1.110₂ × 2⁻³ = –0.21875
