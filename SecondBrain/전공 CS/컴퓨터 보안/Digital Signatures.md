## 13장: 목차
• 디지털 서명
	• 디지털 서명의 두 가지 접근 방식
	• 특성 및 요구사항
• 복습
	• DLP와 순환 군
• Schnorr 인증
	• Schnorr 인증
	• Fiat-Shamir 휴리스틱
	• Schnorr 서명
• DSA와 ECDSA
• RSA-PSS
## 디지털 서명의 핵심 요소 간략도
![[Pasted image 20250529141803.png|500]]
Alice(발신자)
1. M 작성
2. 해시 함수로 메시지 압축 -> 해시 값 h
3. 자신의 개인키로 서명 알고리즘 수행 -> 디지털 서명 S 생성
4. (M, S)를 Bob에게 전송

Bob (수신자)
1. M을 해시하여 해시 값 A 계산
2. Alice의 공개키로 서명 S를 복호화하거나 검증
3. 결과와 A를 비교하여 유효 여부 판단
## Two Approaches to Digital Signatures
![[Pasted image 20250529141828.png|500]]
### RSA 

디지털 서명의 특성
• 서명 작성자 및 서명의 날짜와 시간을 검증할 수 있어야 함
• 서명 당시의 내용을 인증할 수 있어야 함
• 제3자가 분쟁 해결을 위해 서명을 검증할 수 있어야 함

⸻

디지털 서명의 요구사항
• 서명은 서명 대상 메시지에 의존하는 비트 패턴이어야 함
• 서명은 발신자 고유의 정보를 사용하여 위조 및 부인을 방지해야 함
• 디지털 서명을 생성하는 것이 비교적 쉬워야 함
• 디지털 서명을 인식하고 검증하는 것이 비교적 쉬워야 함
• 기존 서명에 대해 새로운 메시지를 구성하거나, 주어진 메시지에 대해 위조 서명을 구성하는 것이 계산적으로 불가능해야 함
• 디지털 서명을 저장소에 보관하기에 실용적이어야 함

⸻

복습: DLP와 순환 군
• 이산 로그 문제(DLP): 𝛼, 𝑝, 𝑦가 주어졌을 때, 𝑦 = 𝛼^𝑥 mod 𝑝를 만족하는 𝑥를 찾는 문제
• 모듈로 곱셈 연산을 갖는 순환 군
• 차수가 𝑞인 부분군 (𝑞는 𝑝−1의 약수)
• 𝛼^𝑥 ≡ 𝛼^𝑥 mod 𝑞 mod 𝑝임을 유의
• 따라서 비밀키 𝑥는 𝑞보다 작고, 공개키 𝑦는 𝑝보다 작음
• 예시: 𝑝 = 19, 𝑞 = 6, 부분군 생성자 𝛼 = 8
• 실제 예시: 𝑝 ≈ 2^3072, 𝑞 ≈ 2^256

⸻

부분군을 사용하는 이유?
• DLP와 모듈러 지수 연산
– DLP 기반 스킴은 𝛼^𝑥 mod 𝑝와 같은 지수 연산 사용
– 이 연산의 계산 복잡도는 지수 𝑥의 비트 길이에 비례
– 예: left-to-right 제곱-곱 알고리즘 사용 시, 3072비트 지수는 평균 약 4608번의 곱셈 필요
– 각 곱셈의 복잡도는 𝑝의 비트 길이 제곱에 비례
– 효율성과 보안성 사이의 균형: 큰 𝑝는 보안성이 높지만 성능이 나빠짐

⸻

부분군을 사용하는 이유?
• DLP (𝛼^𝑥 mod 𝑝)의 보안성과 두 가지 주요 공격 알고리즘
– 일반 수체 필터(GNFS): 소수 체의 대수적 성질 사용, 복잡도는 𝑝의 크기에 의존
→ 예: 3072비트 𝑝는 약 2^128 연산 필요
– Pollard rho: 생일 역설을 이용한 공격 (해시 충돌과 유사)
→ 일반 구조에 적용 가능 (DLP 및 ECDLP 포함), 후보 개수 𝑞에 따라 복잡도 결정
→ 예: 𝑞 = 2^256 → 약 2^128 연산
→ 따라서 𝑞를 조절하면 적절한 보안 수준 확보 가능

⸻

부분군을 사용하는 이유?
• 동일한 보안성 확보하면서 계산 속도 향상
→ 두 가지 요소 간의 균형 필요
– 매우 큰 𝑝 + 중간 크기 𝑞 (GNFS는 𝑞에 영향을 받지 않음)
– 𝛼^𝑥 mod 𝑞 mod 𝑝 사용

NIST 특별 간행물 800-57 Part 1
𝐿: 공개키 크기(𝑝의 비트 길이)
𝑁: 개인키 크기(𝑞의 비트 길이)

⸻

부분군을 사용하는 이유?
• 추가 설명
– GNFS는 ECDLP에 적용되지 않음. ECC에서는 그룹 크기 𝑞만 고려하면 됨 → ECC가 더 효율적
– 𝑞는 소수여야 함. 그렇지 않으면 Pohlig-Hellman 공격에 취약해짐 (𝑞의 소인수 분해를 통해 계산 가속)

⸻

Schnorr 인증 (1989)
출처: Douglas Stinson, Cryptography: Theory and Practice, 3판
• 실제로는 challenge-response 기반 사용자 인증 방식
• 기본 문제: DLP (𝛼, 𝑝, 𝑦로부터 𝑥를 찾기)
• Alice의 키 쌍
– 개인키: 𝑎
– 공개키: 𝑣 = 𝛼^(−𝑎) mod 𝑞 mod 𝑝

⸻

Schnorr 서명 (1989)
• Schnorr 인증은 상호작용 기반 영지식 증명 프로토콜
• Fiat-Shamir 휴리스틱:
– 상호작용 기반 지식 증명을 입력으로 받아
– 디지털 서명을 생성하는 방식
• 무작위 챌린지 𝑟을 H(M||𝛾)로 대체함

증명: 메시지 M에 대한 (𝛾, 𝑦)
검증자:
	1.	𝑟 = H(M||𝛾) 계산
	2.	𝛾 ≡ 𝛼^𝑦 * 𝑣^𝑟 mod 𝑝 검증 (𝑣 = 𝛼^(−𝑎) mod 𝑝)

Schnorr 서명 변형
서명: (𝑟, 𝑦)
검증자:
	1.	𝛾′ = 𝛼^𝑦 * 𝑣^𝑟 mod 𝑝 계산
	2.	𝑟 = H(M||𝛾′)인지 확인

⸻

NIST 디지털 서명 알고리즘 (DSA)
• NIST에서 연방 정보 처리 표준 FIPS 186으로 발표
• SHA(Secure Hash Algorithm) 사용
• FIPS 186-3부터 RSA, ECC 기반 서명 알고리즘도 포함

⸻

최신 DSA 정보
• 최신 버전: FIPS 186-5 (2023년 2월 발행)
• DSA는 산업계에서의 사용 부족과 도메인 파라미터가 적절히 생성되지 않을 경우 취약해질 수 있다는 분석에 따라 더 이상 승인된 알고리즘이 아님
• 단, 과거에 생성된 서명 검증에는 계속 사용 가능

⸻

그림 13.4: DSA / Schnorr 서명 요약
키 쌍: (𝑎, 𝑣 = 𝛼^(−𝑎) mod 𝑝)
메시지 M에 대한 서명 과정:
	1.	𝛾 = 𝛼^𝑘 mod 𝑝 (랜덤 𝑘)
	2.	𝑟 = H(M||𝛾)
	3.	𝑦 = 𝑘 + 𝑎𝑟 mod 𝑞
	4.	서명: (𝑟, 𝑦)

검증:
	1.	𝛾′ = 𝛼^𝑦 * 𝑣^𝑟 mod 𝑝
	2.	𝑟 = H(M||𝛾′)인지 확인

※ 𝑞는 𝑝−1의 약수인 부분군의 차수

⸻

RSA-PSS
• RSA 확률 서명 스킴
• 2009년 FIPS 186 버전에 포함
• RSA Labs가 가장 안전하다고 권장하는 RSA 서명 방식
• 이전의 RSA 기반 스킴들은 RSA 기반 원시 연산의 보안성과 동등함을 수학적으로 증명하지 못함
• PSS 접근 방식은 Bellare와 Rogaway가 처음 제안
• 무작위화(randomization)를 도입하여 RSA 알고리즘 자체의 보안성과 직접적으로 연결 가능

⸻
