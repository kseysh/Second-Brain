## 13장: 목차
• 디지털 서명
	• 디지털 서명의 두 가지 접근 방식
	• 특성 및 요구사항
• 복습
	• DLP와 순환 군
• Schnorr 인증
	• Schnorr 인증
	• Fiat-Shamir 휴리스틱
	• Schnorr 서명
• DSA와 ECDSA
• RSA-PSS
## 디지털 서명의 핵심 요소 간략도
![[Pasted image 20250529141803.png|500]]
Alice(발신자)
1. M 작성
2. 해시 함수로 메시지 압축 -> 해시 값 h
3. 자신의 개인키로 서명 알고리즘 수행 -> 디지털 서명 S 생성
4. (M, S)를 Bob에게 전송

Bob (수신자)
1. M을 해시하여 해시 값 A 계산
2. Alice의 공개키로 서명 S를 복호화하거나 검증
3. 결과와 A를 비교하여 유효 여부 판단
## Two Approaches to Digital Signatures
![[Pasted image 20250529141828.png|500]]
### RSA 접근 방식
위 방식과 같음
### DSA 접근 방식
서명 과정
1. M 작성
2. 임의의 값 k 생성
3. 자신의 개인키와 k로 서명 알고리즘 수행 -> 디지털 서명 (r, s) 생성
4. 메시지와 (r, s)를 Bob에게 전송

검증과정
1. M을 해시하여 해시 값 A 계산
2. 공개키 PUₐ, 공개 파라미터 PUg, (r, s)를 사용하여 서명 검증 Ver 수행
3. 결과 비교를 통해 유효 여부 판단
![[Pasted image 20250531173215.png|400]]
## 디지털 서명의 특성
• 서명 작성자 및 서명의 날짜와 시간을 검증할 수 있어야 함
• 서명 당시의 내용을 인증할 수 있어야 함
• 제3자가 분쟁 해결을 위해 서명을 검증할 수 있어야 함 (부인 방지)
## 디지털 서명의 요구사항
• 서명은 서명 대상 메시지에 의존하는 비트 패턴이어야 함
• 서명은 발신자 고유의 정보를 사용하여 위조 및 부인을 방지해야 함
• 디지털 서명을 생성하는 것이 비교적 쉬워야 함
• 디지털 서명을 인식하고 검증하는 것이 비교적 쉬워야 함
• 기존 서명에 대해 새로운 메시지를 구성하거나, 주어진 메시지에 대해 위조 서명을 구성하는 것이 계산적으로 불가능해야 함
• 디지털 서명을 저장소에 보관하기에 실용적이어야 함
## Subgroup
• 이산 로그 문제(DLP): 𝛼, 𝑝, 𝑦가 주어졌을 때, 𝑦 = 𝛼<sup>𝑥</sup> mod 𝑝를 만족하는 𝑥를 찾는 문제
• 모듈로 곱셈 연산을 갖는 순환 군
• 차수가 𝑞인 subgroup (𝑞는 𝑝−1의 약수) (8의 경우에선 6개 있으므로 q = 6)
	• 𝛼<sup>𝑥</sup> ≡ 𝛼<sup>𝑥 mod 𝑞</sup> mod 𝑝임을 유의
	• 따라서 비밀키 𝑥는 𝑞보다 작고, 공개키 𝑦는 𝑝보다 작음
	• 예시: 𝑝 = 19, 𝑞 = 6, 부분군 생성자 𝛼 = 8
	• 실제 예시: 𝑝 ≈ 2<sup>3072</sup>, 𝑞 ≈ 2<sup>256</sup>
## 부분군을 사용하는 이유?
• DLP와 모듈러 지수 연산
	– DLP 기반 schemes은 𝛼<sup>𝑥</sup> mod 𝑝와 같은 지수 연산 사용
	– 이 연산의 계산 복잡도는 지수 𝑥의 비트 길이에 비례
		– 예: left-to-right 제곱-곱 알고리즘 사용 시, 3072비트 지수는 평균 약 4608번의 곱셈 필요
	– 각 곱셈의 복잡도는 𝑝의 비트 길이 제곱에 비례
	– 효율성과 보안성 사이의 균형: 큰 𝑝는 보안성이 높지만 성능이 나빠짐
•	DLP(Diffie-Hellman 문제)의 보안성, 즉 a<sup>x</sup> mod p: DLP를 해결하는 두 가지 주요 알고리즘
	•	GNFS, General Number Field Sieve
		▪ 소수체 mod p의 대수적 성질을 사용
		▪ *복잡도는 모듈러 p의 크기에 따라 달라짐*
		▪ 3072비트 p: 약 2^{128} 연산 필요 (후보 x의 개수는 최대 2^{3072}일 수 있음)
	•	Pollard rho 알고리즘
		▪ 생일 역설(birthday paradox)을 이용한 공격 (해시 충돌 탐색과 유사)
		▪ 일반 구조(DLP 및 ECDLP)에 적용 가능
		▪ *복잡도는 x의 후보 수에 따라 달라짐*
		▪ 2<sup>256</sup>개의 x 후보에 대해, 약 2<sup>128</sup> 연산 필요
		▪ 이를 위해 q ≈ 2<sup>256</sup>인 순환 부분군을 사용할 수 있음
		▪ *q = x의 후보 개수*
• 동일한 보안성 확보하면서 계산 속도 향상
	→ 두 가지 요소 간의 균형 필요
		– 매우 큰 𝑝 + 중간 크기 𝑞 (GNFS는 𝑞에 영향을 받지 않음)
		– 𝛼<sup>𝑥 mod 𝑞</sup> mod 𝑝 사용
• 추가 설명
	– GNFS는 ECDLP에 적용되지 않음. ECC에서는 그룹 크기 𝑞만 고려하면 됨 → ECC가 더 효율적
	– 𝑞는 소수여야 함.
![[Pasted image 20250529150553.png|400]]
𝐿: 공개키 크기(𝑝의 비트 길이)
𝑁: 개인키 크기(𝑞의 비트 길이)
## Schnorr 인증 (1989)
• 실제로는 challenge-response 기반 사용자 인증 방식
• 기본 문제: DLP (𝛼, 𝑝, 𝑦로부터 𝑥를 찾기)
• Alice의 키 쌍
	– 개인키: 𝑎 (이걸 알아야 challenge에 답할 수 있음)
	– 공개키: 𝑣 = 𝛼<sup>(−𝑎) mod 𝑞</sup> mod 𝑝
![[Pasted image 20250529150839.png|400]]
	•	프로토콜 절차
1.	Alice는 무작위 값 𝑘 ∈ {0, …, 𝑞−1} 선택, 𝛾 = 𝑎ᵏ mod 𝑝 → commitment (1024비트)
2.	Bob은 challenge 𝑟 ∈ {1, …, 2ᵗ} 선택 → challenge (40비트)
3.	Alice는 응답 𝑦 = 𝑘 + 𝑎𝑟 mod 𝑞 계산 → response (160비트)
	•	Bob의 검증:
	•	𝛾 ≡ 𝑎ʸ × 𝑣ʳ mod 𝑝 인지 확인
## Schnorr 서명 (1989)
• Schnorr 인증은 상호작용 기반 zero knowledge 증명 프로토콜
• Fiat-Shamir 휴리스틱:
	– 상호작용 기반 지식 증명을 입력으로 받아
	– 디지털 서명을 생성하는 방식
• 무작위 챌린지 𝑟을 H(M||𝛾)로 대체함

![[Pasted image 20250529151027.png|400]]
challenge r을 임의로 선택하는 대신, 𝑟 = H(M||𝛾)로 변경하고, 서명 (𝛾, 𝑦)를 검증함

증명: 메시지 M에 대한 (𝛾, 𝑦)
검증자:
1.	𝑟 = H(M||𝛾) 계산
2.	𝛾 ≡ 𝛼<sup>𝑦</sup> * 𝑣<sup>𝑟</sup> mod 𝑝 검증 (𝑣 = 𝛼<sup>−𝑎</sup> mod 𝑝)

Schnorr 서명 변형
서명: (𝑟, 𝑦)
검증자:
	1.	𝛾′ = 𝛼<sup>𝑦</sup> * 𝑣<sup>𝑟</sup> mod 𝑝 계산
	2.	𝑟 = H(M||𝛾′)인지 확인
## NIST 디지털 서명 알고리즘 (DSA)
• NIST에서 연방 정보 처리 표준 FIPS 186으로 발표
• SHA(Secure Hash Algorithm) 사용
• FIPS 186-3부터 RSA, ECC 기반 서명 알고리즘도 포함
• 최신 버전: FIPS 186-5 (2023년 2월 발행)
• *DSA는 산업계에서의 사용 부족과 도메인 파라미터가 적절히 생성되지 않을 경우 취약해질 수 있다는 분석에 따라 더 이상 승인된 알고리즘이 아님*
• 단, *과거에 생성된 서명 검증에는 계속 사용 가능*
## Digital Signature Algorithm (DSA)
![[Pasted image 20250529151931.png|500]]
## 그림 13.4: DSA / Schnorr 서명
![[Pasted image 20250529151859.png|400]]
키 쌍: (𝑎, 𝑣 = 𝛼<sup>−𝑎</sup> mod 𝑝)
메시지 M에 대한 서명 과정:
	1.	𝛾 = 𝛼<sup>𝑘</sup> mod 𝑝 (랜덤 𝑘)
	2.	𝑟 = H(M||𝛾)
	3.	𝑦 = 𝑘 + 𝑎𝑟 mod 𝑞
	4. 서명: (𝑟, 𝑦)

검증:
	1.	𝛾′ = 𝛼^𝑦 * 𝑣^𝑟 mod 𝑝
	2.	𝑟 = H(M||𝛾′)인지 확인

※ 𝑞는 𝑝−1의 약수인 부분군의 차수
![[Pasted image 20250529152045.png|500]]
## RSA-PSS
• RSA 확률적 서명 스킴 (salt가 랜덤한 값이라서 같은 문서 -> 다른 서명이 나옴)
• 2009년 FIPS 186 버전에 포함
• RSA Labs가 가장 안전하다고 권장하는 RSA 서명 방식
• 이전의 RSA 기반 스킴들은 RSA 기반 원시 연산의 보안성과 동등함을 수학적으로 증명하지 못함
• PSS 접근 방식은 Bellare와 Rogaway가 처음 제안
• 무작위화(randomization)를 도입하여 RSA 알고리즘 자체의 보안성과 직접적으로 연결 가능
![[Pasted image 20250529152128.png|400]]