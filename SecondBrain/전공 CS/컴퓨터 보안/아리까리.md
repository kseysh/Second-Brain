###### NIST 기준 정보 보안의 정의
cia...
(A) 무결성(Integrity):
	•	부적절한 정보 수정이나 파괴를 방지하는 것
	•	정보의 부인 방지(non-repudiation)와 신뢰성(authenticity) 보장 포함
(B) 기밀성(Confidentiality):
	•	허가된 제한 내에서 접근과 공개를 보호하는 것
	•	개인 정보 및 독점 정보 보호 포함
(C) 가용성(Availability):
	•	정보에 대한 신속하고 신뢰할 수 있는 접근 및 사용을 보장하는 것
###### 필수 정보 및 네트워크 보안 목표 5가지
ciaaa
- Confidentially
- Integrity
- Authenticity
- Availablillity
- Accountability(e.g., Nonrepudiation)
###### 보안 설계 원칙 5가지
1. **Fail-safe Defaults** (실패 안전 기본값)
	•	접근 제어는 거부를 기본값으로 설정해야 함
2. **Isolation** (격리)
	•	공개 접근 시스템은 중요 자원과 분리되어야 함 (정보 유출 및 변조 방지)
	•	개별 사용자의 프로세스 및 파일은 명확하게 격리되어야 함
	•	보안 메커니즘도 외부 접근으로부터 격리되어야 함
3. **Complete Mediation** (완전한 중재)
	•	모든 접근 요청은 접근 제어 메커니즘을 통해 검사되어야 함
4. **Open Design** (개방형 설계)
	•	보안 메커니즘의 설계는 비밀이 아니라 공개적으로 검토 가능해야 함
	•	암호화 키는 비밀이어야 하지만, 암호화 알고리즘은 공개되어야 함
		- 이유: 아무리 전문가여도 한계가 존재하므로 많은 전문가의 의견을 받아 안전하게 만들기 위해
5. **Least Privilege** (최소 권한 원칙)
###### Device Security 종류
- Firewall (방화벽)
	- 하드웨어 및/또는 소프트웨어 기능으로, 특정 보안 정책에 따라 네트워크와 네트워크에 연결된 장치 간의 접근을 제한
- Intrusion detection (침입 감지)
	- Host-based(HIDS) vs. NW-based(NIDS)
- Intrusion prevention (침입 방어)
###### Communications Security
**네트워크를 통한 통신의 보호를 다루며, 수동적 공격과 능동적 공격 모두에 대한 방어 조치를 포함**
통신 보안은 주로 **네트워크 프로토콜**을 사용하여 구현
###### Permutation Cipher 단점
알파벳의 빈도 수가 달라 빈도 수를 이용해 유추하기 쉽다 
Digram, Trigram을 이용하여 유추할 수 있다.
###### S-Box 설계 이유
비선형성
입력 비트와 출력 비트 사이의 상관 관계를 낮춤
###### AddRoundkey 설계 이유
•	매우 단순하지만, 상태(State)의 모든 비트에 영향을 미침
•	키 확장의 복잡성과 다른 AES 단계들과 결합되어 보안을 확보함
###### ECB CBC CFB OFB CTR 그리기
![[Pasted image 20250411164154.png]]
input register, encrypt, output  register가 있고 CBC는 위에서 xor, CFB는 아래에서 xor함
CFB와 OFB는 xor 한 칸 차이
OFB와 CTR은 전처리가 가능해야 하므로 다 아래에서 함
###### 시스템의 root 권한을 획득하고 악성코드의 존재를 숨김
Rootkit
###### 정보보호 및 개인정보보호 관리체계 인증
ISMS-P
###### APT 침해 사례
표적형 공격: **Operation Shady RAT**
산업 시설을 감시하고 파괴하는 악성 소프트웨어: **Stuxnet**
###### 숫자 시퀀스가 랜덤한지 검증하기 위한 두 가지 기준
•	균등 분포
	▪ 1과 0의 발생 빈도가 대략 동일해야 한다
•	독립성
	▪ 시퀀스 내의 어떤 부분 시퀀스도 다른 부분 시퀀스로부터 유추될 수 없어야 한다
###### Random number를 위한 두 개의 요구사항
Randomness, Unpredictability
###### Randomness test 세가지
- Frequncy test
▪ 가장 기본적인 테스트이며, 모든 테스트 모음에 반드시 포함되어야 함
▪ 시퀀스 내의 1과 0의 개수가 진정한 랜덤 시퀀스에서 기대되는 수준과 유사한지를 판단하기 위한 것
0과 1의 분포가 특정 퍼센트 이상이면 탈락
- Runs test
▪ 이 테스트의 초점은 시퀀스 내의 전체 런(run) 수에 있음
▪ 런이란, 동일한 비트가 연속적으로 나타나는 구간으로, 앞뒤는 반대값의 비트로 경계 지어짐
▪ 다양한 길이의 1과 0 런의 개수가 랜덤 시퀀스에서 기대되는 수준과 일치하는지를 판단하는 것이 목적
100000000001에서 0의 개수가 일정 개수 이상이면 탈락
- Maurer’s universal statistical test (마우러의 일반성 검정)
▪ 초점은 일치하는 패턴 사이의 비트 수에 있음
▪ 시퀀스가 정보 손실 없이 얼마나 압축 가능한지를 감지하는 것이 목적
▪ 유의미하게 압축 가능한 시퀀스는 비랜덤으로 간주됨
0001000100010001 => 0001 x 5 이렇게 압축이 잘 되면 탈락
###### X<sub>n+1</sub> = (aX<sub>n</sub> + c) mod m 이거 이름
Linear Congruential Generator(선형 합동 생성기)
X<sub>1</sub>, X<sub>2</sub>, ... X<sub>n</sub>을 공격자가 알면 연립방정식을 풀어서 a,c,m을 알아낼 수 있으므로 안전하지 않은 방식이다.
###### 스트림 암호 설계 고려사항
긴 주기를 가져야 함
###### RC4 특징
RSA의 R이 만듬
•	*바이트 기반 연산*을 사용하는 *가변 키 크기 스트림 암호*
•	무작위 순열(random permutation) 기반
RFC에서 금지됨
###### Conditioning이란?
TRNG의 출력은 편향(bias)될 수 있으므로 TRNG의 출력의 엔트로피를 증가시키기 위해 deskewing algorithm을 적용하는 방법
###### 최초의 상용 TRNG, 내부 구조
Intel DRNG
CBC MAC을 이용해 conditioning 진행, CTR을 이용해 PRNG 진행

###### 미국 국립표준기술연구소
NIST
###### 미국 국립표준기술연구소에서 만든거
FIPS
SP
###### 조직 및 개인 회원으로 구성된 전문가 협회
Internet Society (ISOC)
###### 인터넷 표준 및 관련 명세
RFC
###### UN 산하 국제 기구, 전기통신 기술 표준 개발담당
ITU-T (International Telecommunication Union)
###### 미국 전기전자 학회
IEEE (Institute of Electrical and Electronics Engineers)
###### 한국정보통신기술협회
TTA (Telecommunications Technology Association)
###### stream cipher에서 key가 전송할 데이터 트래픽이 크다면, 저장의 문제로 인해 해결하기 어려워 하는 일
*key와 key를 seed로 하는 key generator를 이용하여 plaintext를 암호화하는 방식을 사용*한다.
###### 국가정보원 암호모듈 검증 제도
**KCMVP**
###### Diffusion
각 *plaintext의 숫자가 여러 개의 암호문 숫자에 영향을 미치도록 한다*.
###### Confusion
*암호문의 통계적 특성과 암호화 키의 값 간의 관계를 최대한 복잡하게 만든다*.
암호문의 통계 정보를 얻더라도, 해당 정보를 바탕으로 키를 유추하기 어렵도록 설계한다.
###### Fermat's Theorem
p가 소수고, a가 p로 나뉘어지지 않는 양수라면 아래 식을 만족한다
a<sup>p−1</sup> ≡ 1 (mod p)
###### Fermat test
n이 소수인지 판별하려면, random한 a에 대해 a<sup>n-1</sup>mod n != 1인 값을 찾아야 한다. ( a ∈ \[1, n-1] )
페르마의 소정리에 따라, n가 소수라면, 어떤 a를 선택하든 a<sup>n−1</sup>를 n으로 나눈 나머지는 항상 1이 되어야 하기 때문이다.
###### Primality Test
- *Trial division*
	- 에라토스테네스의 체같은 방식 : 2부터 루트 n까지의 소수로 나누어 떨어지는지 확인한다
	- 틀리지 않는 알고리즘이지만 느리고, 나머지는 답이 틀릴 수도 있는 알고리즘이다.
- Fermat test
- Miller-Rabin test
	- Fermat test를 기반으로 하지만, 추가적인 검사를 수행하여 확률을 높임
- Hybrid
	- ex) trial division + Miller-Rabin/Fermat
	- 작은 수만 trial division으로 소수 판별을 하고, 
	- 일정 지점을 넘어가면 Miller-Rabin/Fermat을 이용해서 소수를 찾는다.
###### 아벨군 5가지 특성
- Closure (폐쇄성)
a, b가 G에 속하면 a•b도 G에 속해야 한다.
- Associativity (결합법칙)
a • (b • c) = (a • b) • c
- Identity Element (항등원)
G에는 항등원 e가 존재하여,  a•e = e•a = a가 성립해야 한다.
- Inverse Element (역원)
G내에 역원 a<sup>-1</sup>이 존재하여 a•a<sup>-1</sup> = a<sup>-1</sup>•a = e가 성립해야 한다.
-  Commutativity (교환법칙)
a•b = b•a
###### Fields 특성
덧셈에 대한 아벨군
곱셈에 대한 아벨군
0 인수분해 금지
분배 법칙
###### 이진 다항식 곱셈 함수 bin_mul(a,b,n)
```python
def bin_mul(a, b, n): # 이진 다항식의 곱셈 수행
    buf = n & 0xff # n의 최고차항 빼버림 100011011 -> 00011011

    f = [0] * 8  # pre-computation table for `a`, 길이 8짜리 리스트를 0으로 초기화
    f[0] = a
    for i in range(1, 8):
        f[i] = f[i-1] << 1 # f[i]: a를 왼쪽으로 i번 시프트한 결과 즉, 위의 결과를 가져와서 1 올림
        if f[i] & 0x100: # carry가 발생하면, # mod의 최고차항과 같아진다면
            f[i] &= 0xff # 하위 8비트만 볼 수 있도록 0b11111111과 and 연산 # 상위 비트 하나 지우고
            f[i] ^= buf # buf와 xor 연산자 # mod 값과 xor

    res = 0
    for i in range(8):
        mask = 1 << i
        if b & mask == 1:
            res ^= f[i]

    return res
```
###### deg()를 이용한 bin_ext_euclid(a, b)
```python
def bin_ext_euclid(a, b):
    u, v = a, b
    g_1, g_2, h_1, h_2 = 1, 0, 0, 1
    while u != 0:
        j = deg(u) - deg(v) # 차수가 낮은 다항식에서 높은 걸 빼야하므로, j < 0 이면 u,v를 스왑
        if j < 0:
            u, v = v, u
            g_1, g_2 = g_2, g_1
            h_1, h_2 = h_2, h_1
            j = -j 
        u = u ^ (v << j) # 차이나는 차수씩만 곱해서 xor
        g_1 = g_1 ^ (g_2 << j)
        h_1 = h_1 ^ (h_2 << j)
    d, g, h = v, g_2, h_2

    return d, g, h # a * g + b * h = gcd (a, b) = 1 = d 
```