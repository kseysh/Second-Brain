###### Cryptographic Hash Function H의 요구사항
가변 입력 크기
고정 출력 크기
효율성
Preimage resistant
Second preimage resistant, 약한 충돌 저항성
강한 충돌 저항성
의사난수성
###### birthday paradox를 이용한 Collision Resistant Attack
•	A는 합법적인 메시지 x를 m비트 해시 코드로 서명할 준비
•	B는 의미는 같지만 다양한 x’를 2<sup>m/2</sup>개 생성하고 (x’, H(x’))를 저장 (그래야 내용을 확인하고 서명을 해줄 것이기 때문)
•	B는 조작된 메시지 y를 만들고 다양한 y’를 생성해 H(y’) = H(x’) 조건을 만족할 때까지 반복
•	그런 후 A에게 x’를 서명 요청
•	서명된 Sign(H(x’))을 Sign(H(y’))로 교체 가능
###### MAC을 이용해 인증, 기밀성 충족하는 방법
![[Pasted image 20250501203514.png|400]]
2번째 방법: 
K1으로 메시지 M에 대해 MAC을 생성 K2로 M과 MAC을 Encrypt -> 인증, 기밀성 충족
3번째 방법:
K2로 M Encrpt, K1으로 암호문 E(K2, M)에 대해 MAC 생성
###### HMAC 특징
대칭 블록 암호보다 소프트웨어에서 일반적으로 더 빠르게 실행됨
NIST 표준(FIPS 198-1)으로도 제정됨
Hash 두 번 함
HMAC은 IP, CMAC은 wifi
###### HMAC 표시
H((K₀ ⊕ opad) || H((K₀ ⊕ ipad) || text))
K0: Block size와 길이가 같은 key 길면 Hash로 압축, 작으면 0추가
K0랑 ipad xor와 text를 hash, K0랑 opad를 concat and hash
###### AE란? / AE 종류
•	통신의 기밀성과 무결성을 동시에 보호하는 암호 시스템을 지칭하는 용어

•	인증 후 암호화: CCM
•	암호화 후 인증: GCM (Galois CTR 모드)
•	독립적으로 암호화 및 인증: 안전하지 않음
###### CCM
Encrypt는 counter mode로 하고, Authentication는 CBC-MAC을 사용하겠다는 의미
IEEE 802.11 WiFi의 보안 요구사항을 지원하는 표준
Authenticate then encrypt 방식 사용
###### Hash 관련 난수 생성 하는 법
Hash_DRBG
Counter 값을 점점 증가시키면서 Hash Function에 V(seed 값) + counter를 넣고 해시 반복 결과를 이어붙여 충분한 길이의 pseudo random bit를 생성
HMAC_DRBG
HMAC을 반복 호출하며 V 값을 입력으로 사용 (Random한 k를 사용하기 때문)
출력된 블록들을 이어붙여 충분한 길이의 난수 비트를 생성
###### 공개키 암호 시스템 응용분야 4가지, 기능
![[Pasted image 20250506175832.png|300]]
###### key generation 하는 법
소수 p, q 고르기
n = p x q
𝜙(n) = (p-1)(q-1)
gcd(𝜙(n), e) = 1 인 e 고르기
d ≡ e<sup>-1</sup>(mod 𝜙(n))
###### Private key의 효율적 연산 방법
•	복호화는 d 제곱 연산 포함
	•	d가 작으면 무차별 대입 공격 등 다양한 공격에 취약 (그래서 d는 작게 하면 안됨)
•	계산 속도를 높이기 위해 중국인의 나머지 정리(CRT) 사용 가능
	•	d mod (p-1), d mod (q-1)을 미리 계산
	•	직접 계산보다 약 4배 빠르게 처리 가능
###### RSA 공격을 위한 수학적 접근 3가지
1. n을 소인수 분해하는 방법
	- n = p x q의 두 소수로 분해하면,
	- 오일러 함수 φ(n) = (p-1)(q-1)를 계산 할 수 있음
	- 이 값을 통해 비밀 키 d를 e<sup>-1</sup>mod φ(n)로 계산 가능
2. p, q 없이 φ(n) 직접 계산하는 방법
3.	φ(n) 없이 d를 직접 계산
###### CCA
Chosen Ciphertext Attack
암호문을 살짝 바꿔서 새로운 암호문을 만들어 복호화를 요청(query to decryption oracle)하고, 이를 수학적으로 계산하여 원래 메시지를 알아내는 방법
###### side-channel attacks의 대응책
•	키에 독립적인 연산 (예: 일정한 시간의 지수 계산)
•	무작위성 도입 (예: 무작위 지연)
###### CRT를 이용한 Fault Based Attack
- 공격자가 한쪽 모듈러 연산 (예: mod p)만 오류를 일으키면, 서명 값이 잘못되면서, 이 정보를 이용해 p 또는 q 중 하나를 추출할 수 있다.
###### ElGamal Cryptosystem의 전역 공개 요소
q : 큰 소수
a: q의 primitive root
###### ElGamal Cryptosystem의 key generation
Y<sub>A</sub> = α<sup>X<sub>A</sub></sup> mod q
PU: {q, α, Y<sub>A</sub>}
PR: X<sub>A</sub>
###### ElGamal Cryptosystem의 Encryption 과정
세션 키 K 계산: K = (Y<sub>A</sub>)<sup>k</sup> mod q
C1 (세션 키 계산 용) 계산 : α<sup>k</sup> mod q (k는 random key)
C2 (메시지 계산 용) 계산: KM mod q
Y<sub>A</sub>, a를 k승한다고 생각
###### ElGamal Cryptosystem의 Decryption 과정
K Decryption: K = C<sub>1</sub><sup>X<sub>A</sub></sup> mod q
M Decryption: M = C<sub>2</sub>K<sup>-1</sup> mod q
###### Elliptic Curve Arithmetic 장점
RSA/DH보다 훨씬 짧은 키 길이로 동일한 수준의 보안을 제공
###### ECDH Key Exchange key generation
User A
PU: P<sub>A</sub> = n<sub>A</sub> x G
PR: n<sub>A</sub> = n보다 작은 임의의 정수

User B
PU: P<sub>B</sub> = n<sub>B</sub> x G
PR: n<sub>B</sub> = n보다 작은 임의의 정수
###### ECDH Key Exchange 과정
K = n<sub>A</sub> x P<sub>B</sub>
K = n<sub>B</sub> x P<sub>A</sub>
###### 전자 서명 하는 방법 5가지
RSA, ElGamal, Schnorr, DSA, ECDSA
###### DSA에서 subgroup을 사용하는 이유
DLP를 해결하는 두 가지 주요 알고리즘인 GNFS, Pollard rho 알고리즘에 의해 보안이 깨지지 않도록 큰 소수 p 위에 정의된 중간 크기의 cyclic subgroup(q)을 사용하면, 보안성을 유지하면서 지수 연산의 계산 효율성을 높일 수 있기 때문에 subgroup을 사용한다.
𝛼<sup>𝑥 mod 𝑞</sup> mod 𝑝
###### DLP를 해결하는 두 가지 주요 알고리즘
•	GNFS, General Number Field Sieve
	▪ *복잡도는 모듈러 p의 크기에 따라 달라짐*
	▪ 3072비트 p: 약 2<sup>128</sup> 연산 필요
•	Pollard rho 알고리즘
	▪ 생일 역설(birthday paradox)을 이용한 공격 (해시 충돌 탐색과 유사)
	▪ *복잡도는 x의 후보 수인 q에 따라 달라짐*
	▪ 2<sup>256</sup>개의 x 후보에 대해, 약 2<sup>128</sup> 연산 필요
	▪ 이를 위해 q ≈ 2<sup>256</sup>인 cyclic subgroup을 사용할 수 있음
###### Schnorr 인증이 무엇인지
DLP를 이용한 challenge-response 기반 사용자 인증 방식
**DLP를 이용한 상호작용 기반 zero knowledge 증명 프로토콜**
###### Fiat-Shamir 휴리스틱이란?
상호작용 기반 지식 증명을 입력으로 받아 디지털 서명을 생성하는 방식
###### Schnorr signature
Schnorr Identification과 Fiat-Shamir 휴리스틱을 사용하는 디지털 서명 방식
• 무작위 챌린지 𝑟을 H(M||𝛾)로 대체함
###### 전자 서명 알고리즘 세 개와 각각의 수학적 구조, 공통 요소
DSA, Schnorr Signature, ECDSA
DSA/Schnorr은 DLP, ECDSA는 타원곡선
공통 요소(무작위 k, 해시함수 H(M), 유사한 검증 전략)
###### X.509 특징
•	공개키 암호와 디지털 서명 기반
•	특정 알고리즘 사용은 강제하지 않음
•	사용 예시: IPSec, TLS, 공동인증서 등
###### 공개키 배분 authority 하는 법
![[Pasted image 20250529152538.png|500]]
1. 나 B의 공개 키 알고 싶어라고 timestamp와 함께 보냄
2. PR<sub>auth</sub>를 이용해 Bob의 공개키, Request, timestamp를 함께 보냄
3. A의 id와 Nounce를 Bob의 공개키로 암호화해서 보냄
4. B도 똑같이 하고 N1, N2를 보냄
5. A가 잘 받았다고 PU<sub>B</sub>로 N2를 다시 보냄
###### 공개키 인증서 하는 법
![[Pasted image 20250606204920.png|400]]
1. CA가 Alice의 공개키를 담은 인증서 발급 (C = S<sub>PR<sub>CA</sub></sub>(A, PU<sub>A</sub>))
2. Alice는 자신의 개인키로 서명한 Y<sub>A</sub>를 담은 Z (Z = S<sub>PR<sub>A</sub></sub>(A, Y<sub>A</sub>))와 Y<sub>A</sub> C를 보냄
3. Bob은 PU<sub>CA</sub>로 C 검증해 PU<sub>A</sub>로 Z 검증 => 보낸 Y<sub>A</sub>와 Z안의 Y<sub>A</sub>가 같으면 신뢰
Alice가 S<sub>PR<sub>A</sub></sub>(A, Y<sub>A</sub>)와 S<sub>PR<sub>CA</sub></sub>(A, PU<sub>A</sub>), Y<sub>A</sub>를 보냄
#### one cycle
###### Block chain 거래 방식
 peer-to-peer (P2P) 방식
###### Bitcoin 분산원장, 무결성, 기밀성
**분산 원장**을 사용하여 다수 참여자가 동일한 공개 거래 기록을 관리, *무결성 제공되나 기밀성 제공 안됨*
###### 비트 코인 주소
- 비트코인 주소는 ID인 동시에 전자서명 확인용 public key임 
- 비트코인의 수신자를 비트코인 주소로 명시 
- 비트코인의 송신자(지급자)는 연결된 이전 트랜잭션에 포함되었던 비트코인 주소(즉, 공개키)에 대응되는 개인 키를 이용하여 전자서명을 수행함으로써 지급 트랜잭션 완성 
- 모든 참여자들은 이전 트랜잭션에 포함된 공개키를 이용 하여 이 서명을 확인함으로써 트랜잭션 유효성 검증
###### Block chain이 조작이 어려운 이유
- 해시함수의 특성(one-way property, collision resistance): 해당 해시값이 변하지 않도록 하면서 조작 대상 블록의 다른 값 (예: nonce)을 같이 변경시키거나, 다른 트랜잭션들을 포함하면서 같은 해시값을 가지도록 하는 것은 거의 불가능함 
- 변경의 영향은 체인처럼 연결된 다음 블록들로 계속 전파되므로 맨 뒤 블록까지 모두 수정해야 함 
- 트랜잭션이 포함된 투명한 상자(블록)들의 탑(블록체인)의 복제 본이 수많은 참여자(노드)들 에게 저장되어 있으므로 조작이 더 어려움
###### Lightweight client
- Full client: 블록체인 전체를 보유 
- Lightweight client 
	- full client의 도움을 받음 
###### Bitcoin core
node + wallet (Open source SW)
###### 작업 증명
proof of work
###### Bitcoin에서 트랜잭션들 간의 연결관계 및 블록들 간의 연결관계 구현
SHA-256
###### 비트코인 보상 값
- 코인베이스(coinbase) 트랜잭션
	- 매 21만 개 블록(약 4년)마다 보상이 반감되도록 설계되었음
	- 총 통화량 2100만
- 거래 수수료 (transaction fee)
###### 통화량의 증가 속도를 조절하기 위해, 새로운 블록은 10분마다 생성되도록 설정한 것
pow difficulty
###### Bitcoin의 Scalability Issue를 해결하기 위한 방법
off-chain transactions (시작과 끝만 기록하는 느낌)
###### 트랜잭션 보낼 때 사용하는 알고리즘
Merkle Tree
###### 이더리움 블록체인 상에서 실행되는 프로그램과 언어
smart contract
Solidity language
###### 이더리움 블록체인과 다른점
비트코인과는 다르게, Turing-complete 한 기능 제공
이더리움은 잔고 표시를 한다.
final state를 다 저장하기에는 너무 커서 그건 따로 물리적 저장소에 저장한다.
###### 이더리움 주소 계산 방법
ECDSA public key에 Keccak을 사용해서 사용함
###### 허가받은 소수만 블록체인에 참여하는 허가형 블록체인
Hyperledger
###### 허가형 블록체인 예시
Hyperledger Fabric
###### NFT의 Data 기록
Data의 직접 기록 대신 외부에 저장된 디지털 매체에 대한 reference를 저장하는 것이 일반적
Blockchain에 기록된 metadata + ownership
Ethereum 상에 구현
###### 데이터셋의 예제에 대해 작지만 의도적으로 최악의 경우를 가정한 작은 변형을 가해 입력을 만든 후, 그 결과로 모델이 높은 확신을 가지고 오답을 출력하도록 함 
Evasion Attack
추론 시점 공격
###### poisoning 공격
학습 시점 공격
■ 악의적인 데이터셋 배포
■ backdoor attack
###### Homomorphic Encryption
■ 연산 가능한 암호화 방식
■ Homomorphic: 구조를 보존함
■ 암호화 후 연산 = 연산 후 암호화
###### Differential Privacy
데이터셋에 어떤 개인의 정보가 포함되어 있든 없든, 분석 결과의 확률 분포가 거의 같아야 한다
■ 간단한 연산 (노이즈 추가 방식)
■ 모델 반전, 멤버십 추론 방지에 유용
■ 정확도 일부 감소
###### 지도 학습 또는 반지도 학습 기반 분류는 AD에 적합하다
▣ 정상과 다르면 정의상 이상(anomaly)이므로,
이상들은 서로 유사할 필요가 없음
▣ 이 때문에 **지도 학습 또는 반지도 학습 기반 분류는 Anomaly Detection에 부적합**함
###### AD의 주요 두 가지 접근 방식
예측 기반 이상 탐지
재구성 기반 이상 탐지
###### 무결성 학습 시점 공격/추론 시점 공격
학습 시점 공격: Data poisoning / backdoor attack
⇒ Data sanitization
추론 시점 공격: Evasion Attack ⇒ Adversarial training, model ensemble
###### 학습 시점에 데이터 기밀성을 지키기 위한 방법
동형암호, MPC
