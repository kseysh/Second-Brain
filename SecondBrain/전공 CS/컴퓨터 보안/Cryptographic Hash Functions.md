## Contents
•	암호학적 해시 함수
•	암호학적 해시 함수의 응용
	1.	MAC = 키를 사용하는 해시
	2.	디지털 서명
	3.	비밀번호 보호
	4. 시스템 무결성: 침입 및 바이러스 탐지
	5.	PRF / PRNG
•	요구사항과 보안성
	•	무차별 대입 공격과 birthday paradox
•	보안 해시 알고리즘 (SHA)
## 해시 함수
•	해시 함수 H는 가변 길이의 데이터 블록 M을 입력으로 받아 고정된 크기의 해시 값 h를 출력함
	•	h = H(M)
	•	주요 목적은 데이터 무결성 유지
•	암호학적 해시 함수
	•	다음 두 가지 중 어느 하나라도 계산적으로 찾기 어려운 알고리즘
		(a) 특정 해시 값에 대응하는 입력 데이터를 찾는 것 (단방향성)
		(b) 동일한 해시 값을 생성하는 서로 다른 두 입력 데이터를 찾는 것 (충돌 회피성)
![[Pasted image 20250501155851.png|300]]
Hashing은 암호화와 다르게 input의 length가 달라도 output의 length는 항상 같다.
## Attack Against Hash Function
![[Pasted image 20250501155945.png|300]]
## 1. 메시지 인증 코드 (MAC)
•	keyed hash function로도 알려짐
•	비밀 키를 공유하는 두 당사자 간에 정보를 인증할 때 사용
•	비밀 키와 데이터 블록을 입력으로 받아 메시지에 부속된 해시 값(MAC)을 생성
	•	메시지 무결성을 확인할 때 MAC 함수를 다시 적용하고 기존 MAC 값과 비교
	•	공격자는 비밀 키 없이는 메시지를 조작해도 MAC 값을 변경할 수 없음
## 2. 디지털 서명
•	동작은 MAC과 유사
•	메시지의 해시 값을 사용자 개인 키로 암호화
•	공개 키를 가진 누구나 메시지의 무결성을 검증할 수 있음
•	공격자가 메시지를 조작하려면 개인 키를 알아야 함
•	디지털 서명은 단순한 메시지 인증을 넘어서는 의미를 가짐
### Simplified Examples of Digital Signatures
![[Pasted image 20250501160149.png|400]]
전자 서명은 나중에 또 나온다 함
## 기타 해시 함수 응용
3.	단방향 비밀번호 파일 생성
	•	사용자가 비밀번호를 입력하면 해당 해시 값을 저장된 해시 값과 비교하여 인증
	•	대부분의 운영체제가 이 방식으로 비밀번호 보호
4.	침입 및 바이러스 탐지
	•	각 파일 F에 대해 H(F)를 저장하고 이 값을 보호
	•	나중에 파일을 다시 해싱하여 변경 여부 확인
	•	침입자는 H(F)를 바꾸지 않고 F만 변경해야 하므로 어려움
5.	의사난수 함수(PRF) 또는 의사난수 생성기(PRNG) 구성에 사용
	•	PRF의 일반적 사용은 대칭 키 생성
## 두 가지 간단한 해시 함수
•	다음은 일반적인 방식으로 작동하는 두 가지 간단한(하지만 안전하지 않은) 해시 함수
	•	입력을 n비트 블록의 시퀀스로 처리
	•	각 블록을 반복적으로 처리하여 n비트 해시 값을 생성
1.	각 비트에 대해 블록들의 비트 XOR
	•	Ci = bi1 xor bi2 xor … xor bim
	•	각 비트 위치에 대해 단순 패리티 값을 생성 (세로 중복 검사)
	•	무작위 데이터에 대한 무결성 검사로는 비교적 효과적임
2.	각 블록 처리 후 해시 값을 1비트 원형 이동
	•	입력을 더 무작위화하고 규칙적인 패턴을 극복하는 효과 있음
![[Pasted image 20250501160352.png|200]]
=> 너무 쉽게 만들면 collision이 쉽게 생성될 수 있음
## 요구사항과 보안성
•	Preimage
	•	h = H(x)일 때, x는 h의 Preimage
	•	H는 다대일 함수이므로 하나의 해시 값에 대해 여러 개의 원상 이미지가 존재 가능
•	Collision
	•	x ≠ y이지만 H(x) = H(y)인 경우
	•	해시 함수는 데이터 무결성을 위한 것이므로 충돌은 바람직하지 않음
	•	Collision은 생길 수 밖에 없는데, 그 값을 찾기 어렵도록 해야한다.

## 암호학적 해시 함수 H의 요구 사항

| 요구 사항                                                                | **설명****                                                            |
| -------------------------------------------------------------------- | ------------------------------------------------------------------- |
| 가변 입력 크기 (Variable input size)                                       | H는 어떤 크기의 데이터 블록에도 적용될 수 있어야 한다.                                    |
| 고정 출력 크기 (Fixed output size)                                         | H는 고정 길이의 출력을 생성해야 한다.                                              |
| 효율성 (Efficiency)                                                     | H(x)는 주어진 x에 대해 상대적으로 쉽게 계산되어야 하며, 하드웨어와 소프트웨어 모두에서 구현이 실용적이어야 한다.  |
| Preimage resistant, one-way property                                 | 주어진 해시 값 h에 대해, H(y) = h가 되도록 하는 y를 찾는 것이 계산적으로 불가능해야 한다.           |
| Second preimage resistant, weak collision resistant                  | 주어진 블록 x에 대해, H(y) = H(x)가 되도록 하고 y ≠ x인 y를 찾는 것이 계산적으로 불가능해야 한다.   |
| 충돌 저항성 (강한 충돌 저항성) (Collision resistant, strong collision resistant) | 서로 다른 x ≠ y에 대해 H(x) = H(y)가 되도록 하는 쌍 (x, y)을 찾는 것이 계산적으로 불가능해야 한다. |
| 의사난수성 (Pseudorandomness)                                             | H의 출력은 의사난수성에 대한 표준 테스트를 충족해야 한다.                                   |
Collision resistant는 기억할 필요까지는 없다.
## 해시 함수에 대한 공격
•	Brute-Force Attacks
	•	특정 알고리즘이 아닌 해시 값의 비트 수에 의존
	•	무작위로 값을 선택하여 충돌이 발생할 때까지 반복 시도
•	암호 분석 (Cryptanalysis)
	•	특정 알고리즘의 약점을 이용한 공격
	•	전체 탐색 외의 방식으로 알고리즘의 속성을 이용해 공격
## Collision Resistant Attacks
•	일종의 무차별 대입 공격
•	공격자는 동일한 해시 값을 생성하는 두 메시지를 찾고자 함
	•	birthday paradox을 활용하여 공격
#### birthday paradox를 이용한 Collision Resistant Attack
•	A는 합법적인 메시지 x를 m비트 해시 코드로 서명할 준비
•	B는 의미는 같지만 다양한 x’를 2<sup>m/2</sup>개 생성하고 (x’, H(x’))를 저장
•	B는 조작된 메시지 y를 만들고 다양한 y’를 생성해 H(y’) = H(x’) 조건을 만족할 때까지 반복
•	그런 후 A에게 x’를 서명 요청
•	서명된 Sign(H(x’))을 Sign(H(y’))로 교체 가능
#### A Letter in 2<sup>38</sup> Variations
![[Pasted image 20250501161031.png|200]]
## General Structure of Secure Hash Code
![[Pasted image 20250501161100.png|300]]
## 보안 해시 알고리즘 (SHA)
•	SHA는 미국 NIST에서 설계하고 1993년에 FIPS 180으로 발표
•	1995년 SHA-1로 개정 → 160비트 해시 값 생성
•	2002년 SHA-2로 개정되어 256, 384, 512비트 해시 길이 제공
## SHA-3
•	SHA-1은 아직 실제적으로 “깨지지” 않았음
•	하지만 SHA-2는 이전 SHA들과 구조와 수학적 연산이 유사하여 잠재적 위험 존재
•	NIST는 SHA-2가 취약해질 가능성에 대비해 2007년 SHA-3 개발 경쟁 시작
•	2015년 최종 선정되어 FIPS PUB 202로 표준화
•	Keccak이라는 알고리즘이 채택됨 (설계자: Bertoni, Daemen, Peeters, van Assche)
### SHA-3 Parameters
![[Pasted image 20250501161202.png|400]]
### Sponge Construction
![[Pasted image 20250501161243.png|400]]

### SHA-3의 단계 함수

| 함수 유형   | 설명                                                  |
| ------- | --------------------------------------------------- |
| θ (세타)  | 각 워드의 각 비트는 해당 열의 앞뒤 워드의 특정 비트와 현재 값에 따라 갱신됨        |
| ρ (로)   | 각 워드의 비트들이 순환 시프트되어 순서 변경됨 (W[0, 0]은 영향 없음)         |
| π (파이)  | 5×5 행렬 구조에서 워드 위치가 바뀜 (W[0, 0]은 영향 없음)              |
| χ (카이)  | 각 워드의 비트는 같은 행의 다음 워드와 그 다음 워드의 특정 비트와 현재 값에 따라 변경됨 |
| ι (이오타) | W[0, 0]에 라운드 상수를 XOR하여 업데이트                         |
