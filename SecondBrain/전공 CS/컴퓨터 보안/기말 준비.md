###### Cryptographic hash function의 응용
1.	MAC = keyed hash
2.	디지털 서명
3.	비밀번호 보호
4. 시스템 무결성: 침입 및 바이러스 탐지
5.	PRF / PRNG
###### Cryptographic hash function이란?
•	다음 두 가지 중 어느 하나라도 계산적으로 찾기 어려운 알고리즘
	(a) 특정 해시 값에 대응하는 입력 데이터를 찾는 것 (단방향성)
	(b) 동일한 해시 값을 생성하는 서로 다른 두 입력 데이터를 찾는 것 (충돌 회피성)
###### Preimage란?
•	h = H(x)일 때, x는 h의 Preimage
•	H는 다대일 함수이므로 하나의 해시 값에 대해 여러 개의 원상 이미지가 존재 가능
###### Collision이란?
•	x ≠ y이지만 H(x) = H(y)인 경우
•	해시 함수는 데이터 무결성을 위한 것이므로 충돌은 바람직하지 않음
•	Collision은 생길 수 밖에 없는데, 그 값을 찾기 어렵도록 해야한다.
###### Cryptographic Hash Function H의 요구사항
가변 입력 크기
고정 출력 크기
효율성
Preimage resistant, one-way property
Second preimage resistant, 약한 충돌 저항성
강한 충돌 저항성
의사난수성
###### 해시 함수에 대한 공격
•	Brute-Force Attacks
•	암호 분석 (Cryptanalysis)
###### birthday paradox를 이용한 Collision Resistant Attack
•	A는 합법적인 메시지 x를 m비트 해시 코드로 서명할 준비
•	B는 의미는 같지만 다양한 x’를 2<sup>m/2</sup>개 생성하고 (x’, H(x’))를 저장
•	B는 조작된 메시지 y를 만들고 다양한 y’를 생성해 H(y’) = H(x’) 조건을 만족할 때까지 반복
•	그런 후 A에게 x’를 서명 요청
•	서명된 Sign(H(x’))을 Sign(H(y’))로 교체 가능
###### SHA-3 algorithm
Keccak
###### SHA 해시 길이 종류
256, 384, 512
###### SHA-3의 단계 함수 순서 / 이름
Sponge Construction
θ (세타)
ρ (로)
π (파이)
ι (이오타)
###### SHA-3의 단계 함수 설명
| 함수 유형   | 설명                                                  |
| ------- | --------------------------------------------------- |
| θ (세타)  | 각 워드의 각 비트는 해당 열의 앞뒤 워드의 특정 비트와 현재 값에 따라 갱신됨        |
| ρ (로)   | 각 워드의 비트들이 순환 시프트되어 순서 변경됨 (W[0, 0]은 영향 없음)         |
| π (파이)  | 5×5 행렬 구조에서 워드 위치가 바뀜 (W[0, 0]은 영향 없음)              |
| χ (카이)  | 각 워드의 비트는 같은 행의 다음 워드와 그 다음 워드의 특정 비트와 현재 값에 따라 변경됨 |
| ι (이오타) | W[0, 0]에 라운드 상수를 XOR하여 업데이트                         |
###### MAC으로 인해 방지할 수 있는 위협
•	가장 공격(Masquerade)
•	내용/순서/타이밍 변경
###### HMAC 특징
대칭 블록 암호보다 소프트웨어에서 일반적으로 더 빠르게 실행됨
HMAC은 IP 보안을 위한 필수 구현 MAC으로 채택됨
NIST 표준(FIPS 198-1)으로도 제정됨
###### CBC MAC 단점과 해결
•	MAC(K, X) = T이면, MAC(X || (X ⊕ T)) = T도 성립함

마지막 블록에 대해 파생 키(K1 또는 K2)를 한 번 더 XOR 연산
•	입력에 메시지 길이를 인코딩하여 포함
	이렇게 하면 block을 추가할 수 없음
###### AE란? / AE 접근 방식
•	통신의 기밀성과 무결성을 동시에 보호하는 암호 시스템을 지칭하는 용어

•	인증 후 암호화: CCM
•	암호화 후 인증: GCM (Galois CTR 모드)
•	독립적으로 암호화 및 인증: 안전하지 않음
###### Counter + CBC-MAC
Encrypt는 counter mode로 하고, 암호화는 CBC-MAC을 사용하겠다는 의미
IEEE 802.11 WiFi 무선 근거리 통신망의 보안 요구사항을 지원하는 표준
Authenticate (MAC) then encrypt 방식 사용
###### Counter + CBC-MAC 알고리즘 구성 요소
AES, CTR mode, CBC-MAC
###### Hash 관련 난수 생성 하는 법
Hash_DRBG, HMAC_DRBG
# Quiz
###### RSA 암호화 목적 세가지에 따른 암호화, 복호화, 보안 기능
여기서 A가 송신자, B가 수신자

| **목적**                               | **암호화 키**                       | **복호화 키**                       | **보장되는 보안 기능** |
| ------------------------------------ | ------------------------------- | ------------------------------- | -------------- |
| 9.2 Confidentiality                  | PU<sub>b</sub>                  | PR<sub>b</sub>                  | 기밀성            |
| 9.3 Authentication                   | PR<sub>a</sub>                  | PU<sub>a</sub>                  | 인증(부인 방지)      |
| 9.4 Authentication + Confidentiality | PR<sub>a</sub> → PU<sub>b</sub> | PR<sub>b</sub> → PU<sub>a</sub> | 기밀성 + 인증       |
###### Authentication + Confidentiality에서 송신자의 PR, PU가 어떤 목적을 가지고 사용되는지
1. 송신자 A는 메시지 X를 자신의 PRa로 암호화 Y = E(PR<sub>a</sub>, X)
	- 서명 생성
2. Y를 다시 수신자 B의 PU<sub>b</sub>로 암호화 Z = E(PU<sub>b</sub>, Y)
	- 기밀성
3. 수신자 B는 자신의 PR<sub>b</sub>로 복호화 Y = D(PR<sub>b</sub>, Z)
	- 기밀성 복호화
4. 수신자 B는 A의 PUa로 복호화 X = D(PU<sub>a</sub>, Y)
	- 서명 검증
###### 공개키 암호 시스템 응용분야 RSA, Elliptic Curve, DH, DSS
![[Pasted image 20250506175832.png|300]]
###### RSA Encryption, Decryption 방법
PU = (e, n) 
PR = (d, n)
C = M<sup>e</sup> mod n 
M = C<sup>d</sup> mod n
###### RSA에서 𝐶<sup>𝑑</sup> mod 𝑛이 M이 되는 이유
gcd(𝑀, 𝑛) = 1 이고 𝑒𝑑 = 𝑘𝜙(𝑛) + 1 일 때,
𝐶<sup>𝑑</sup> mod 𝑛 = (𝑀<sup>𝑒</sup> mod 𝑛)<sup>𝑑</sup> mod 𝑛 => C = 𝑀<sup>𝑒</sup> mod 𝑛 이므로
      = 𝑀<sup>𝑒𝑑</sup> mod 𝑛 => mod 연산의 성질로 이렇게 표현 가능
      = 𝑀<sup>𝑘𝜙(𝑛)</sup>× 𝑀 mod 𝑛
      = (𝑀<sup>𝜙(𝑛)</sup>)<sup>𝑘</sup> × 𝑀 mod 𝑛 = 𝑀 => Euler totient function에 의해 𝑀<sup>𝜙(𝑛)</sup> = 1
###### Plain text 88, PU 7, 187 PR 23, 187 일 때, Encryption, Decryption
88<sup>7</sup>mod 187 = 11
11<sup>23</sup>mod 187 = 88
###### M이 n보다 클 때 해결 방법 두 가지
1. ECB 모드처럼 메시지를 블록으로 나눠 각각 암호화 한다.
2. 대칭키와 공개키를 결합하는 하이브리드 암호화를 사용한다
	1. RSA로 K 암호화
	2. CTR모드로 K를 사용해 데이터 암호화
###### RSA로 전자 서명 하는 법
송신자
S = M<sup>d</sup> mod n
수신자
M' = S<sup>e</sup> mod n
메시지 M과 전자서명 S를 같이 보낸다.
Alice의 공개 키 e,n을 가지고 M,S를 서명확인할 수 있어 부인 방지가 가능하다
추가적으로 M과 M'이 같다는 것을 알면 무결성도 확인 가능하다
###### 지수 연산 하는 파이썬 코드
7<sup>1</sup>을 이용해 7<sup>10</sup>을 만들고 이를 이용해 7<sup>1000110000</sup>을 만드는 방법
```python
def exp(a, b, n):
    f = 1
    bin_b = int_to_bin(b)
    k = len(bin_b)
    for i in range(k):   # Fill this part.
        f = (f * f) % n
        if bin_b[i] == '1':
            f = (f * a) % n
    return f
```
###### 지수 연산 복잡도
비트 자리 수 정도만 하므로 k bit라면, k x 3/2 정도의 곱셈을 하게 된다.
###### RSA에서의 공개 키 값이 65537을 사용하는 이유
•	RSA에서 공개키 사용 시 속도를 높이기 위해 e 값은 보통 특정 값으로 설정
•	가장 일반적인 값: 65537 (2¹⁶ + 1)
이 값은 1 비트가 적어 곱셈 횟수가 최소화 됨
###### Private key의 효율적 연산 방법
•	복호화는 d 제곱 연산 포함
	•	d가 작으면 무차별 대입 공격 등 다양한 공격에 취약 (그래서 d는 작게 하면 안됨)
•	계산 속도를 높이기 위해 중국인의 나머지 정리(CRT) 사용 가능
	•	d mod (p-1), d mod (q-1)을 미리 계산
	•	직접 계산보다 약 4배 빠르게 처리 가능
###### RSA에 대한 공격 방식 5가지
•	Brute force: 가능한 모든 개인키 시도
•	Mathematical attacks: 두 소수의 곱을 인수분해
•	Chosen ciphertext attacks (CCA): RSA의 동형성 속성 악용
•	Implementation attacks: 
	•	side-channel
		예: 시간 분석, 전력 분석
	•	Hardware fault-based attack
		•	복호화 또는 서명 중인 프로세서에 인위적 오류 유도
###### Factoring Problem 3가지
1. n을 소인수 분해하는 방법
	- n = p x q의 두 소수로 분해하면,
	- 오일러 함수 φ(n) = (p-1)(q-1)를 계산 할 수 있음
	- 이 값을 통해 비밀 키 d를 e<sup>-1</sup>mod φ(n)로 계산 가능
2. p, q 없이 φ(n) 직접 계산하는 방법
3.	φ(n) 없이 d를 직접 계산
###### CCA
Chosen Ciphertext Attack
공격자는 임의의 평문을 선택해 타겟의 공개 키로 암호화하고, 이를 다시 개인 키로 복호화함으로써 평문을 얻을 수 있다
암호문을 살짝 바꿔서 새로운 암호문을 만들어 복호화를 요청(query to decryption oracle)하고, 이를 수학적으로 계산하여 원래 메시지 M을 알아내는 방법
###### OAEP
원래, C = M<sup>e</sup> mod n
OAEP: C = (EM)<sup>e</sup> mod n
EM = encoded message
###### side-channel attacks의 대응책
•	키에 독립적인 연산 (예: 일정한 시간의 지수 계산)
•	무작위성 도입 (예: 무작위 지연)
###### Fault based Attack
•	RSA 서명을 생성 중인 프로세서를 공격
	•	전력을 줄여 계산 중 오류를 유도
	•	잘못된 서명 결과를 분석해 개인키 유추
•	알고리즘은 단일 비트 오류를 유도하고 결과를 관찰함
###### CRT를 이용한 Fault Based Attack
- 공격자가 한쪽 모듈러 연산 (예: mod p)만 오류를 일으키면, 서명 값이 잘못되면서, 이 정보를 이용해 p 또는 q 중 하나를 추출할 수 있다.
###### CRT를 이용해 RSA계산을 빠르게 하는 법
RSA 계산에서 N = pq에 대해, 계산을 더 빠르게 하기 위해 mod p, mod q로 나누어 처리할 수 있다. (CRT 사용)
###### 공개 키 암호 vs. 대칭키 암호 안전성
대칭키 암호 128bit: brute force 사용
RSA 2048 bit: Factoring을 이용한 2<sup>112</sup> 복잡도로 깨짐
###### 공개 키 암호 vs. 대칭 키 암호 기능
공개 키 암호: 상대의 공개 키가 정말 상대의 공개 키인지 몰라 man-in-the-middle attack이 발생할 수 있고 이로 인해 복잡한 키 교환 절차가 필요할 수 있다.
대칭키: 빠름
공개키: 느림, 대칭키를 안전하게 전달하는데 사용됨
###### Discrete log를 사용하는 공개키 암호 시스템
DH
Elgamal
타원 곡선 암호는 Discrete log와 구조상으로 비슷 사용은 X
###### DH key 교환
송신자는 X<sub>A</sub>를 가지고, Y<sub>A</sub> = a<sup>X<sub>A</sub></sup> mod q를 수신자에게 보냄
수신자도 X<sub>B</sub>를 가지고, Y<sub>B</sub> = a<sup>X<sub>B</sub></sup> mod q를 송신자에게 보냄
K = (Y<sub>B</sub>)<sup>X<sub>A</sub></sup> mod q = (Y<sub>A</sub>)<sup>X<sub>B</sub></sup> mod q임
###### Forward Secrecy란?
Forward Secrecy: 앞쪽은 안전하다!
RSA의 경우, 영구적인 개인 키를 사용하기 때문에, cipher text 값을 logging해서 가지고 있다면, 2에서 뚫려도 1도 뚫릴 수 있다.
따라서 이를 사용하는 이전 모든 세션이 뚫릴 수 있다.
###### DH Forward Secrecy, Man-in-the middle attack
Forward Secrecy: 만족 (X<sub>A</sub>, X<sub>B</sub>를 한 세션만 쓰고 사용 후 버리기 때문)
Man-in-the middle attack: 당할 수 있음 (중간에 각각 Y<sub>A</sub>, Y<sub>B</sub>를 가로채 통신할 수 있기 때문)
###### ElGamal Cryptosystem의 전역 공개 요소
q : 큰 소수
a: q의 primitive root
###### ElGamal Cryptosystem의 key generation
Y<sub>A</sub> = α<sup>X<sub>A</sub></sup> mod q
PU: {q, α, Y<sub>A</sub>}
PR: X<sub>A</sub>
###### ElGamal Cryptosystem의 Encryption 과정
세션 키 K 계산: K = (Y<sub>A</sub>)<sup>k</sup> mod q
C1 (세션 키 계산 용) 계산 : α<sup>k</sup> mod q
C2 (메시지 계산 용) 계산: KM mod q
###### ElGamal Cryptosystem의 Decryption 과정
K Decryption: K = C<sub>1</sub><sup>X<sub>A</sub></sup> mod q
M Decryption: M = C<sub>2</sub>K<sup>-1</sup> mod q
###### Elliptic Curve Arithmetic 장점
RSA/DH보다 훨씬 짧은 키 길이로 동일한 수준의 보안을 제공
###### ECC에서 덧셈 곱셈
ECC에서의 덧셈 연산은 RSA에서의 모듈러 곱셈에 해당
다중 덧셈(= 스칼라 곱셈, 점 곱셈)은 RSA에서의 모듈러 거듭제곱에 해당
###### ECDLP
 elliptic curve discrete logarithm problem
 곡선 E, P, Q를 죽 Q = kp를 만족하는 k를 찾는 것
###### 타원 곡선 암호 해독 하는 가장 빠른 기법
Pollard rho method
###### ECC DH Key Exchange 전역 공개 요소
E<sub>q</sub>(a,b) : 타원 곡선
G: 타원 곡선 위의 점
###### ECC DH Key Exchange key generation
User A
PU: P<sub>A</sub> = n<sub>A</sub> x G
PR: n<sub>A</sub> = n보다 작은 임의의 정수

User B
PU: P<sub>B</sub> = n<sub>B</sub> x G
PR: n<sub>B</sub> = n보다 작은 임의의 정수
###### ECC DH Key Exchange 과정
K = n<sub>A</sub> x P<sub>B</sub>
K = n<sub>B</sub> x P<sub>A</sub>
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
