###### Process state
- new
- running
- waiting
- ready
- terminated
- blocking 없음
###### process에서의 두 가지 특성
- *자원 소유의 단위*
	- 프로세스 이미지를 저장하기 위한 가상 주소 공간 할당
	- 파일, I/O 장치 등 *일부 자원에 대한 제어 권한 보유*
	- 일반적으로 Process or Task라고 한다.
- *실행 흐름의 단위*
	- 제어 스레드를 가짐
	- 실행 상태 및 *dispatch 우선 순위를 가짐*
	- 프로세스 실행은 다른 프로세스와 교차되어 수행될 수 있음
	- thread라고 한다.
###### Implicit Threading이란?
프로그래머보다 compiler와 *run-time library가 thread의 생성 및 관리를 담당*하는 것
 - 주요 방식
	 - Thread Pools (스레드 풀)
    - OpenMP
    - Grand Central Dispatch
###### OpenMP란?
컴파일러가 알아서 확인하면 multithread를 생성 및 관리해줌
*CPU core의 개수만큼 스레드를 생성해 병렬처리를 지원*해준다
`#pragma omp parallel`
###### 스레드의 개념과 프로세스와의 차이점
프로세스 안에 스레드가 여러개 있는 것이고, 스레드는 프로세스에서 execution stream을 여러개 분리한 것
###### Dispatcher의 역할
CPU 스케쥴러가 선택한 프로세스에 CPU 제어권을 넘겨준다
• Context Switching
• user mode로 전환
• 해당 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 jump
###### 다중 프로세서 내에서 동일한 코어를 사용하는 경우 각 스케쥴링 방식
- `Asymmetric multiprocessing`: *하나의 프로세서만 시스템 데이터 구조에 접근*하여 데이터 공유에 대한 필요를 줄임
- `Symmetric multiprocessing, SMP`: 각 프로세서가 자체적으로 스케줄링을 수행하며, 모든 프로세스는 공통의 준비 큐에 있거나 각자 고유한 준비 큐를 가질 수 있음
	- 현재 가장 일반적인 방식
###### SMP에서 ready queue 관리 방식
- Common ready queue
	- 모든 스레드가 하나의 common ready queue에 존재할 수 있음
	- 코어 수가 많으면 동기화 문제가 발생할 수 있음
- Per-core ready queue
	- 각 프로세서가 자신만의 독립된 스레드 큐를 가질 수 있음
	- 코어마다 load가 불균형할 가능성이 있음
	- cache hit rate가 늘어남 (코어에 캐시가 저장되므로)
###### Real-Time CPU Scheduling에서 성능에 영향을 미치는 두 가지 지연(latency)
1. Interrupt latency: 인터럽트가 도착한 시점부터 ISR(인터럽트 서비스 루틴)이 시작될 때까지의 시간
2. Dispatch latency: Context Switching에 걸리는 시간
###### peterson's solution이 현대 컴퓨터에서 조건을 만족하지 않는 이유
피터슨의 해법은 현대 컴퓨터 아키텍처에서는 항상 동작한다고 보장할 수 없음
→ 프로세서나 컴파일러가 의존성이 없는 읽기/쓰기 연산의 순서를 바꿀 수 있음
![[Pasted image 20250408171904.png|300]]
###### semaphore with busy waiting code
![[Pasted image 20250410164421.png|400]]
###### semaphore with no busy waiting code
![[Pasted image 20250410164744.png|400]]
###### block, wakeup operation
- Two operations
	- block: 해당 연산을 호출한 프로세스를 적절한 대기 큐에 넣음
	- wakeup: 대기 큐에 있는 프로세스 중 하나를 제거하여 준비 큐(ready queue)로 이동시킴













