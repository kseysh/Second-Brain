###### 60-90년대 OS 발전
파일 시스템 추가
Interactive time-sharing OS
Response time, protection 중요해짐
###### 90~ OS 발전
- Internet acess가 built in
- Multi tasking 중요
- Multimedia support
###### IO 컨트롤러의 주요 레지스터
•	데이터 레지스터 (입력, 출력)
•	제어 레지스터 (제어, 상태)
###### Polling I/O vs. Interrupt-driven I/O
- Polling I/O: *CPU가 I/O 상태 레지스터를 계속 확인*하여 작업이 완료되었는지 검사
- Interrupt-driven I/O: *I/O 컨트롤러가 작업 완료 시 인터럽트를 발생*하여 CPU에 알림
###### DMA란?
Direct Memory Access
- **장치 컨트롤러가 CPU의 개입 없이 버퍼 스토리지와 메인 메모리 간에 데이터 블록을 직접 전송할 수 있도록 하는 장치**
- I/O 작업만 담당하는 CPU라고 생각하자
- 큰 메모리 Access를 한 번에 하는 것이 어렵기 때문에 DMA를 활용해서 옮긴다.
- Keyboard 입력 같은 경우는 데이터의 크기가 크지 않아 CPU에 그냥 인터럽트를 보낸다.
- 한 블록당 한 번의 인터럽트만 발생 (바이트당 한 번의 인터럽트 발생과 비교하여 효율적)
###### Microkernel (Mach)의 정의
중요하지 않은 컴포넌트는 커널에서 다 빼고 유저 레벨 프로그램에서 작성하도록 하는 방법
message 전달을 통해 사용자 모듈간 통신을 한다.
###### Process state
- new
- running
- waiting
- ready
- terminated
- blocking 없음
###### Job queue란
시스템에서 모든 프로세스가 저장되는 큐
사용자가 프로그램 실행 시 Job queue에 들어가고, OS가 메모리 공간을 할당하면 Ready queue에 들어감
###### build from scratch 방식
- loading 과정: code, data를 program file에서 읽어서 *memory에 적재* (stack, heap은 실행하면서 생기므로)
- create empty stack (메모리에 자리만 잡아준다.)
- PCB 만들기
- 해당 PCB를 ready queue에 넣기
###### 프로세스 복제
- 현재 state 저장(PC, register)
- *memory context 복사*
- PCB 복사 (pid, parent, child만 변경)
- 해당 PCB -> ready queue로 복사
###### Message passing 방식과 단점
커널이 *메시지 큐를 이용*해 아래 두 함수를 이용해 소통한다.
- msgsnd()
	- 커널 공간에 메시지를 쌓는다.
- msgrcv()
	- 커널 공간에 쌓은 메시지를 읽는다.
- 실질적으로 메시지 복사가 필요하다.
	- 따라서 대용량 전달이 비효율적이다 
###### 멀티 스레드의 장점
- 응답성
	- 프로세스의 일부(스레드)가 Block되어도 계속 실행될 수 있다.
- **자원 공유**
	- 스레드는 프로세스의 자원을 공유하며, shared memory나 메시지 전달 방식보다 더 쉽게 사용할 수 있다.
	- IPC가 필요하지 않다.
- 경제적
	- 프로세스 생성/종료보다 시간이 적게 든다
	- 같은 프로세스의 thread간 변경 비용이 적다.
	- Stack 과 스레드 당 static memory의 적은 리소스를 사용한다.
- 확장성
	- multiprocessor(CPU 코어가 여러개) architecture의 장점을 가질 수 있다.
###### process에서의 두 가지 특성
- *자원 소유의 단위*
	- 프로세스 이미지를 저장하기 위한 가상 주소 공간 할당
	- 파일, I/O 장치 등 *일부 자원에 대한 제어 권한 보유*
	- 일반적으로 Process or Task라고 한다.
- *실행 흐름의 단위*
	- 제어 스레드를 가짐
	- 실행 상태 및 *dispatch 우선 순위를 가짐*
	- 프로세스 실행은 다른 프로세스와 교차되어 수행될 수 있음
	- thread라고 한다.
###### Implicit Threading이란?
프로그래머보다 compiler와 *run-time library가 thread의 생성 및 관리를 담당*하는 것
 - 주요 방식
	 - Thread Pools (스레드 풀)
    - OpenMP
    - Grand Central Dispatch
###### OpenMP란?
컴파일러가 알아서 확인하면 multithread를 생성 및 관리해줌
*CPU core의 개수만큼 스레드를 생성해 병렬처리를 지원*해준다
`#pragma omp parallel`
###### 스레드의 개념과 프로세스와의 차이점
프로세스 안에 스레드가 여러개 있는 것이고, 스레드는 프로세스에서 execution stream을 여러개 분리한 것
###### Dispatcher의 역할
CPU 스케쥴러가 선택한 프로세스에 CPU 제어권을 넘겨준다
• Context Switching
• user mode로 전환
• 해당 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 jump
###### 다중 프로세서 내에서 동일한 코어를 사용하는 경우 각 스케쥴링 방식
- `Asymmetric multiprocessing`: *하나의 프로세서만 시스템 데이터 구조에 접근*하여 데이터 공유에 대한 필요를 줄임
- `Symmetric multiprocessing, SMP`: 각 프로세서가 자체적으로 스케줄링을 수행하며, 모든 프로세스는 공통의 준비 큐에 있거나 각자 고유한 준비 큐를 가질 수 있음
	- 현재 가장 일반적인 방식
###### SMP에서 ready queue 관리 방식
- Common ready queue
	- 모든 스레드가 하나의 common ready queue에 존재할 수 있음
	- 코어 수가 많으면 동기화 문제가 발생할 수 있음
- Per-core ready queue
	- 각 프로세서가 자신만의 독립된 스레드 큐를 가질 수 있음
	- 코어마다 load가 불균형할 가능성이 있음
	- cache hit rate가 늘어남 (코어에 캐시가 저장되므로)
###### Real-Time CPU Scheduling에서 성능에 영향을 미치는 두 가지 지연(latency)
1. Interrupt latency: 인터럽트가 도착한 시점부터 ISR(인터럽트 서비스 루틴)이 시작될 때까지의 시간
2. Dispatch latency: Context Switching에 걸리는 시간
###### peterson's solution이 현대 컴퓨터에서 조건을 만족하지 않는 이유
피터슨의 해법은 현대 컴퓨터 아키텍처에서는 항상 동작한다고 보장할 수 없음
→ 프로세서나 컴파일러가 의존성이 없는 읽기/쓰기 연산의 순서를 바꿀 수 있음
![[Pasted image 20250408171904.png|300]]
###### semaphore with busy waiting code
![[Pasted image 20250410164421.png|400]]
###### semaphore with no busy waiting code
![[Pasted image 20250410164744.png|400]]
###### block, wakeup operation
- Two operations
	- block: 해당 연산을 호출한 프로세스를 적절한 대기 큐에 넣음
	- wakeup: 대기 큐에 있는 프로세스 중 하나를 제거하여 준비 큐(ready queue)로 이동시킴













