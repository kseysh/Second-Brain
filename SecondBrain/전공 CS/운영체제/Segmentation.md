## Problem of Contiguous Allocation
• 프로세스당 하나의 세그먼트(파티션)만 허용됨
	• 개인 데이터 영역은 유지하면서 두 프로세스가 코드를 어떻게 공유할 수 있을까?
• 프로그램은 여러 세그먼트로 구성된 집합임
	• 세그먼트는 다음과 같은 논리적 단위임:
		• 메인 프로그램
		• 함수
		• 객체
		• 지역 변수, 전역 변수
		• 스택
		• 심볼 테이블
		• 배열
## Segmentation
메모리의 유저 뷰를 지원하는 메모리 관리 스키마
![[Pasted image 20250522164000.png|150]]
• 프로세스가 여러 메모리 영역에 나뉘어 존재하는 것을 허용
• 각 세그먼트에 대해 개별적인 베이스와 리미트 레지스터 쌍을 사용하며, 두 개의 보호 비트(읽기 및 쓰기)도 추가
• 각 메모리 참조는 세 가지 방식 중 하나 이상으로 세그먼트와 오프셋을 지정
	• 주소의 상위 비트는 세그먼트를 선택하고, 하위 비트는 오프셋을 나타냄
	• 명령어에 의해 암시적으로 세그먼트가 선택됨
		• 예시: 코드 vs. 데이터, 스택 vs. 데이터
	• 세그먼트 테이블은 프로세스의 모든 세그먼트에 대한 베이스와 리미트를 저장
## Logical View of Segmentation
![[Pasted image 20250522164213.png|300]]

## Segmentation Architecture (1)
• 논리 주소는 두 개의 튜플로 구성됨
• <세그먼트 번호, 오프셋>
• 세그먼트 테이블은 이차원 물리 주소를 매핑함
• base - 세그먼트가 메모리 내에 위치하는 시작 물리 주소
• limit - 세그먼트의 길이
• 세그먼트 테이블 베이스 레지스터(STBR)는 세그먼트 테이블의 메모리 위치를 가리킴
• 세그먼트 테이블 길이 레지스터(STLR)는 프로그램이 사용하는 세그먼트의 수를 나타냄
• 세그먼트 번호 s는 s < STLR일 때 유효함