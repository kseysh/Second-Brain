다음은 요청하신 글의 한글 번역입니다:

⸻

가상 메모리의 동기
	•	코드와 데이터를 실행하려면 메모리에 있어야 하지만, 전체 프로그램이 항상 사용되는 것은 아니다
	•	오류 처리 코드, 특이한 루틴, 큰 데이터 구조 등은 드물게 사용됨
	•	부분적으로 적재된 프로그램을 실행할 수 있다면 좋음
	•	프로그램이 물리적 메모리 용량의 제약을 받지 않게 됨
	•	실행 중인 각 프로그램이 적은 메모리를 차지함 → 동시에 더 많은 프로그램 실행 가능
	•	응답 시간이나 반환 시간의 증가 없이 CPU 활용률과 처리량이 향상됨
	•	프로그램을 메모리에 적재하거나 교체(swap)하는 데 필요한 I/O가 줄어듦 → 사용자 프로그램이 더 빠르게 실행됨

⸻

가상 메모리 (1)
	•	사용자 논리 메모리와 물리 메모리의 분리
	•	실행을 위해 프로그램의 일부만 메모리에 존재하면 됨
	•	논리 주소 공간이 물리 주소 공간보다 훨씬 클 수 있음
	•	여러 프로세스가 주소 공간을 공유 가능
	•	프로세스 생성이 더 효율적임
	•	더 많은 프로그램을 동시에 실행 가능
	•	프로세스를 적재하거나 교체하는 데 필요한 I/O 감소
	•	가상 주소 공간: 프로세스가 메모리에 저장된 방식에 대한 논리적 관점
	•	일반적으로 주소 0부터 시작해서 연속된 주소를 가짐
	•	물리 메모리는 페이지 프레임 단위로 구성됨
	•	MMU가 논리 주소를 물리 주소로 매핑해야 함
	•	가상 메모리는 다음 방식으로 구현 가능
	•	요청 페이징(Demand Paging)
	•	요청 세그멘테이션(Demand Segmentation)
	•	가상 메모리는 물리 메모리보다 크다
	•	가상 주소 공간
	•	코드에서 스택까지 0에서 최대까지의 연속된 메모리 공간
	•	스택과 힙 사이에 사용되지 않는 주소 공간 존재
	•	시스템 라이브러리는 가상 주소 공간에 매핑하여 공유됨
	•	페이지를 읽기-쓰기 형태로 가상 주소 공간에 매핑하여 공유 메모리 구현 가능
	•	fork() 시 페이지 공유를 통해 프로세스 생성 속도 향상
	•	가상 메모리를 이용한 공유 라이브러리

⸻

요청 페이징(Demand Paging)

요청 페이징의 기본 개념 (1)
	•	필요한 페이지만 메모리에 불러옴
	•	불필요한 I/O 없음 → 더 적은 I/O
	•	더 적은 메모리 사용
	•	응답 시간 단축
	•	더 많은 사용자 수용
	•	스와핑을 사용하는 페이징 시스템과 유사함
	•	페이지가 필요함 → 참조 발생
	•	잘못된 참조 → 중단
	•	메모리에 없으면 → 메모리로 불러오기
	•	Lazy Swapper: 실제로 필요한 페이지만 메모리에 적재
	•	페이지를 다루는 swapper는 pager라고 함
	•	요청 페이징을 구현하려면 MMU에 새로운 기능이 필요
	•	필요한 페이지가 이미 메모리에 있다면
	•	일반 페이징과 차이 없음
	•	필요한 페이지가 메모리에 없다면
	•	저장 장치에서 해당 페이지를 감지하고 불러와야 함
	•	프로그램 동작을 바꾸지 않아야 함
	•	프로그래머가 코드를 변경할 필요 없음

⸻

유효-무효 비트(Valid-Invalid Bit)
	•	각 페이지 테이블 항목마다 유효-무효 비트를 둔다
	•	v → 메모리에 존재 (유효)
	•	i → 메모리에 없음 (무효)
	•	처음에는 모든 항목의 비트를 i로 설정
	•	예시: 페이지 테이블 스냅샷
	•	MMU가 주소 변환 시 해당 비트가 i이면 → 페이지 폴트 발생

⸻

페이지 폴트 (1)
	•	페이지 참조가 발생하면, 해당 페이지에 대한 첫 참조 시 운영체제로 trap 발생 (페이지 폴트)

	1.	운영체제가 다른 테이블을 확인함
	•	잘못된 참조 → 중단
	•	단지 메모리에 없을 경우
	2.	빈 프레임 찾기
	3.	디스크 작업을 통해 해당 페이지를 프레임에 스와핑
	4.	페이지가 메모리에 있다고 테이블 갱신, 유효-무효 비트 = v
	5.	페이지 폴트를 유발한 명령어를 재시작

⸻

요청 페이징의 특징
	•	순수 요청 페이징: 처음에는 아무 페이지도 메모리에 없이 프로세스 시작
	•	OS는 프로세스의 첫 명령어 위치로 IP를 설정 → 메모리에 없음 → 페이지 폴트
	•	다른 모든 페이지들도 처음 접근 시 페이지 폴트
	•	실제로는 하나의 명령어가 여러 페이지를 접근할 수도 있음 → 다중 페이지 폴트
	•	예시: 메모리에서 두 수를 더하고 결과를 저장하는 명령어의 fetch/decode 과정
	•	지역성(locality of reference) 때문에 이러한 비용이 완화됨
	•	요청 페이징을 위한 하드웨어 지원 필요
	•	유효/무효 비트를 갖는 페이지 테이블
	•	보조 기억장치 (swap 장치)
	•	명령어 재시작 기능

⸻

명령어 재시작
	•	페이지 폴트가 명령어 중간에서 발생할 수 있기 때문에 프로세스를 계속 실행시키는 것은 매우 까다롭다
	•	사용자 프로세스는 페이지 폴트가 발생한 사실조차 몰라야 함
	•	해당 명령어를 건너뛰는 것은 불가능
	•	프로세스에 투명하지 않음
	•	명령어는 처음부터 다시 실행되어야 함
	•	자동 증가/감소 같은 명령어는 어떻게 처리할까?
	•	명령어 재시작을 위한 하드웨어 지원이 필요함

⸻
