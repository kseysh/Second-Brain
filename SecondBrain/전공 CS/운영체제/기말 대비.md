###### 모니터를 사용하는 이유
세마포어가 구조화 되지 않은 저수준의 방식이라 경쟁 조건에 취약함
따라서 프로세스 동기화를 위해 편리하고 효과적인 메커니즘을 제공하는 고수준 추상화가 필요하기 때문
###### 모니터가 캡슐화 하는 것
공유 데이터 구조
공유 데이터를 조작하는 프로시저들
해당 프로시저를 호출하는 동시 스레드 간의 동기화
###### 모니터 내 큐
Entry Queue: 모니터에 진입을 기다리는 모든 thread가 대기하는 큐
Condition Variable Queue: wait()을 호출한 스레드가 특정 조건이 만족될 때 까지 대기하는 큐
signal lock queue: signal을 날리고 대기하는 큐
###### 프로세스 P가 x.signal()을 호출하고, 프로세스 Q가 x.wait()으로 중단되어 있는 경우 다음에 어떤 일이 일어나야 하는가?
Signal and wait : P는 sig_lock_queue에서 대기, Q는 실행
Signal and continue : P가 계속 실행, Q는 sig_lock_queue에서 대기
Concurrent Pascal 언어: P는 exit(), Q는 실행
###### signal wait 방식의 모니터 wait 구현
```cpp
x_count++; // 현재 스레드가 x를 기다리므로 대기자 수 증가
if (sig_lock_count > 0) // 이미 누군가 x.signal()을 호출한 상태라면,
	signal(sig_lock); // signal을 기다리던 스레드 하나를 깨움
else
	signal(monitor_lock); // 그렇지 않으면 monitor_lock을 넘겨줌
wait(x_sem); // x.signal()이 호출될 때까지 대기
x_count--; // 일어나서 다 기다렸으니 나갈거라서 x_count를 감소
```
###### signal wait 방식의 모니터 signal 구현
```cpp
if (x_count > 0) { // 조건 변수 x를 기다리는 스레드가 있다면
	sig_lock_count++; // signal을 기다리는 스레드 수 증가
	signal(x_sem); // 기다리던 스레드 하나를 깨움
	wait(sig_lock); // signal한 스레드는 sig_lock에서 잠시 대기 (깨운 스레드가 모니터를 먼저 갖고 실행을 계속하게 하기 위함)
	sig_lock_count--; // signal 대기 스레드 수 감소
}
```
###### signal continue 방식의 모니터 wait 구현
```cpp
add current_thread to x.queue; // x_counter++
signal(monitor_lock);
block current_thread; // wait(x_sem)

acquire monitor_lock // wait(monitor_lock)
```
###### signal continue 방식의 모니터 signal 구현
```cpp
if(!x.queue.empty()){ // x.count > 0
	move one thread from x.queue to ready queue; // signal(x_sem)
}
```
###### Bounded-Buffer Problem에서 mutex, full, empty 세마포어의 초기 값
•	세마포어 mutex는 1로 초기화됨 (mutex -> buffer 접근에 대한 mutual exclusion 보장하는 semaphore)
•	세마포어 full은 0으로 초기화됨  (full -> n개 중에 몇 개가 사용되고 있는지)
•	세마포어 empty는 n으로 초기화됨 (empty -> n개 중에 비어있는 buffer의 수)
###### Bounded-Buffer Problem에서 생산자 프로세스 구조
```cpp
do {
  …
  /* next_produced에 항목을 생성 */
  …
  wait(empty); // 접근 가능한 빈 semaphore가 있는지 check
  wait(mutex); // buffer는 공유객체이므로 잠그고 들어감
  …
  /* next_produced를 버퍼에 추가 */
  …
  signal(mutex);  
  signal(full);  
} while (true);
```
###### Bounded-Buffer Problem에서 소비자 프로세스 구조
```cpp
do {
  wait(full); // buffer에 유효한 data가 채워졌는지 check
  wait(mutex); // buffer는 공유객체이므로 잠그고 들어감
  …
  /* 버퍼에서 항목을 제거하여 next_consumed에 저장 */
  …
  signal(mutex); // 
  signal(empty); // 
  …
  /* next_consumed에 있는 항목을 소비 */
  …
} while (true);
```
###### Readers-Writers Problem이란?
•	하나의 데이터 집합을 여러 동시 실행 프로세스가 공유함
	•	Reader(읽기 전용): 데이터를 읽기만 하고 갱신하지 않음
	•	Writer(쓰기 가능): 데이터를 읽고 쓸 수 있음
•	문제: 여러 Reader가 동시에 읽을 수 있도록 허용하되, Writer는 단독으로 접근해야 함 (Write 중 다른 Reader가 읽어도 안 됨)
###### Readers-Writers Problem에서 rw_mutex, mutex, read_count 초기 값
•	세마포어 rw_mutex = 1 (하나의 writer만 접근하도록 하는 mutex)
•	세마포어 mutex = 1 (read_count 접근 통제용 mutex)
•	정수 read_count = 0
###### Readers-Writers Problem에서 Writer 프로세스 구조
```cpp
do {
  wait(rw_mutex);
  /* 쓰기 작업 수행 */
  signal(rw_mutex);
} while (true);
```
###### Readers-Writers Problem에서 Reader 프로세스 구조
```cpp
do {
  wait(mutex);
  read_count++;
  if (read_count == 1)
    wait(rw_mutex); // 최초로 진입하는 reader만 이 과정 수행
  signal(mutex); // 들어왔으니 read_count에 대한 접근 권한을 해제해줌

  /* 읽기 작업 수행 */

  wait(mutex);
  read_count--;
  if (read_count == 0)
    signal(rw_mutex); // 남은 Reader가 아무도 없으면 Writer가 들어올 수 있도록 signal(rw_mutex)를 날려줌
  signal(mutex);
} while (true);
```
###### Readers-Writers Problem - Writer preference에서 초기값
semaphore rw_mutex = 1;
semaphore mutex = 1;
int read_count = 0;
semaphore queue = 1;  (Writer가 수행 중일 때 새 Reader를 차단)
###### Readers-Writers Problem - Writer preference에서 Writer 프로세스 구조
```cpp
do {
	wait (queue);
	wait (rw_mutex);
	
	/* writing is performed */
	
	signal(rw_mutex);
	signal(queue);
} while (true);
```
###### Readers-Writers Problem - Writer preference Reader 프로세스 구조
```cpp
do{
	wait(queue);
	// 2. signal(queue) 이건 유효함
	wait(mutex);
	
	read_count++;
	if (read_count == 1)
		wait(rw_mutex);
		
	signal(mutex);
	signal(queue);

	/ * reading is performed */
	
	wait(mutex);
		
	read_count--;
	if (read_count == 0)
		signal(rw_mutex);
		
	signal(mutex);
	
} while (true);
```
###### Readers-Writers Problem 문제
기아 문제 발생할 수 있음
###### 식사하는 철학자 문제에서 세마포어 사용이 해법이 될 수 없는 이유
데드락 발생 가능하기 때문
###### 식사하는 철학자 문제에서 데드락을 피하는 방법 3가지
1.	동시에 식탁에 앉을 수 있는 철학자를 최대 4명으로 제한
2.	두 젓가락이 모두 있을 때만 집을 수 있게 함 (임계 구역 사용)
3.	비대칭 해법 사용:
	•	홀수 번호 철학자는 왼쪽 먼저, 그다음 오른쪽
	•	짝수 번호 철학자는 오른쪽 먼저, 그다음 왼쪽
###### 식사하는 철학자 문제에서의 모니터 솔루션
```cpp
monitor DiningPhilosophers {
	enum {THINKING, HUNGRY, EATING} state[5];
	condition self[5];
	
	initialization_code() {
		for (int i=0; i<5; i++)
			state[i] = THINKING;
	}

	void test(int i) {
		if ((state[(i+4)%5] != EATING && // 왼쪽 이웃이 식사 중이 아니고
		(state[i] == HUNGRY) && // 내가 배고플 때
		(state[(i+1)%5] != EATING)) { // 오른쪽 이웃이 식사 중이 아니고
			state[i] = EATING; // 위 조건을 충족해야 먹을 수 있음
			self[i].signal(); // 철학자 i에게 식사해도 된다고 알림
		}
	}

	void pickup(int i) {
		state[i] = HUNGRY;
		test(i);
		if (state[i] != EATING) self[i].wait; // state[i] == HUNGRY 라면 (철학자 i가 식사할 수 없으면 대기)
	}
	
	void putdown(int i) {
		state[i] = THINKING;
		test((i+4)%5);
		test((i+1)%5);
	}
}
```

```cpp
DiningPhilosophers.pickup(i);
/* 식사 */
DiningPhilosophers.putdown(i);
```
###### 생각하는 철학자 문제의 문제
데드락 없음, 그러나 기아 발생 가능 (오른쪽 왼쪽 사람만 계속 먹을 수도 있기 때문)
###### Deadlock 정의
•	하나의 프로세스 집합 내에서 각 프로세스가 다른 프로세스가 가진 어떤 것을 기다리고 있는 상황
•	모두가 기다리고 있으므로, 아무도 기다리는 자원을 제공할 수 없음
###### Deadlock 4가지 조건
•	상호 배제 (Mutual exclusion)
	•	한 번에 하나의 프로세스만 자원을 사용할 수 있음
•	비선점 (No preemption)
	•	한 번 할당된 자원은 강제로 빼앗을 수 없음
•	보유와 대기 (Hold and wait)
	•	하나 이상의 자원을 보유한 프로세스가 다른 자원을 요청하며 대기 중
•	순환 대기 (Circular wait)
	•	자원을 가진 프로세스들이 서로가 가진 자원을 기다리는 원형의 대기 관계 존재
###### Allocation Graph에서 순환고리가 만들어졌다면
무조건 데드락이 걸리는 것은 아님
###### Deadlock 두 가지 해결책
•	교착 상태 예방/회피
	•	시스템을 구성할 때 교착 상태가 절대 발생하지 않도록 설계
	•	자원 효율성이 낮아질 수 있음
•	교착 상태 탐지 및 복구
	•	시스템이 교착 상태인지 판단하고, 심각한 조치를 취함
	•	하나 이상의 프로세스를 종료하여 자원을 회수해야 할 수 있음
###### 교착 상태 예방법
•	네 가지 조건 중 하나를 피하는 방식:
	•	*No mutual exclusion*
		•	공유 자원에 대한 배타적 접근을 허용하지 않음
		•	많은 애플리케이션에서 비현실적
	•	*Preemption*
		•	자원을 보유한 프로세스가 새로운 자원을 요청했을 때 즉시 할당할 수 없다면, 기존 자원 모두를 반납시킴
		•	반납된 자원은 대기 목록에 추가됨
		•	해당 프로세스는 모든 자원을 다시 얻을 수 있을 때까지 재시작되지 않음
	•	*No hold and wait*
		•	프로세스가 자원을 요청할 때, 다른 자원을 보유하고 있지 않아야 함을 보장해야 함
			•	예) 프로세스가 필요한 모든 자원을 한 번에 요청하게 만듦
		•	필요한 자원을 전부 다 얻거나, 아니면 전부 다 얻을 때까지 대기
		•	프로세스 입장에서는 불편함
			•	필요한 자원을 미리 예측하기 어려워, 자원을 매우 비효율적으로 사용할 수 있음
			•	낮은 자원 활용률 또는 기아 상태가 발생할 수 있음
	•	*No circular wait*
		•	자원 요청에 순서를 부여함
			•	예: 먼저 S 자원들, 그 다음 T 자원들을 요청
		•	모든 프로세스가 같은 순서를 따르도록 강제함
###### safe state & unsf
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
