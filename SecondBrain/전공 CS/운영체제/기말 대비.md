###### 모니터를 사용하는 이유
세마포어가 구조화 되지 않은 저수준의 방식이라 경쟁 조건에 취약함
따라서 프로세스 동기화를 위해 편리하고 효과적인 메커니즘을 제공하는 고수준 추상화가 필요하기 때문
###### 모니터가 캡슐화 하는 것
공유 데이터 구조
공유 데이터를 조작하는 프로시저들
해당 프로시저를 호출하는 동시 스레드 간의 동기화
###### 모니터 내 큐
Entry Queue: 모니터에 진입을 기다리는 모든 thread가 대기하는 큐
Condition Variable Queue: wait()을 호출한 스레드가 특정 조건이 만족될 때 까지 대기하는 큐
signal lock queue: signal을 날리고 대기하는 큐
###### 프로세스 P가 x.signal()을 호출하고, 프로세스 Q가 x.wait()으로 중단되어 있는 경우 다음에 어떤 일이 일어나야 하는가?
Signal and wait : P는 sig_lock_queue에서 대기, Q는 실행
Signal and continue : P가 계속 실행, Q는 sig_lock_queue에서 대기
Concurrent Pascal 언어: P는 exit(), Q는 실행
###### signal wait 방식의 모니터 wait 구현
```cpp
x_count++; // 현재 스레드가 x를 기다리므로 대기자 수 증가
if (sig_lock_count > 0) // 이미 누군가 x.signal()을 호출한 상태라면,
	signal(sig_lock); // signal을 기다리던 스레드 하나를 깨움
else
	signal(monitor_lock); // 그렇지 않으면 monitor_lock을 넘겨줌
wait(x_sem); // x.signal()이 호출될 때까지 대기
x_count--; // 일어나서 다 기다렸으니 나갈거라서 x_count를 감소
```
###### signal wait 방식의 모니터 signal 구현
```cpp
if (x_count > 0) { // 조건 변수 x를 기다리는 스레드가 있다면
	sig_lock_count++; // signal을 기다리는 스레드 수 증가
	signal(x_sem); // 기다리던 스레드 하나를 깨움
	wait(sig_lock); // signal한 스레드는 sig_lock에서 잠시 대기 (깨운 스레드가 모니터를 먼저 갖고 실행을 계속하게 하기 위함)
	sig_lock_count--; // signal 대기 스레드 수 감소
}
```
###### signal continue 방식의 모니터 wait 구현
```cpp
add current_thread to x.queue; // x_counter++
signal(monitor_lock);
block current_thread; // wait(x_sem)

acquire monitor_lock // wait(monitor_lock)
```
###### signal continue 방식의 모니터 signal 구현
```cpp
if(!x.queue.empty()){ // x.count > 0
	move one thread from x.queue to ready queue; // signal(x_sem)
}
```
###### Bounded-Buffer Problem에서 mutex, full, empty 세마포어의 초기 값
•	세마포어 mutex는 1로 초기화됨 (mutex -> buffer 접근에 대한 mutual exclusion 보장하는 semaphore)
•	세마포어 full은 0으로 초기화됨  (full -> n개 중에 몇 개가 사용되고 있는지)
•	세마포어 empty는 n으로 초기화됨 (empty -> n개 중에 비어있는 buffer의 수)
###### Bounded-Buffer Problem에서 생산자 프로세스 구조
```cpp
do {
  …
  /* next_produced에 항목을 생성 */
  …
  wait(empty); // 접근 가능한 빈 semaphore가 있는지 check
  wait(mutex); // buffer는 공유객체이므로 잠그고 들어감
  …
  /* next_produced를 버퍼에 추가 */
  …
  signal(mutex);  
  signal(full);  
} while (true);
```
###### Bounded-Buffer Problem에서 소비자 프로세스 구조
```cpp
do {
  wait(full); // buffer에 유효한 data가 채워졌는지 check
  wait(mutex); // buffer는 공유객체이므로 잠그고 들어감
  …
  /* 버퍼에서 항목을 제거하여 next_consumed에 저장 */
  …
  signal(mutex); // 
  signal(empty); // 
  …
  /* next_consumed에 있는 항목을 소비 */
  …
} while (true);
```
###### Readers-Writers Problem이란?
•	하나의 데이터 집합을 여러 동시 실행 프로세스가 공유함
	•	Reader(읽기 전용): 데이터를 읽기만 하고 갱신하지 않음
	•	Writer(쓰기 가능): 데이터를 읽고 쓸 수 있음
•	문제: 여러 Reader가 동시에 읽을 수 있도록 허용하되, Writer는 단독으로 접근해야 함 (Write 중 다른 Reader가 읽어도 안 됨)
###### Readers-Writers Problem에서 rw_mutex, mutex, read_count 초기 값
•	세마포어 rw_mutex = 1 (하나의 writer만 접근하도록 하는 mutex)
•	세마포어 mutex = 1 (read_count 접근 통제용 mutex)
•	정수 read_count = 0
###### Readers-Writers Problem에서 Writer 프로세스 구조
```cpp
do {
  wait(rw_mutex);
  /* 쓰기 작업 수행 */
  signal(rw_mutex);
} while (true);
```
###### Readers-Writers Problem에서 Reader 프로세스 구조
```cpp
do {
  wait(mutex);
  read_count++;
  if (read_count == 1)
    wait(rw_mutex); // 최초로 진입하는 reader만 이 과정 수행
  signal(mutex); // 들어왔으니 read_count에 대한 접근 권한을 해제해줌

  /* 읽기 작업 수행 */

  wait(mutex);
  read_count--;
  if (read_count == 0)
    signal(rw_mutex); // 남은 Reader가 아무도 없으면 Writer가 들어올 수 있도록 signal(rw_mutex)를 날려줌
  signal(mutex);
} while (true);
```
###### Readers-Writers Problem - Writer preference에서 초기값
semaphore rw_mutex = 1;
semaphore mutex = 1;
int read_count = 0;
semaphore queue = 1;  (Writer가 수행 중일 때 새 Reader를 차단)
###### Readers-Writers Problem - Writer preference에서 Writer 프로세스 구조
```cpp
do {
	wait (queue);
	wait (rw_mutex);
	
	/* writing is performed */
	
	signal(rw_mutex);
	signal(queue);
} while (true);
```
###### Readers-Writers Problem - Writer preference Reader 프로세스 구조
```cpp
do{
	wait(queue);
	// 2. signal(queue) 이건 유효함
	wait(mutex);
	
	read_count++;
	if (read_count == 1)
		wait(rw_mutex);
		
	signal(mutex);
	signal(queue);

	/ * reading is performed */
	
	wait(mutex);
		
	read_count--;
	if (read_count == 0)
		signal(rw_mutex);
		
	signal(mutex);
	
} while (true);
```
###### 식사하는 철학자 문제에서 세마포어 사용이 해법이 될 수 없는 이유
데드락 발생 가능하기 때문
###### 식사하는 철학자 문제에서 데드락을 피하는 방법 3가지
1.	동시에 식탁에 앉을 수 있는 철학자를 최대 4명으로 제한
2.	두 젓가락이 모두 있을 때만 집을 수 있게 함 (임계 구역 사용)
3.	비대칭 해법 사용:
	•	홀수 번호 철학자는 왼쪽 먼저, 그다음 오른쪽
	•	짝수 번호 철학자는 오른쪽 먼저, 그다음 왼쪽
###### 식사하는 철학자 문제에서의 모니터 솔루션

###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
