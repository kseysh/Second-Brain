1.1 운영체제의 세 가지 주요 목적은 무엇인가?
1.	컴퓨터 시스템의 자원 관리 (CPU, 메모리, I/O 장치 등)
2.	사용자와 하드웨어 사이의 인터페이스 제공
3.	프로그램 실행 환경 제공 (프로세스 및 스케줄링 관리 등)

1.5 커널 모드와 사용자 모드의 구분이 어떻게 기본적인 보호 메커니즘(보안 기능)으로 작용하는가?
•	사용자 모드에서는 중요한 하드웨어 자원 접근이 제한되어 시스템 오작동이나 악성코드로부터 보호 가능
•	커널 모드에서만 중요한 명령 실행이 가능하므로 안정성과 보안 유지

2.1 시스템 콜의 목적은 무엇인가?
운영체제의 기능을 사용자 프로그램이 사용할 수 있도록 인터페이스를 제공한다. 예를 들어 파일 열기, 메모리 할당, 프로세스 생성 등은 모두 시스템 콜을 통해 이루어진다.

2.5 계층적 시스템 설계 방식의 주요 장점과 단점은 무엇인가?
•	장점: 모듈화가 잘 되어 유지보수와 디버깅이 쉬움. 각 계층이 독립적으로 설계되어 안정성 향상.
•	단점: 각 계층 간 호출로 인한 오버헤드 발생. 하위 계층에 기능이 없으면 상위 계층이 제약을 받을 수 있음.

5.6 멀티레벨 큐 스케줄링 시스템에서 서로 다른 레벨에 서로 다른 타임 퀀텀을 두는 장점은 무엇인가?

답변:
	•	짧은 작업은 빠르게 끝나므로 짧은 퀀텀으로 처리하면 지연 시간 감소
	•	긴 작업은 더 큰 타임퀀텀을 부여하여 문맥 전환 비용을 줄일 수 있음
	•	전반적인 응답성과 처리량 간 균형을 맞출 수 있음

6.2 busy waiting(바쁜 대기)의 의미는 무엇인가? 운영체제에서 존재하는 다른 종류의 대기는 어떤 것이 있는가? 바쁜 대기를 완전히 피할 수 있는가?

답변:
	•	바쁜 대기: 조건이 충족될 때까지 CPU를 쉬지 않고 루프를 돌며 계속 검사하는 방식
→ CPU 자원을 낭비함
	•	다른 대기 방식:
	•	블로킹 대기: 조건이 충족될 때까지 프로세스를 비활성 상태로 만들고, 다시 활성화될 때까지 CPU를 사용하지 않음
	•	회피 가능 여부:
	•	바쁜 대기는 완전히 제거할 수 있지만, 멀티코어 환경에서는 짧은 시간 동안의 바쁜 대기가 오히려 효율적일 수 있음
	•	따라서 적절한 환경에서만 최소화하는 것이 중요

6.3 스핀락(spinlock)은 단일 프로세서 시스템에는 부적절하고, 멀티프로세서 시스템에서는 자주 사용된다고 했다. 그 이유를 설명하라.
•	단일 프로세서 시스템에서는 한 스레드가 락을 잡고 CPU를 사용 중이면, 다른 스레드는 락을 얻기 위해 계속 바쁜 대기를 하며 CPU를 낭비하게 됨 → 낭비만 초래하고 효과 없음
•	멀티프로세서 시스템에서는 한 프로세스가 락을 잡고 다른 프로세스가 바쁜 대기를 하더라도 각자 다른 CPU를 사용하기 때문에 효과적으로 사용 가능

6.4 wait()와 signal() 세마포어 연산이 원자적으로 실행되지 않으면 상호배제가 깨질 수 있음을 증명하라.
답변:
	•	예를 들어 두 프로세스 P1과 P2가 동시에 wait()를 호출할 경우, 두 프로세스가 동시에 세마포어 값을 검사하고(>0), 각자 값을 감소시킨다면 둘 다 critical section에 진입할 수 있게 된다
	•	이는 상호배제 원칙을 위반한 것이므로, wait()와 signal() 연산은 반드시 원자적으로 실행되어야 함
