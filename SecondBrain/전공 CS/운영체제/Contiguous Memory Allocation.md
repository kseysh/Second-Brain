## Contiguous Allocation
• 메인 메모리는 운영체제와 사용자 프로세스 모두를 지원해야 함
• 제한된 자원이므로 효율적으로 할당해야 함
• Contiguous allocation은 초기의 메모리 관리 방법 중 하나임
• 메인 메모리는 보통 두 개의 파티션으로 나뉨:
	• 상주 운영체제는 일반적으로 인터럽트 벡터와 함께 저주소 영역에 위치
	• 사용자 프로세스는 고주소 영역에 위치
	• 각 프로세스는 메모리의 하나의 연속된 구간에 포함됨

•	사용자 프로세스를 서로 또는 OS 코드와 데이터로부터 보호하기 위해 relocation register 사용
	• base register는 가장 작은 물리 주소 값을 가짐
	• 리미트 레지스터는 logical address의 범위를 가짐
	• MMU는 논리 주소를 실행 중에 동적으로 매핑함
![[Pasted image 20250520170458.png|300]]
더해주는 것이 MMU라고 할 수 있음
### Multiple-partition allocation
• multiprogramming의 정도는 파티션 수에 의해 제한됨
• 효율성을 위해 가변 크기 파티션 사용
• Hole(빈 공간) - 사용 가능한 메모리 블록
• 프로세스가 도착하면, 충분히 큰 hole에서 메모리가 할당됨
• 프로세스가 종료되면 해당 파티션을 해제하고 인접한 빈 파티션은 합쳐짐
• 운영체제는 다음 정보를 유지함:
	• (a) 할당된 파티션
	• (b) 사용 가능한 파티션(hole)
![[Pasted image 20250520170718.png|400]]
### 동적 저장소 할당 문제
• 크기 n의 요청을 free hole 목록에서 어떻게 만족시킬 것인가?
	• First-fit: 충분히 큰 첫 번째 hole에 할당
	• Best-fit: 충분히 큰 hole 중 가장 작은 것에 할당
	• Worst-fit: 가장 큰 hole에 할당
그냥 여러가지 방법이 있다 . . .
## Contiguous Allocation 단점
### 단편화(Fragmentation)
• 외부 단편화(External fragmentation)
	• 요청을 만족시킬 수 있는 전체 메모리 공간은 있으나 연속되지 않아서 사용할 수 없음
• 내부 단편화(Internal fragmentation)
	• 할당된 메모리가 요청보다 조금 더 클 수 있으며, 이 크기 차이는 파티션 내부에서 사용되지 않아서 사용할 수 없음
### 50% 규칙
• First-fit 분석 결과, N개의 블록이 할당되면 0.5N개의 블록이 단편화로 손실됨
	• 1/3 정도가 사용 불가능할 수 있음
그냥 이런 실험이 있었다...

## 극복 방법 - Compaction
•	압축(Compaction)은 외부 단편화를 줄임
	• 메모리 내용을 재배열하여 모든 빈 메모리를 하나의 큰 블록으로 만듦
	• 압축은 주소 재배치가 동적이며 실행 시간 중에 가능한 경우에만 수행 가능
	• I/O 문제
		• I/O 작업 중인 잡은 메모리에 유지해야 함
		• ~~I/O는 운영체제 버퍼로만 수행해야 함~~