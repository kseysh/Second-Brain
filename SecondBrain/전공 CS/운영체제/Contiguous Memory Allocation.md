	•	Contiguous Allocation (1)
• 메인 메모리는 운영체제와 사용자 프로세스 모두를 지원해야 함
• 제한된 자원이므로 효율적으로 할당해야 함
• 연속 할당은 초기의 메모리 관리 방법 중 하나임
• 메인 메모리는 보통 두 개의 파티션으로 나뉨:
• 상주 운영체제는 일반적으로 인터럽트 벡터와 함께 저주소 영역에 위치
• 사용자 프로세스는 고주소 영역에 위치
• 각 프로세스는 메모리의 하나의 연속된 구간에 포함됨
	•	사용자 프로세스를 서로 또는 OS 코드와 데이터로부터 보호하기 위해 리로케이션 레지스터 사용
• 베이스 레지스터는 가장 작은 물리 주소 값을 가짐
• 리미트 레지스터는 논리 주소의 범위를 가짐
• MMU는 논리 주소를 실행 중에 동적으로 매핑함
	•	다중 파티션 할당
• 멀티프로그래밍의 정도는 파티션 수에 의해 제한됨
• 효율성을 위해 가변 크기 파티션 사용
• Hole(빈 공간) - 사용 가능한 메모리 블록
• 프로세스가 도착하면, 충분히 큰 hole에서 메모리가 할당됨
• 프로세스가 종료되면 해당 파티션을 해제하고 인접한 빈 파티션은 합쳐짐
• 운영체제는 다음 정보를 유지함:
• (a) 할당된 파티션
• (b) 사용 가능한 파티션(hole)
	•	동적 저장소 할당 문제
• 크기 n의 요청을 자유 hole 목록에서 어떻게 만족시킬 것인가?
• First-fit: 충분히 큰 첫 번째 hole에 할당
• Best-fit: 충분히 큰 hole 중 가장 작은 것에 할당
• Worst-fit: 가장 큰 hole에 할당
	•	단편화(Fragmentation)
• 외부 단편화(External fragmentation)
• 요청을 만족시킬 수 있는 전체 메모리 공간은 있으나 연속되지 않음
• 내부 단편화(Internal fragmentation)
• 할당된 메모리가 요청보다 조금 더 클 수 있으며, 이 크기 차이는 파티션 내부에서 사용되지 않음
• 50% 규칙
• First-fit 분석 결과, N개의 블록이 할당되면 0.5N개의 블록이 단편화로 손실됨
• 1/3 정도가 사용 불가능할 수 있음
	•	압축(Compaction)은 외부 단편화를 줄임
• 메모리 내용을 재배열하여 모든 빈 메모리를 하나의 큰 블록으로 만듦
• 압축은 주소 재배치가 동적이며 실행 시간 중에 가능한 경우에만 수행 가능
• I/O 문제
• I/O 작업 중인 잡은 메모리에 유지해야 함
• I/O는 운영체제 버퍼로만 수행해야 함