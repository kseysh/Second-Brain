###### 모니터를 사용하는 이유
=> 세마포어가 *경쟁 조건에 취약한 저수준*의 방식이라 프로세스 동기화를 위해 고수준 추상화가 된 모니터를 사용함
###### 식사하는 철학자 문제에서 데드락을 피하는 방법 3가지
1.	동시에 식탁에 앉을 수 있는 철학자를 최대 4명으로 제한
2.	두 젓가락이 모두 있을 때만 집을 수 있게 함 (임계 구역 사용)
3.	비대칭 해법 사용:
	•	홀수 번호 철학자는 왼쪽 먼저, 그다음 오른쪽
	•	짝수 번호 철학자는 오른쪽 먼저, 그다음 왼쪽
###### 교착 상태 예방법
•	네 가지 조건 중 하나를 피하는 방식:
	•	*No mutual exclusion*
		•	공유 자원에 대한 배타적 접근을 허용하지 않음
		•	많은 애플리케이션에서 비현실적
	•	*Preemption*
		•	자원을 보유한 프로세스가 새로운 자원을 요청했을 때 즉시 할당할 수 없다면, 기존 자원 모두를 반납시킴
		•	요청 실패 시 기존 자원 반납
		•	해당 프로세스는 모든 자원을 다시 얻을 수 있을 때까지 재시작되지 않음
	•	*No hold and wait*
		•	프로세스가 자원을 요청할 때, 다른 자원을 보유하고 있지 않아야 함을 보장해야 함
			•	예) 프로세스가 필요한 모든 자원을 한 번에 요청하게 만듦
		•	필요한 자원을 전부 다 얻거나, 아니면 전부 다 얻을 때까지 대기
		•	처음부터 모든 자원을 한 번에 요청
	•	*No circular wait*
		•	자원 요청에 순서를 부여함
			•	예: 먼저 S 자원들, 그 다음 T 자원들을 요청
		•	모든 프로세스가 같은 순서를 따르도록 강제함
###### no hold and wait 단점
•	필요한 자원을 미리 예측하기 어려워, 자원을 매우 비효율적으로 사용할 수 있음
•	낮은 자원 활용률 또는 기아 상태가 발생할 수 있음
###### 교착 상태 처리 매커니즘의 한계
교착 상태 예방 및 방지가 비용이 많이 든다. 교착 상태를 탐지하더라도 복구가 어렵다.
###### 교착 상태 복구 방법
•	모든 교착 상태의 프로세스를 종료
•	교착 상태의 사이클이 제거될 때까지 하나씩 종료
- Resource Preemption
###### Multiple partition allocation의 OS에서 저장하는 정보
• (a) 할당된 파티션
• (b) 사용 가능한 파티션(hole)
###### ASID가 필요한 이유
• 일부 TLB는 address-space identifiers(ASID)를 각 항목에 저장 (어떤 process 정보인지)

ASID가 없다면, 다른 프로세스가 실행될 때, 기존 TLB 항목이 잘못된 것이 될 수 있어 컨텍스트 스위치마다 TLB를 비워야 하기 때문에 프로세스를 고유하게 식별하여 주소공간을 보호할 수 있도록 한다.

여러 프로세스가 서로 다른 페이지 테이블을 사용하므로,
같은 가상 주소라도 서로 다른 의미를 가질 수 있음
	•	ASID는 어떤 프로세스의 항목인지 구별 → TLB context switch 시 invalidate 필요 없음
###### page fault시 발생하는 일
•	페이지 참조가 발생하면, 해당 페이지에 대한 첫 참조 시 운영체제로 trap 발생 (page fault)
1.	운영체제가 다른 테이블을 확인함
	•	잘못된 참조 → 중단
	•	단지 메모리에 없을 경우 다음 step
2.	빈 프레임 찾기
3.	disk operation을 통해 해당 페이지를 프레임에 swap in
4.	페이지가 메모리에 있다고 테이블 갱신, valid-invalid bit를 v로 세팅
5.	페이지 폴트를 유발한 명령어를 재시작
![[Pasted image 20250529171418.png|400]]
###### pure demand paging
•	*pure demand paging*: 처음에는 아무 페이지도 메모리에 없이 프로세스 시작
	•	OS는 프로세스의 첫 명령어 위치로  instruction pointer를 설정 → 메모리에 없음 → 페이지 폴트
	•	다른 모든 페이지들도 처음 접근 시 페이지 폴트
###### Demand Paging을 위한 하드웨어 지원
1.	Backing store
2.	MMU (메모리 관리 장치): 주소 변환 수행
3.	TLB (Translation Lookaside Buffer): 주소 변환 캐시
4.	페이지 폴트 처리 인터럽트 지원
###### Prepaging
• 참조되기 전에 페이지를 미리 메모리에 불러옴
• 한 페이지가 참조되면, 혹시 몰라 다음 페이지도 불러옴
• 예측 능력자 없이 효과적으로 하기 어려움
• 가끔 효과적임: 순차적 읽기 예측(read-ahead)
###### Request paging과 문제점
• 사용자가 필요한 페이지를 직접 지정
• 이 방식의 문제점은?
	• 사용자가 항상 최선의 선택을 하는 것은 아님
	• 사용자가 객관적이지 않음 (필요 이상으로 과대 평가)
###### Copy on Write
부모와 자식 프로세스가 처음에는 동일한 페이지를 메모리에서 공유하도록 허용함
	• 둘 중 어느 쪽이 공유된 페이지를 수정하면, 그때 비로소 해당 페이지를 복사함
• 일반적으로, 빈 페이지는 ‘요청 시 0으로 채워지는(zero-fill-on-demand)’ 페이지 풀에서 할당됨
	• 빠른 Demand paging 처리를 위해 이 풀에는 항상 여유 프레임이 있어야 함
		• 페이지 폴트 발생 시 프레임을 해제하고 다른 처리를 동시에 하지 않도록 하기 위함
###### COW 장점
• COW는 수정된 페이지만 복사하므로 프로세스를 보다 효율적으로 생성할 수 있음
###### LRU에서 Belady의 역설이 발생하지 않는 이유
 LRU는 stack 알고리즘이므로 frame 개수가 n개일 때, 메모리에 존재하는 page set은 n+1 frame의 부분집합이다
따라서 LRU와 OPT는 Belady의 역설이 없는 스택 알고리즘 사례이다.
###### Enhanced Clock Algorithm
•	참조 비트(reference bit)와 수정 비트(modify bit 또는 dirty bit)를 함께 사용하여 알고리즘 개선
•	(참조, 수정) 쌍을 기준으로 4가지 상태로 구분
1.	(0, 0): 최근에 사용되지 않았고 수정되지 않음 → 교체 대상 최우선
2.	(0, 1): 최근에 사용되지 않았지만 수정됨 → 좋지는 않음, 교체 전에 디스크에 기록해야 함
3.	(1, 0): 최근에 사용되었고 깨끗함 → 곧 다시 사용될 가능성 높음
4.	(1, 1): 최근에 사용되었고 수정됨 → 곧 다시 사용될 가능성 높고, 디스크에 기록 필요
•	페이지 교체가 필요할 때는 클럭 스킴을 사용하되, 네 가지 상태 중 가장 낮은 우선순위 그룹에서 교체
	•	이때 원형 큐를 여러 번 순회해야 할 수도 있음
###### Global Allocation과 장단점
•	**프로세스는 시스템 전체의 프레임 중에서 교체 프레임을 선택할 수 있음**
•	한 프로세스가 다른 프로세스의 프레임을 가져갈 수 있음
장점: 처리량이 높아짐
단점: 프로세스 실행 시간에 큰 변동이 생길 수 있음 (같이 사용되는 프로세스에 따라 달라지므로)

다른 프로세스가 쓰던 데이터를 빼내도 된다.
###### 스래싱의 뜻과 스래싱이 발생하는 이유
프로세스가 페이지를 들여오고 내보내는 작업에만 몰두하게 되는 현상

•	지역성들의 전체 크기(∑ 지역성 크기)가 전체 메모리보다 클 때 발생
	•	지역 교체나 우선순위 교체를 통해 영향 완화 가능
•	Δ 작을 때:
	•	워킹셋 크기 ↓
	•	페이지 폴트 ↑
	•	많은 프로세스 실행 가능
	•	Δ 클 때:
	•	워킹셋 크기 ↑
	•	페이지 폴트 ↓
	•	동시에 실행 가능한 프로세스 수 ↓