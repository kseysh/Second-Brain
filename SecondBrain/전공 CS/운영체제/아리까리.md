###### signal wait 방식의 모니터 wait 구현
```cpp
x_count++; // 현재 스레드가 x를 기다리므로 대기자 수 증가
if (sig_lock_count > 0) // 이미 누군가 x.signal()을 호출한 상태라면,
	signal(sig_lock); // signal을 기다리던 스레드 하나를 깨움
else
	signal(monitor_lock); // 그렇지 않으면 monitor_lock을 넘겨줌
wait(x_sem); // x.signal()이 호출될 때까지 대기
x_count--; // 일어나서 다 기다렸으니 나갈거라서 x_count를 감소
```
x_count++, 다음 프로세스 호출, wait(x_sem), x_count--
###### signal wait 방식의 모니터 signal 구현
```cpp
if (x_count > 0) { // 조건 변수 x를 기다리는 스레드가 있다면
	sig_lock_count++; // signal을 기다리는 스레드 수 증가
	signal(x_sem); // 기다리던 스레드 하나를 깨움
	wait(sig_lock); // signal한 스레드는 sig_lock에서 잠시 대기 (깨운 스레드가 모니터를 먼저 갖고 실행을 계속하게 하기 위함)
	sig_lock_count--; // signal 대기 스레드 수 감소
}
```
sig_lock_count++, signal(s_xem), wait(sig_lock_count), sig_lock_count--
###### Bounded-Buffer Problem에서 mutex, full, empty 세마포어의 초기 값과 역할
•	세마포어 mutex는 1로 초기화됨 (buffer 접근에 대한 mutual exclusion 보장하는 semaphore)
•	세마포어 full은 0으로 초기화됨  (n개 중에 몇 개가 사용되고 있는지)
•	세마포어 empty는 n으로 초기화됨 (n개 중에 비어있는 buffer의 수)
###### Bounded-Buffer Problem에서 생산자 프로세스 구조 (do while 안에서 wait, signal 순서)
```cpp
do {
  …
  /* next_produced에 항목을 생성 */
  …
  wait(empty); // 접근 가능한 빈 semaphore가 있는지 check
  wait(mutex); // buffer는 공유객체이므로 잠그고 들어감
  …
  /* next_produced를 버퍼에 추가 */
  …
  signal(mutex);  
  signal(full);  
} while (true);
```
###### Contiguous Memory Allocation에서 user process를 관리하기 위한 base, limit 레지스터 관리
•	사용자 프로세스를 서로 또는 OS 코드와 데이터로부터 보호하기 위해 relocation register 사용
	• base register는 가장 작은 물리 주소 값을 가짐
	• 리미트 레지스터는 logical address의 범위를 가짐
	• MMU는 논리 주소를 실행 중에 동적으로 매핑함
![[Pasted image 20250520170458.png|300]]
###### Contiguous Allocation 단점
- **단편화(Fragmentation)**
• 외부 단편화(External fragmentation)
	• *요청을 만족시킬 수 있는 전체 메모리 공간은 있으나 연속되지 않아서 사용할 수 없음*
• 내부 단편화(Internal fragmentation)
	• 할당된 메모리가 요청보다 조금 더 클 수 있으며, 이 크기 차이는 파티션 내부에서 사용되지 않아서 사용할 수 없음
- **50% 규칙**
• First-fit 분석 결과, N개의 블록이 할당되면 절반의 블록이 단편화로 손실됨
	• 1/3 정도가 사용 불가능할 수 있음
###### segmentation이란?
프로세스의 주소 공간을 논리적인 단위인 segment로 나누는 메모리 관리 기법
• 각 세그먼트에 대해 개별적인 base, limit register 쌍을 사용하며, two protection bits(읽기 및 쓰기)도 추가
###### segment table에서 저장하는 값
• 세그먼트 테이블은 이차원 물리 주소를 매핑함
	• base - 세그먼트가 메모리 내에 위치하는 시작 물리 주소
	• limit - 세그먼트의 길이
###### STBR, STLR
• 세그먼트 테이블 베이스 레지스터(STBR): 세그먼트 테이블의 물리 메모리 내 위치(시작 주소)를 가리킴
• 세그먼트 테이블 길이 레지스터(STLR): 세그먼트 테이블에 포함된 세그먼트 개수 (즉, segment number의 유효 범위)
	• segment number는 STLR보다 작을 때 유효함
###### segmentation 방식에서 physical address를 얻는 방법
1. STBR에서 segment table의 physical memory 내 위치를 찾는다
2. segment number (s)가 STLR보다 작은지 검사
	- 그렇지 않으면 trap 발생
3. segment number를 이용해 segment table에서 base와 limit 값을 가져옴
4. offset (d)이 limit보다 작은지 검사
	- 그렇지 않으면 trap 발생
5. base + offset을 계산해 physical address 구함
###### Paging에서 작은 page size가 항상 좋은가?
작은 페이지 크기를 사용하면 같은 크기의 주소 공간을 더 많은 페이지로 나눠야 함.
•	이로 인해 페이지 테이블 엔트리 수가 증가하고, 전체 페이지 테이블의 크기도 커짐.
•	페이지 테이블이 너무 커지면 메모리 공간을 많이 차지하고, TLB 미스 시 페이지 테이블 접근 시간이 증가
###### ASID가 필요한 이유
• 일부 TLB는 address-space identifiers(ASID)를 각 항목에 저장 (어떤 process 정보인지)

ASID가 없다면, 다른 프로세스가 실행될 때, 가상 주소 공간도 바뀌므로 기존 TLB 항목이 잘못된 것이 될 수 있어 컨텍스트 스위치마다 TLB를 비워야 하기 때문에 프로세스를 고유하게 식별하여 주소공간을 보호할 수 있도록 한다.
###### 계층적 페이지 테이블이 필요한 이유
단일 프로세스가 너무 많은 페이지 테이블을 관리해야 하므로 이를 계층적으로 분해하여 공간을 절약하기 위함


