9.1

문제 (번역):
논리 주소(logical address)와 물리 주소(physical address)의 차이점 두 가지를 말하시오.

풀이:
	1.	정의 차이:
	•	논리 주소는 CPU가 생성한 주소로, 가상 주소라고도 불리며 프로세스가 사용하는 주소입니다.
	•	물리 주소는 실제 메모리(RAM)에서의 위치를 나타내는 주소입니다.
	2.	주소 변환 여부:
	•	논리 주소는 주소 변환 과정을 통해 물리 주소로 매핑됩니다.
	•	주소 변환은 MMU(Memory Management Unit)가 수행합니다.

⸻

9.2

문제 (번역):
왜 페이지 크기는 항상 2의 거듭제곱인가?

풀이:
	•	주소 변환 시, 주소를 페이지 번호 + 페이지 오프셋으로 나누기 쉽기 때문입니다.
	•	2의 거듭제곱이면 비트 단위로 쉽게 나뉘므로, 연산 속도와 하드웨어 구현이 단순해집니다.

⸻

9.3

문제 (번역):
한 프로그램이 코드와 데이터 두 부분으로 나눌 수 있고, CPU가 명령어(fetch)와 데이터(fetch/store)를 구분할 수 있다고 가정하자.
이때, 명령어용(base-limit)과 데이터용(base-limit) 레지스터 쌍이 따로 제공된다. 명령어용 레지스터는 자동으로 읽기 전용이다.
이러한 구조의 장점과 단점을 논하라.

풀이:
	•	장점:
	1.	코드 공유가 가능함 → 여러 사용자 프로그램이 같은 코드 영역을 사용할 수 있어 메모리 절약.
	2.	명령어는 읽기 전용 → 버그나 악성 코드로부터 보호됨.
	•	단점:
	1.	프로그램 구조가 rigid → 코드와 데이터를 분리해야 해서 개발 복잡도 증가.
	2.	유연성 부족 → 일부 프로그램은 코드에서 데이터를 수정하거나 셀프-수정 코드를 사용할 수도 있음.

⸻

9.4

문제 (번역):
1,024단어(word) 크기의 64페이지로 이루어진 논리 주소 공간이 있고, 이가 32개의 프레임으로 구성된 물리 메모리에 매핑된다.
a. 논리 주소는 몇 비트인가?
b. 물리 주소는 몇 비트인가?

풀이:
	•	a. 논리 주소는 페이지 번호 + 오프셋
	•	페이지 수: 64 → 6비트
	•	각 페이지: 1,024 word → 10비트
	•	총 6 + 10 = 16비트
	•	b. 물리 프레임 수: 32 → 5비트
	•	각 프레임 크기: 1,024 word → 10비트
	•	총 5 + 10 = 15비트

⸻

9.5

문제 (번역):
페이지 테이블의 두 엔트리가 같은 페이지 프레임을 가리키도록 허용하면 어떤 효과가 있는가?
이 효과가 대량의 메모리를 한 장소에서 다른 장소로 복사할 때 시간을 절약하는 데 어떻게 사용될 수 있는가?
한 페이지의 일부 바이트를 수정했을 때 다른 페이지에 어떤 영향이 있는가?

풀이:
	•	두 논리 페이지가 같은 물리 프레임을 가리키면 공유 메모리를 구현할 수 있습니다.
	•	메모리를 복사할 필요 없이, 두 페이지 테이블 엔트리를 같은 프레임으로 설정만 하면 되므로 속도 향상.
	•	그러나 한 페이지에서 바이트를 수정하면 다른 페이지도 영향을 받음 (둘 다 같은 실제 메모리를 참조하므로).
	•	이를 막기 위해선 “쓰기 시 복사(copy-on-write)” 기법 사용 가능.

⸻

좋습니다. 이어서 연습문제 9.6 ~ 9.10을 한글로 번역하고 풀이해드리겠습니다.

⸻

9.6

문제 (번역):
메모리 파티션이 다음과 같이 존재한다고 하자:
300KB, 600KB, 350KB, 200KB, 750KB, 125KB (순서대로).
다음과 같은 크기의 프로세스들을 순서대로 배치할 때,
115KB, 500KB, 358KB, 200KB, 375KB
first-fit, best-fit, worst-fit 알고리즘은 각각 어떻게 배치되는가?

풀이:

프로세스	크기	First-Fit	Best-Fit	Worst-Fit
P1	115KB	300KB → 185KB 남음	125KB → 10KB 남음	750KB → 635KB 남음
P2	500KB	600KB → 100KB 남음	600KB → 100KB 남음	635KB(기존 750KB) → 135KB
P3	358KB	750KB → 392KB 남음	392KB(기존 750KB) → 34KB	392KB → 34KB
P4	200KB	350KB → 150KB 남음	350KB → 150KB 남음	350KB → 150KB
P5	375KB	불가능 (남은 공간 부족)	불가능	불가능

	•	First-Fit: 처음 맞는 공간에 순서대로 배치.
	•	Best-Fit: 가장 근접하게 맞는 공간 선택 (낭비 최소화).
	•	Worst-Fit: 가장 큰 공간 선택 (남은 공간 최대화).

⸻

9.7

문제 (번역):
페이지 크기가 1KB일 때, 다음 주소(10진수)를 참조할 경우
페이지 번호와 페이지 내 오프셋은 어떻게 되는가?

풀이:
	•	페이지 크기 = 1KB = 2¹⁰ = 1024 바이트
	•	주소 = 페이지 번호 × 1024 + 오프셋

주소	페이지 번호 (주소 ÷ 1024)	오프셋 (주소 % 1024)
3085	3	13
42095	41	79
215201	210	721
650000	634	816
2000001	1953	673


⸻

9.8

문제 (번역):
BTV 운영체제는 21비트 가상 주소를 사용하지만, 일부 임베디드 장치에서는 16비트 물리 주소만 가진다.
페이지 크기는 2KB이다.
다음 항목별로 엔트리 수를 구하시오:
a. 일반적인 단일 레벨 페이지 테이블
b. 인버티드 페이지 테이블
그리고, BTV 운영체제에서 사용할 수 있는 최대 물리 메모리 크기는?

풀이:
	•	가상 주소: 21비트
페이지 크기: 2KB = 2¹¹ → 페이지 오프셋 = 11비트
→ 페이지 번호 비트 = 21 - 11 = 10비트
→ 페이지 수 = 2¹⁰ = 1024개 엔트리
	•	물리 주소: 16비트
페이지 크기: 2KB → 오프셋 = 11비트
→ 물리 프레임 수 = 2⁵ = 32개 프레임

a. 단일 레벨 페이지 테이블: 페이지 수 = 1024 → 1024개 엔트리
b. 인버티드 페이지 테이블: 프레임 수 = 32 → 32개 엔트리
c. 최대 물리 메모리 크기: 2¹⁶ 바이트 = 64KB

⸻

9.9

문제 (번역):
4KB 페이지 크기를 가진 256 페이지의 논리 주소 공간이 있고,
이는 64개의 물리 프레임에 매핑된다.
a. 논리 주소에 필요한 비트 수는?
b. 물리 주소에 필요한 비트 수는?

풀이:
	•	페이지 수 = 256 → 8비트
	•	페이지 크기 = 4KB = 2¹² → 오프셋 = 12비트

a. 논리 주소 비트 수 = 페이지 번호(8) + 오프셋(12) = 20비트
b. 물리 프레임 수 = 64 → 6비트
→ 물리 주소 비트 수 = 프레임 번호(6) + 오프셋(12) = 18비트

⸻

9.10

문제 (번역):
32비트 논리 주소와 4KB 페이지 크기를 가지는 컴퓨터 시스템이 있다.
최대 512MB의 물리 메모리를 지원한다.
다음 항목에서 페이지 테이블의 엔트리 수는?

a. 일반적인 단일 레벨 페이지 테이블
b. 인버티드 페이지 테이블

풀이:
	•	페이지 크기 = 4KB = 2¹²
	•	논리 주소 = 32비트 → 페이지 번호 = 32 - 12 = 20비트 → 페이지 수 = 2²⁰ = 1,048,576개
	•	물리 메모리 = 512MB = 2²⁹ → 프레임 수 = 2²⁹ ÷ 2¹² = 2¹⁷ = 131,072개

a. 단일 레벨 페이지 테이블: 2²⁰ = 1,048,576개 엔트리
b. 인버티드 페이지 테이블: 2¹⁷ = 131,072개 엔트리

