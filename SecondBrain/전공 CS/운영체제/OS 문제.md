9.1

문제 (번역):
논리 주소(logical address)와 물리 주소(physical address)의 차이점 두 가지를 말하시오.

풀이:
	1.	정의 차이:
	•	논리 주소는 CPU가 생성한 주소로, 가상 주소라고도 불리며 프로세스가 사용하는 주소입니다.
	•	물리 주소는 실제 메모리(RAM)에서의 위치를 나타내는 주소입니다.
	2.	주소 변환 여부:
	•	논리 주소는 주소 변환 과정을 통해 물리 주소로 매핑됩니다.
	•	주소 변환은 MMU(Memory Management Unit)가 수행합니다.

⸻

9.2

문제 (번역):
왜 페이지 크기는 항상 2의 거듭제곱인가?

풀이:
	•	주소 변환 시, 주소를 페이지 번호 + 페이지 오프셋으로 나누기 쉽기 때문입니다.
	•	2의 거듭제곱이면 비트 단위로 쉽게 나뉘므로, 연산 속도와 하드웨어 구현이 단순해집니다.

⸻

9.3

문제 (번역):
한 프로그램이 코드와 데이터 두 부분으로 나눌 수 있고, CPU가 명령어(fetch)와 데이터(fetch/store)를 구분할 수 있다고 가정하자.
이때, 명령어용(base-limit)과 데이터용(base-limit) 레지스터 쌍이 따로 제공된다. 명령어용 레지스터는 자동으로 읽기 전용이다.
이러한 구조의 장점과 단점을 논하라.

풀이:
	•	장점:
	1.	코드 공유가 가능함 → 여러 사용자 프로그램이 같은 코드 영역을 사용할 수 있어 메모리 절약.
	2.	명령어는 읽기 전용 → 버그나 악성 코드로부터 보호됨.
	•	단점:
	1.	프로그램 구조가 rigid → 코드와 데이터를 분리해야 해서 개발 복잡도 증가.
	2.	유연성 부족 → 일부 프로그램은 코드에서 데이터를 수정하거나 셀프-수정 코드를 사용할 수도 있음.

⸻

9.4

문제 (번역):
1,024단어(word) 크기의 64페이지로 이루어진 논리 주소 공간이 있고, 이가 32개의 프레임으로 구성된 물리 메모리에 매핑된다.
a. 논리 주소는 몇 비트인가?
b. 물리 주소는 몇 비트인가?

풀이:
	•	a. 논리 주소는 페이지 번호 + 오프셋
	•	페이지 수: 64 → 6비트
	•	각 페이지: 1,024 word → 10비트
	•	총 6 + 10 = 16비트
	•	b. 물리 프레임 수: 32 → 5비트
	•	각 프레임 크기: 1,024 word → 10비트
	•	총 5 + 10 = 15비트

⸻

9.5

문제 (번역):
페이지 테이블의 두 엔트리가 같은 페이지 프레임을 가리키도록 허용하면 어떤 효과가 있는가?
이 효과가 대량의 메모리를 한 장소에서 다른 장소로 복사할 때 시간을 절약하는 데 어떻게 사용될 수 있는가?
한 페이지의 일부 바이트를 수정했을 때 다른 페이지에 어떤 영향이 있는가?

풀이:
	•	두 논리 페이지가 같은 물리 프레임을 가리키면 공유 메모리를 구현할 수 있습니다.
	•	메모리를 복사할 필요 없이, 두 페이지 테이블 엔트리를 같은 프레임으로 설정만 하면 되므로 속도 향상.
	•	그러나 한 페이지에서 바이트를 수정하면 다른 페이지도 영향을 받음 (둘 다 같은 실제 메모리를 참조하므로).
	•	이를 막기 위해선 “쓰기 시 복사(copy-on-write)” 기법 사용 가능.

⸻

좋습니다. 이어서 연습문제 9.6 ~ 9.10을 한글로 번역하고 풀이해드리겠습니다.

⸻

9.6

문제 (번역):
메모리 파티션이 다음과 같이 존재한다고 하자:
300KB, 600KB, 350KB, 200KB, 750KB, 125KB (순서대로).
다음과 같은 크기의 프로세스들을 순서대로 배치할 때,
115KB, 500KB, 358KB, 200KB, 375KB
first-fit, best-fit, worst-fit 알고리즘은 각각 어떻게 배치되는가?

풀이:

프로세스	크기	First-Fit	Best-Fit	Worst-Fit
P1	115KB	300KB → 185KB 남음	125KB → 10KB 남음	750KB → 635KB 남음
P2	500KB	600KB → 100KB 남음	600KB → 100KB 남음	635KB(기존 750KB) → 135KB
P3	358KB	750KB → 392KB 남음	392KB(기존 750KB) → 34KB	392KB → 34KB
P4	200KB	350KB → 150KB 남음	350KB → 150KB 남음	350KB → 150KB
P5	375KB	불가능 (남은 공간 부족)	불가능	불가능

	•	First-Fit: 처음 맞는 공간에 순서대로 배치.
	•	Best-Fit: 가장 근접하게 맞는 공간 선택 (낭비 최소화).
	•	Worst-Fit: 가장 큰 공간 선택 (남은 공간 최대화).

⸻

9.7

문제 (번역):
페이지 크기가 1KB일 때, 다음 주소(10진수)를 참조할 경우
페이지 번호와 페이지 내 오프셋은 어떻게 되는가?

풀이:
	•	페이지 크기 = 1KB = 2¹⁰ = 1024 바이트
	•	주소 = 페이지 번호 × 1024 + 오프셋

주소	페이지 번호 (주소 ÷ 1024)	오프셋 (주소 % 1024)
3085	3	13
42095	41	79
215201	210	721
650000	634	816
2000001	1953	673


⸻

9.8

문제 (번역):
BTV 운영체제는 21비트 가상 주소를 사용하지만, 일부 임베디드 장치에서는 16비트 물리 주소만 가진다.
페이지 크기는 2KB이다.
다음 항목별로 엔트리 수를 구하시오:
a. 일반적인 단일 레벨 페이지 테이블
b. 인버티드 페이지 테이블
그리고, BTV 운영체제에서 사용할 수 있는 최대 물리 메모리 크기는?

풀이:
	•	가상 주소: 21비트
페이지 크기: 2KB = 2¹¹ → 페이지 오프셋 = 11비트
→ 페이지 번호 비트 = 21 - 11 = 10비트
→ 페이지 수 = 2¹⁰ = 1024개 엔트리
	•	물리 주소: 16비트
페이지 크기: 2KB → 오프셋 = 11비트
→ 물리 프레임 수 = 2⁵ = 32개 프레임

a. 단일 레벨 페이지 테이블: 페이지 수 = 1024 → 1024개 엔트리
b. 인버티드 페이지 테이블: 프레임 수 = 32 → 32개 엔트리
c. 최대 물리 메모리 크기: 2¹⁶ 바이트 = 64KB

⸻

9.9

문제 (번역):
4KB 페이지 크기를 가진 256 페이지의 논리 주소 공간이 있고,
이는 64개의 물리 프레임에 매핑된다.
a. 논리 주소에 필요한 비트 수는?
b. 물리 주소에 필요한 비트 수는?

풀이:
	•	페이지 수 = 256 → 8비트
	•	페이지 크기 = 4KB = 2¹² → 오프셋 = 12비트

a. 논리 주소 비트 수 = 페이지 번호(8) + 오프셋(12) = 20비트
b. 물리 프레임 수 = 64 → 6비트
→ 물리 주소 비트 수 = 프레임 번호(6) + 오프셋(12) = 18비트

⸻

9.10

문제 (번역):
32비트 논리 주소와 4KB 페이지 크기를 가지는 컴퓨터 시스템이 있다.
최대 512MB의 물리 메모리를 지원한다.
다음 항목에서 페이지 테이블의 엔트리 수는?

a. 일반적인 단일 레벨 페이지 테이블
b. 인버티드 페이지 테이블

풀이:
	•	페이지 크기 = 4KB = 2¹²
	•	논리 주소 = 32비트 → 페이지 번호 = 32 - 12 = 20비트 → 페이지 수 = 2²⁰ = 1,048,576개
	•	물리 메모리 = 512MB = 2²⁹ → 프레임 수 = 2²⁹ ÷ 2¹² = 2¹⁷ = 131,072개

a. 단일 레벨 페이지 테이블: 2²⁰ = 1,048,576개 엔트리
b. 인버티드 페이지 테이블: 2¹⁷ = 131,072개 엔트리
좋습니다. 아래는 운영체제 연습문제 9.11 ~ 9.27의 한글 번역과 해설입니다.

⸻

9.11

문제 (번역):
내부 단편화(internal fragmentation)와 외부 단편화(external fragmentation)의 차이를 설명하시오.

풀이:
	•	내부 단편화: 할당받은 블록 내부에 남는 사용하지 못하는 빈 공간
예: 18KB 요청 시 20KB 블록 할당 → 2KB 낭비
	•	외부 단편화: 전체로 보면 여유 메모리가 많지만, 연속된 큰 블록이 없어 요청을 처리하지 못하는 현상
예: 3KB, 4KB, 2KB 등 흩어진 블록 → 10KB 요청 처리 불가

⸻

9.12

문제 (번역):
컴파일러가 개별 모듈에 대해 목적 코드(object code)를 생성하고, 링커(linker)는 여러 개의 오브젝트 모듈을 하나의 실행 파일로 결합한다.
이 과정에서 링커는 명령어와 데이터를 메모리 주소에 어떻게 바인딩하는가?
컴파일러에서 링커로 어떤 정보가 전달되어야 하는가?

풀이:
	•	링커는 각 모듈의 상대 주소를 절대 주소로 바인딩합니다.
	•	컴파일러는 심볼 테이블, 참조 목록, 정의된 기호 등을 링커에게 전달하여 링커가 주소를 정확히 매핑할 수 있도록 도와야 합니다.

⸻

9.13

문제 (번역):
메모리 파티션이 다음과 같다: 100MB, 170MB, 40MB, 205MB, 300MB, 185MB
프로세스 요청: 200MB, 15MB, 185MB, 75MB, 175MB, 80MB
각각의 요청을 first-fit, best-fit, worst-fit으로 배치하시오. 불가능한 요청이 있다면 명시하시오. 각 알고리즘의 메모리 효율성을 비교하시오.

풀이 요약 (표는 생략):
	•	First-Fit: 공간을 찾을 수 없으면 건너뜀. 중간에 많은 작은 조각 남음 → 외부 단편화 발생
	•	Best-Fit: 낭비 최소화하지만, 많은 작은 조각 발생 가능
	•	Worst-Fit: 큰 공간 먼저 사용하여 대형 프로세스 수용이 힘들 수 있음

➡ 요청 200MB는 205MB, 300MB에서만 수용 가능. 요청 175MB는 불가능할 수 있음. 정확한 테이블도 원하시면 만들어 드릴 수 있습니다.

⸻

9.14

문제 (번역):
실행 중 주소 공간에 메모리를 추가로 할당하는 시스템이 많다.
힙 영역에 데이터를 할당하는 것은 그 예이다.
다음 메모리 관리 방식에서 동적 메모리 할당을 지원하려면 무엇이 필요한가?

a. 연속 메모리 할당 (Contiguous Memory Allocation)
b. 페이징 (Paging)

풀이:
a. 연속 할당에서는 힙의 끝 주소를 조정하고, 연속된 빈 공간 확보가 필요함 → 압축(compaction) 필요
b. 페이징에서는 빈 프레임만 있으면 아무 데나 할당 가능, 주소 공간 확장 쉬움

⸻

9.15

문제 (번역):
연속 메모리 할당과 페이징 메모리 구조를 다음 항목에 대해 비교하시오.

a. 외부 단편화
b. 내부 단편화
c. 코드 공유 가능성

풀이:

항목	연속 할당	페이징
외부 단편화	있음	없음
내부 단편화	거의 없음	있음 (페이지 끝 공간 낭비)
코드 공유	어렵다	페이지 단위로 공유 쉬움


⸻

9.16

문제 (번역):
페이징 시스템에서 프로세스는 자신이 소유하지 않은 메모리에 접근할 수 없다.
그 이유는? 운영체제가 추가 메모리 접근을 허용하려면 어떻게 해야 하는가?
이것을 허용해야 하는가, 말아야 하는가?

풀이:
	•	이유: MMU와 페이지 테이블이 해당 페이지가 프로세스에 속하는지 검사 → 보호 기능
	•	허용하려면: 공유 메모리 페이지를 매핑
	•	허용 이유: IPC(프로세스 간 통신), 라이브러리 공유 등
	•	허용하지 말아야 할 경우: 보안 문제, 권한 오용

⸻

9.17

문제 (번역):
iOS, Android와 같은 모바일 OS는 왜 스와핑(swap)을 지원하지 않는가?

풀이:
	•	플래시 메모리는 쓰기 횟수가 제한됨 → 스와핑은 많은 쓰기를 유발
	•	전력 소비, 성능 저하, 수명 단축 → 모바일 환경 부적합

⸻

9.18

문제 (번역):
Android는 부팅 디스크에서 스와핑을 지원하지 않지만, SD 카드 같은 외부 디스크에서는 가능하다.
왜 부팅 디스크에서는 금지되고 외부 디스크에서는 허용되는가?

풀이:
	•	부팅 디스크는 내장 NAND 플래시 → 수명 보호 목적
	•	외부 SD는 교체 가능하므로 스와핑 허용
	•	사용자 선택으로 성능 향상과 디스크 보호를 절충

⸻

9.19

문제 (번역):
TLB에서 주소 공간 식별자(ASID)를 사용하는 이유는 무엇인가?

풀이:
	•	여러 프로세스가 서로 다른 페이지 테이블을 사용하므로,
같은 가상 주소라도 서로 다른 의미를 가질 수 있음
	•	ASID는 어떤 프로세스의 항목인지 구별 → TLB context switch 시 invalidate 필요 없음

⸻

9.20

문제 (번역):
대부분의 시스템에서 실행 파일 구조는 다음과 같다:
코드는 작은 고정 가상 주소(예: 0)에서 시작되며, 그 다음에 데이터 세그먼트가 위치한다.
스택은 주소 공간 반대편에서 시작하여 낮은 주소로 자라난다.
이 구조가 다음 메모리 관리 방식에 어떤 의미를 가지는가?

a. 연속 메모리 할당
b. 페이징

풀이:
a. 연속 할당에서는 코드, 데이터, 스택이 단일 블록 내에 배치되어야 하므로 중간 충돌 가능성 존재
b. 페이징에서는 각 세그먼트를 다른 페이지 영역에 매핑 가능 → 유연하고 안전

⸻

9.21

문제 (번역):
페이지 크기가 1KB일 때 다음 주소에 대한 페이지 번호와 오프셋을 구하시오.

주소	페이지 번호	오프셋
21205	20	725
164250	160	250
121357	118	205
16479315	16092	163
27253187	26609	483

(주소 ÷ 1024, 주소 % 1024 계산)

⸻

9.22

문제 (번역):
MPV 운영체제:
	•	가상 주소: 24비트
	•	물리 주소: 20비트
	•	페이지 크기: 4KB

다음 항목에서 엔트리 수는?
a. 단일 레벨 페이지 테이블
b. 인버티드 페이지 테이블
그리고 최대 물리 메모리는?

풀이:
	•	페이지 크기 4KB = 2¹²
	•	가상 주소 = 24비트 → 페이지 수 = 2¹² = 4096개
	•	물리 주소 = 20비트 → 최대 메모리 = 2²⁰ = 1MB
→ 프레임 수 = 2²⁰ / 2¹² = 2⁸ = 256

a. 단일 페이지 테이블 = 4096개
b. 인버티드 페이지 테이블 = 256개
최대 물리 메모리 = 1MB

⸻

9.23

문제 (번역):
논리 주소 공간: 2048 페이지, 페이지 크기: 4KB
물리 메모리: 512 프레임
a. 논리 주소 비트 수?
b. 물리 주소 비트 수?

풀이:
	•	페이지 수 = 2¹¹ → 11비트
	•	오프셋 = 2¹² → 12비트
a. 논리 주소 = 11 + 12 = 23비트
b. 프레임 수 = 2⁹ → 물리 주소 = 9 + 12 = 21비트

⸻

9.24

문제 (번역):
32비트 논리 주소, 8KB 페이지, 물리 메모리 최대 1GB
a. 단일 페이지 테이블 엔트리 수
b. 인버티드 페이지 테이블 엔트리 수

풀이:
	•	8KB = 2¹³ → 페이지 수 = 2¹⁹
	•	물리 메모리 = 2³⁰ → 프레임 수 = 2¹⁷

a. 단일 페이지 테이블 = 2¹⁹ = 524,288개
b. 인버티드 페이지 테이블 = 2¹⁷ = 131,072개

⸻

9.25

문제 (번역):
페이지 테이블이 메모리에 저장되는 시스템에서:

a. 메모리 접근 시간 = 50ns일 때, 페이징 메모리 접근 시간은?
b. TLB 사용 시, 75%는 TLB에 있음. TLB 접근 = 2ns일 때, 평균 접근 시간은?

풀이:

a. 1 메모리 접근 + 1 페이지 테이블 접근 = 2 × 50 = 100ns
b.
	•	TLB hit: 2ns + 50ns = 52ns
	•	TLB miss: 2ns + 100ns = 102ns
	•	평균 = 0.75×52 + 0.25×102 = 64ns

⸻

9.26

문제 (번역):
페이지 테이블을 페이징하는 목적은?

풀이:
	•	큰 페이지 테이블을 다루기 위해 다단계 페이지 테이블 구조 사용
	•	메모리 절약 및 관리 용이성 향상

⸻

9.27

문제 (번역):
IA-32 주소 변환(Fig 9.22 기준)

a. 논리 주소를 물리 주소로 변환하는 모든 단계를 설명하시오
b. 이런 복잡한 변환을 하드웨어가 제공할 때 운영체제의 장점은?
c. 단점은 있는가? 있다면 왜 이 구조가 보편화되지 않았는가?

풀이 요약:

a. 세그먼트 + 오프셋 → 디렉토리 → 테이블 → 프레임
b. 가상 메모리, 보호 기능, 다중 사용자 지원
c. 복잡성 증가, 속도 저하, 구현 비용 증가 → 단순한 시스템에서는 불필요

