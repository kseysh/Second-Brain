## Basic Steps in Query Processing
1. Parsing and translation
2. Optimization
3. Evaluation
![[Pasted image 20250529135105.png|300]]
## 기본 단계: 최적화
질의 최적화(Query Optimization): 동일한 의미를 가지는 모든 평가 계획들 중에서 가장 비용이 적은 것을 선택한다.
비용은 데이터베이스 카탈로그의 통계 정보를 사용하여 추정한다.
• 예: 각 릴레이션의 튜플 수, 튜플 크기 등

이 장에서는 다음을 다룬다:
	•	질의 비용 측정 방법
	•	관계 대수 연산을 평가하는 알고리즘들
## 질의 비용의 측정
비용은 일반적으로 질의에 응답하는 데 걸리는 total elapsed time으로 측정된다.
	많은 요인들이 시간 비용에 기여한다:
		• 디스크 접근, CPU, 심지어 네트워크 통신 등
일반적으로 disk access가 predominant cost이며, 상대적으로 추정하기 쉽다.
다음 요소를 고려하여 측정한다:
	•	읽은 블록 수 × 평균 블록 읽기 비용
	•	쓴 블록 수 × 평균 블록 쓰기 비용
		• 블록 쓰기 비용은 블록 읽기 비용보다 크다.
			– 데이터가 성공적으로 쓰였는지 확인하기 위해 다시 읽기 때문이다.

여러 알고리즘들은 추가 버퍼 공간을 사용하여 디스크 I/O를 줄일 수 있다.
	사용 가능한 실질 메모리 양은 실행 중인 다른 질의 및 OS 프로세스에 따라 달라지며, 실행 시에만 알 수 있다.
		• 일반적으로는 최악의 경우를 가정하여, 연산에 필요한 최소 메모리만 사용 가능하다고 본다.
필요한 데이터가 이미 버퍼에 있을 수 있어 디스크 I/O를 피할 수 있다.
## 요약: I/O 복잡도 모델
간단하게 하기 위해 디스크에서 전송된 블록 수만 사용한다.
	•	M: 메모리 크기, 즉 주 메모리에 적재할 수 있는 튜플 수
	•	B: 블록 크기, 즉 블록 하나에 들어갈 수 있는 튜플 수
	•	N: 릴레이션 내 튜플 수 (예: Ns, Nr 등)
	•	선형 I/O: O(N/B)
	•	로그 I/O: O(log<sub>B</sub> N)
CPU 비용과 탐색 비용은 단순화를 위해 무시한다.
	실제 시스템은 CPU 비용도 고려한다.
## 선택 연산(Selection Operation)
파일 스캔
알고리즘 A1 (선형 검색): 각 파일 블록을 스캔하고 모든 레코드가 선택 조건을 만족하는지 검사
	•	I/O 비용 = O(N/B), 자명함
	•	선형 검색은 다음과 무관하게 적용 가능
		• 선택 조건
		• 파일 내 레코드 정렬 여부
		• 인덱스 존재 여부
메모리가 커서 M > N인 경우에도,
	•	여전히 N개의 튜플(즉, N/B 블록)을 메모리로 적재해야 한다.
## 인덱스를 사용하는 선택
인덱스 스캔 – 인덱스를 사용하는 탐색 알고리즘
	•	선택 조건은 인덱스의 검색 키여야 함
A2 (primary B+ tree index, equality on key)
	•	해당 등치 조건을 만족하는 단일 레코드 검색
	•	정확한 탐색
	•	I/O 비용 = O(log<sub>B</sub> N)
A3 (primary B+ tree index, equality on non-key)
	•	같은 검색 키 값을 가진 다수 레코드 검색
	•	T = 검색 키 값을 가진 레코드 수 (연속된 공간에 위치해 있으므로 Block 단위로 가져오면 T/B)
	•	I/O 비용 = O(log<sub>B</sub> N + T/B)
## 보조 인덱스를 사용하는 선택
A4 (보조 인덱스, 비키 속성의 등치 조건)
	•	검색 키가 후보 키일 경우: <u>단일 레코드</u> 검색
		• I/O 비용 = O(logB N)
	•	검색 키가 후보 키가 아닐 경우: <u>다수 레코드</u> 검색
		• T개의 레코드가 각각 다른 블록에 있을 수 있음
		• 비용 = I/O 비용 = O(logB N + T) 
			– 매우 비쌀 수 있다!
## 비교 연산이 포함된 선택
σA≤V(r) 또는 σA≥V(r) 형태의 선택은 선형 파일 스캔 또는 인덱스를 사용하여 구현 가능하다.

A5 (기본 인덱스, 비교) – 릴레이션이 A 속성 기준으로 정렬된 경우
	• σA≥V(r): 인덱스로 v 이상인 첫 튜플 찾고, 그 지점부터 릴레이션을 순차 스캔, O(log<sub>B</sub>N + T/B)
	• σA≤V(r): v보다 큰 첫 튜플 전까지 순차 스캔; 인덱스 사용 안 함  O(T/B)

A6 (보조 인덱스, 비교)
	• σA≥V(r): 인덱스에서 v 이상인 첫 항목 찾고, 그 지점부터 인덱스를 순차 스캔하여 레코드 포인터 획득
		• O(log<sub>B</sub>N + T)
	• σA≤V(r): 인덱스 리프 페이지를 스캔하여 포인터 획득; 첫 항목이 v보다 클 때까지
		• O(T) of O(N/B)
	• 두 경우 모두 포인터가 가리키는 레코드를 검색
		– 레코드마다 I/O 발생
		– 선형 스캔이 더 쌀 수 있음 → T보다 N/B가 더 쌀 수 있기 때문
## 정렬(Sorting)
정렬을 하는 이유?
	• 조인과 같은 많은 관계 연산은 입력 릴레이션이 정렬되어 있을 때 효율적으로 수행 가능하다.
• 인덱스를 만든다고 해도 (보통 보조 인덱스), 실제 릴레이션이 물리적으로 정렬된 것은 아님
• M > N이라면 메모리에 적합하므로, 퀵소트 같은 기술 사용 가능
• 그렇지 않은 경우, 외부 병합 정렬(external merge sort)이 적합
## 외부 병합 정렬(External Merge Sort)
→ 런 수 = O(N/M)
M/B는 블록 단위로 본 메모리 크기라 하자.
1.	정렬 런(run) 생성. i = 0부터 시작 Cost: O(N/B)
	반복:
		(a) M/B 블록을 읽어 메모리에 적재
		(b) 메모리 내 데이터를 정렬
		(c) 정렬된 데이터를 Ri로 출력 후 i 증가
	최종적으로 i = N이 될 때까지
런 수를 K라고 하자 (즉, O(N/M))
2. 런을 병합(K-way merge), 가정: K < M/B, Cost: O(N/B)
	1.	입력 런마다 하나씩 K개의 블록을 메모리에 버퍼로 할당하고, 출력용 버퍼 1개 사용
	2.	반복
		① 모든 버퍼 페이지 중 가장 작은 레코드 선택
		② 출력 버퍼에 기록. 버퍼가 가득 차면 디스크에 기록
		③ 해당 입력 버퍼에서 레코드 삭제
			•	버퍼가 비면 해당 런의 다음 블록 로드
	3.	모든 입력 버퍼가 빌 때까지 반복
K ≥ M/B이면 병합을 여러 번 해야 함
	• 매번 M/B - 1개의 런을 병합
	• 병합 시 런 개수는 M/B - 1만큼 줄고, 길이는 그만큼 길어짐
		예: M/B=11, 런이 90개 → 병합 1회 후 9개의 런, 각 런은 기존보다 10배 김
→ 모든 런이 하나로 병합될 때까지 반복
![[Pasted image 20250602155811.png|300]]

최악의 경우 비용 분석
	•	정렬 런 생성
		• 런 수 = O(N/M)
		• 각 런의 블록 수 = O(M/B)
		• I/O 비용 = O(N/B), 선형
	•	병합 1단계
		• 병합할 런 수 = O(N/M)
		• 각 런의 블록 수 = O(M/B)
		• I/O 비용 = O(N/B)
	•	병합 2단계
		• 병합할 런 수 = O((N/M)/(M/B)) = O(BN/M²)
		• 각 런의 블록 수 = O((M/B)²) = O(M²/B²)
		• I/O 비용 = O(N/B)
	•	병합 i단계
		• 여전히 선형 I/O

최악의 경우 비용 분석
	따라서 각 단계(pass)는 O(N/B), 즉 선형적인 입출력을 필요로 한다.
	총 I/O 양은 단계 수에 O(N/B)를 곱한 값으로 결정된다.
병합 단계(merging pass)의 수:
	• O(logM/B(N/M)) 왜 그런가?
전체 I/O는 다음과 같이 표현된다:
	• O((N/B) logM/B(N/B))
이는 사실 메모리 내 정렬의 O(n log n) 복잡도에 해당하는 것으로,
	즉 최적의 복잡도를 의미한다.