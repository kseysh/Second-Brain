## 데이터는 어디(어떻게) 실제로 저장되는가?
어떤 종류의 저장소가 있는가?
물리적 저장 매체의 특성 (즉, 하드웨어)
	•	자기 디스크와 플래시 저장장치
파일 조직
	•	파일 내 레코드의 구성
디스크 접근 속도를 높이려면?
	•	버퍼 관리자(Buffer Manager)
## Storage Hierarchy
![[Pasted image 20250501133759.png|400]]

## Physical Storage Media
•	캐시(Cache): 가장 빠르고 가장 비용이 높은 저장 형태; 휘발성; 하드웨어에 의해 관리됨
	접근 시간: 수 나노초 (10⁻⁹초)
•	주기억장치(RAM):
	접근 시간: 수백 나노초 (10⁻⁷초)
	Volatile(휘발성) – 전원 장애나 시스템 충돌 시 일반적으로 내용이 손실됨
•	플래시 메모리: 비휘발성
	접근 시간: 10⁻⁴ ~ 10⁻⁵초 (100마이크로초 미만)
		•	RAM보다 느리지만 자기 디스크보다 빠름
•	자기 디스크(Magnetic Disk): 비휘발성
	접근 시간: 수 밀리초 (10⁻³초)
		•	메인 메모리보다 훨씬 느림
		•	데이터를 접근하려면 디스크에서 메인 메모리로 이동 후 사용, 저장 시 다시 디스크로 기록해야 함
## 파일 조직
record - physical적인 측면에서의 tuple
field - physical적인 측면에서의 attribute
- 데이터베이스는 파일들의 모음으로 저장됨.
	- 각 파일은 record들의 순차열이며,
		- 하나의 record는 필드들의 순차열이다.
- 각 파일은 고정 길이의 저장 단위인 **Block**들로 나뉨 (저장 할당 및 데이터 전송 단위)
	- 하나의 block에는 여러 record가 들어갈 수 있음
### 레코드를 파일에 어떻게 구성할 것인가?
다음 조건을 가정하자:
	•	레코드 크기는 고정
	•	파일 하나에는 한 가지 타입의 레코드만 존재
	•	다른 릴레이션은 서로 다른 파일에 저장
- Two types of records
	- Fixed-length records
	- Variable-length records
## External-Memory Model
- EM(External-Memory) 모델은 RAM(주기억 장치) 모델과 다르다.
	- RAM 모델에서의 시간 복잡도 (기존 알고리즘 분석 방식)
		- 기본 연산의 수 (예: 메모리 접근 횟수)
	- EM 모델에서의 I/O 복잡도
		- 외부 메모리로부터의 읽기/쓰기 횟수
- 자주 사용되는 표기
	- N: 데이터 파일에 있는 레코드 수
	- M: 주기억장치에 담을 수 있는 레코드 수
	- B: 하나의 블록에 담을 수 있는 레코드 수
=> EM 모델은 RAM 모델과 달리 시간 복잡도를 디스크 접근 횟수를 기준으로 판단해야 한다 (디스크 접근 속도는 메모리에 비해 훨씬 느리기 때문)
## Fixed-Length Records
![[Pasted image 20250501140222.png|300]]
Linear I/O : O(N/B) -> N개의 데이터를 B 블록 단위로 가져올 때의 시간 복잡도

단순한 접근 방식:
	•	i번째 레코드를 바이트 n * (i - 1)부터 저장 (n은 각 레코드 크기)
	•	접근은 단순하지만 레코드가 블록 경계를 넘을 수 있음
	•	일반적 가정: 레코드는 블록 경계를 넘지 않도록 함
레코드 i의 삭제:
- (단순 방식)
	- 레코드 i+1부터 n까지 i부터 n-1까지 이동
	- O(N/B) I/O 발생
- (개선 방식)
	- 레코드 n을 i에 이동
	- 이동하지 않고 삭제된 레코드들을 free list로 연결
	- O(1) I/O 발생
![[Pasted image 20250501140359.png|200]]
![[Pasted image 20250501140532.png|400]]
Einstein(record 3)을 삭제후 record 11을 삽입한 경우
## Maintaining Free Lists
- 삭제된 첫 번째 레코드의 주소를 파일 헤더에 저장.
- 이 첫 번째 레코드를 사용해 두 번째 삭제된 레코드의 주소를 저장하고, 이와 같은 방식으로 계속 이어나간다.
- 이 저장된 주소들은 레코드의 위치를 “가리키기” 때문에 포인터처럼 생각할 수 있다.
- 더 공간 효율적인 표현 방법은: 사용되지 않는 레코드의 일반 속성 공간을 포인터 저장에 재사용하는 것이다. (사용 중인 레코드에는 포인터를 저장하지 않음.)
- 상수 시간 I/O가 발생함
- *T개의 empty space가 있다면, O(T) I/O's가 발생할 수 있다. (O(T/B)가 아님)*
![[Pasted image 20250501143216.png|300]]
## 가변 길이 레코드
가변 길이 레코드는 다음과 같은 경우에 발생:
	•	하나의 파일에 여러 레코드 타입 저장
	•	문자열(varchar) 등 하나 이상의 필드 길이가 가변적인 경우
	•	반복 필드(배열, 집합) 허용
![[Pasted image 20250508135450.png|200]]
가변 길이 레코드 표현 방법:
	두 부분으로 구성
		•	고정 길이 속성을 저장하는 초기 부분
		•	가변 길이 속성 데이터
	•	가변 속성은 (offset, length) 쌍으로 표현하고 실제 데이터는 고정 속성 뒤에 저장
	•	null 값은 null-value 비트맵으로 표현
![[Pasted image 20250501144031.png|300]]
dept_name인 Comp. Sci를 알고 싶다면, dept_name은 세 번째 필드이므로 8로 가서 좌표값을 확인하고, 36부터 10만큼 읽는다. (가변 길이만 이렇게 하고, fixed length는 그냥 저장함)
null bitmap은 fixed length와 variable length사이에 넣어둔다.
## 가변 길이 레코드 - Slotted Page Structure
![[Pasted image 20250508133432.png|400]]
•	Slotted Page Header에는 다음 정보가 포함됨:
	•	레코드 항목 수
	•	블록 내 자유 공간 끝 위치
	•	각 레코드의 위치와 크기
•	레코드들은 페이지 내에서 이동 가능하며, 빈 공간 없이 연속되도록 유지 (한 레코드가 삭제되면 빈공간을 채우기 위해 block 안의 레코드를 모두 민다)
•	헤더의 항목은 반드시 갱신해야 함
•	포인터는 레코드 자체가 아니라 entry for the record in header를 가리켜야 함 (실제 레코드는 위치가 변경되므로 생각해보면 당연함)

Block의 구성: 
Header: 메타데이터 저장
Entry Table: 각 레코드의 위치와 크기 저장
Records: 실제 레코드 저장
#### example in postgres
![[Pasted image 20250508141643.png|400]]
## 파일 내 레코드 구성 방법
레코드 집합을 파일에 어떻게 배치할 것인가?
•	힙(Heap): 레코드를 공간이 있는 아무 곳에나 배치
	삽입이 빠름
	검색 느림
•	순차(Sequential): 레코드를 검색 키 값(보통 pk)에 따라 순서대로 저장
	- binary search로 빠른 검색 가능
	- 삽입 삭제 시 정렬 유지 비용있음
•	해싱(Hashing): 특정 속성에 대해 해시 함수를 적용하여 결과에 따라 파일의 블록 결정
	매우 빠른 검색/삽입
	해시 충돌 처리 필요
## 순차 파일 조직
![[Pasted image 20250508133516.png|300]]
•	파일 전체를 순차 처리하는 애플리케이션에 적합
•	파일 내 레코드는 검색 키에 따라 정렬되어 있음
•	삭제: 포인터 체인 사용
•	삽입:
	•	삽입 위치에 빈 공간 있으면 그 위치에 삽입
	•	없으면 오버플로 블록에 삽입
	•	어떤 경우든 포인터 체인을 업데이트해야 함
•	정기적으로 파일을 재조직하여 순서를 복원해야 함
![[Pasted image 20250508133545.png|300]]
## 저장소 접근
데이터베이스 파일은 고정 길이 저장 단위인 블록으로 나뉨
•	블록은 저장 할당과 데이터 전송의 단위
•	데이터베이스 시스템은 디스크와 메모리 간 블록 전송을 최소화하려 함
•	가능한 많은 블록을 메인 메모리에 유지하여 디스크 접근 횟수 감소
•	버퍼: 디스크 블록 복사본을 저장할 수 있는 메인 메모리 일부
•	버퍼 관리자: 메인 메모리의 버퍼 공간 할당을 담당하는 하위 시스템
## 버퍼 관리자
프로그램은 디스크 블록이 필요할 때 버퍼 관리자에게 요청
	1.	요청한 블록이 버퍼에 있으면 해당 메모리 주소 반환
	2.	없으면 버퍼 공간을 할당함
	•	공간 부족 시 다른 블록을 교체 (필요 시)
	•	교체되는 블록은 변경된 경우에만 디스크에 다시 기록
	•	디스크에서 블록을 읽어 버퍼에 저장 후 메모리 주소 반환
## 버퍼 교체 정책
•	대부분 운영체제는 가장 오래 전에 사용된 블록을 교체 (LRU 전략)
### LRU의 아이디어: 과거 접근 패턴으로 미래 접근을 예측
•	쿼리는 명확한 접근 패턴을 가지므로, DB 시스템은 쿼리 정보를 이용해 미래 접근 예측 가능
	•	하지만 반복 스캔이 많은 패턴에는 LRU가 비효율적
		예: 중첩 루프 방식으로 두 릴레이션 r, s를 조인할 때
	•	쿼리 최적화기가 교체 전략에 대한 힌트를 제공하는 혼합 전략이 더 바람직함
```
for each tuple tr of r do
  for each tuple ts of s do
    if the tuples tr and ts match...
```

### MRU (Most Recently Used) 전략:
•	현재 처리 중인 블록은 핀(pin) 상태로 유지
•	마지막 튜플 처리 후 블록은 언핀(unpin)되고, 가장 최근 사용 블록이 됨
	•	*pinned block*: 디스크에 다시 기록되는 것이 허용되지 않는 메모리 블록
•	버퍼 관리자는 특정 릴레이션이 참조될 확률에 대한 통계적 정보를 사용할 수 있음
	예: 데이터 사전은 자주 접근되므로 이를 메인 메모리에 유지하는 것이 유리함 (휴리스틱 사용)

![[Pasted image 20250513140752.png|300]]
R1은 pinned block으로 관리됨
MRU에서는 가장 최근에 사용된 블록인 S3와 교체하고, (이로서 S2를 읽을 때 S2를 다시 불러오지 않아도 됨)
LRU에서는 가장 오래전에 사용된 블록인 S2와 교체한다.
