## 기본 개념
Ordered Index(정렬된 인덱스)
B+ 트리 인덱스 파일
B-트리 인덱스 파일
## 동기
- 데이터베이스에서 인덱스란 무엇인가?
	- 간단히 말해, 원하는 레코드를 효율적으로 찾기 위한 잘 설계된 자료 구조입니다.
	- 왜 이렇게 다양한 인덱스 유형이 존재하는가?
		- 다양한 데이터 타입
		- 다양한 쿼리 유형
	- 매우 간략히 말하면, 데이터 엔지니어가 하는 일은 기본 데이터에 적절한 인덱스를 설계하고 사용하는 것입니다.
	- 그렇다면 왜 인덱스가 필요한가?
	- 다음과 같은 쿼리를 효율적으로 수행하기 위해서입니다:
```sql
select name, dept_name, salary  
from instructor  
where ID = 15151;
```
## 기본 개념
- 인덱싱 메커니즘은 원하는 데이터 접근을 빠르게 하기 위해 사용됩니다.
	- 예: 도서관의 저자 색인
- Search Key(검색 키): 파일 내 레코드를 찾기 위해 사용하는 속성(또는 속성 집합)
- 인덱스 파일은 다음 형식의 레코드(인덱스 항목)들로 구성됩니다:
	- search-key pointer
- 인덱스 파일은 일반적으로 원본 파일보다 훨씬 작습니다.
- 인덱스의 기본 유형 두 가지:
	1. Ordered indices (정렬 인덱스): 검색 키가 정렬된 순서로 저장됨
	2. Hash indices (해시 인덱스): 해시 함수를 이용해 키가 “버킷”에 균일하게 분산됨
## 인덱스 평가 지표
•	효율적으로 지원하는 접근 방식
	예: 특정 값을 가진 레코드, 또는 값 범위 내에 있는 레코드
•	접근 시간
•	삽입 시간
•	삭제 시간
•	공간 오버헤드

이론적으로 인덱스 성능을 분석하는 방법: 외부 메모리 모델 (강의노트 참고)
## Ordered Indices (정렬 인덱스)

*ordered index*는 검색 키 값을 기준으로 정렬된 순서로 index 항목을 저장합니다. 예: 도서관 저자 색인
•	Primary index (기본 인덱스): 파일이 정렬된 순서대로 저장되어 있으며, 이 순서를 결정하는 검색 키를 가진 인덱스 (*clustering index*라고도 함)
	•	보통 기본 키가 검색 키지만, 반드시 그렇지는 않음
•	*Secondary index* (보조 인덱스): 파일의 순서와는 다른 순서로 검색 키를 정렬한 인덱스 (non-clustering index라고도 함)
•	*Index-sequential file*: 기본 인덱스를 가진 정렬된 파일 (?)
## Dense Index Files
![[Pasted image 20250513142647.png|300]]
•	Dense Index Files: 파일 내 모든 검색 키 값에 대해 index record가 존재
	•	예: instructor 테이블의 ID 속성에 대한 인덱스

![[Pasted image 20250513142754.png|300]]
- dense index on dept_name with instructor file sorted on dept_name
## Sparse Index Files
• **Sparse Index**: 일부 검색 키 값에 대해서만 인덱스 레코드를 포함함
	– 검색 키를 기준으로 레코드가 순차적으로 정렬되어 있을 때 사용 가능
• 검색 키 값이 K인 레코드를 찾기 위해서는:
	– K보다 작은 검색 키 값 중 가장 큰 값을 가진 인덱스 레코드를 찾음
	– 해당 인덱스 레코드가 가리키는 레코드부터 파일을 순차적으로 검색함
![[Pasted image 20250513143209.png|300]]

• Dense Index와 비교할 때:
– 공간을 덜 차지하고, 삽입 및 삭제 시 유지 관리 비용이 더 적다.
– 일반적으로 레코드 검색 속도는 조밀 인덱스보다 느리다.

• 좋은 절충안: 파일의 각 블록마다 하나의 인덱스 항목을 가지는 희소 인덱스.
이 인덱스 항목은 해당 블록에서 가장 작은 검색 키 값에 대응한다. why?  => 어차피 DB는 block단위로 data를 가져오기 때문
dense Index: N 개 항목, 블록당 B개 :O(N/B) blocks
sparse Index: N/B 개 항목, 블록당 B개: O(N/B<sup>2</sup>)
![[Pasted image 20250513143231.png|200]]
#### sparse index를 이용한 cost 계산 example
N<sub>data</sub> = 20,000,000 (20 M)
B<sub>data</sub> = 20
N<sub>index</sub> = 1M 개의 block 존재
B<sub>index</sub> = 100 이라 가정 (Block size는 동일하지만 index는 key와 pointer만 들어가면 되므로)
index block = N<sub>index</sub>/B<sub>index</sub> = 10000
이분 탐색을 이용한 cost: O(log n) = 13.xxx = 14번 I/O
N이 data를 저장한 block의 개수일 때, 
N/2<sup>i</sup> = B
O(log<sub>2</sub>N/B)
## Multilevel Index
- 기본 인덱스가 메모리에 맞지 않으면 접근 비용이 증가
- 해결책:
	•	디스크상의 Primary index를 정렬된 파일로 보고, 그 위에 sparse index를 구축
	•	외부 인덱스: 기본 인덱스에 대한 희소 인덱스
	•	내부 인덱스: 기본 인덱스 파일

- 외부 인덱스도 메모리에 안 들어갈 경우, 더 상위 단계 인덱스를 생성 가능
- 삽입/삭제 시 모든 수준의 인덱스를 갱신해야 함

![[Pasted image 20250515140224.png|300]]
h = O(log<sub>B</sub>N)
N/Bh
## 인덱스 갱신: 삭제
	•	삭제된 레코드가 해당 검색 키 값을 가진 유일한 레코드였다면, 인덱스에서도 해당 검색 키 삭제

단일 수준 인덱스 삭제:
	•	조밀 인덱스: 파일 레코드 삭제와 유사
	•	희소 인덱스:
	•	검색 키에 해당하는 항목이 있다면, 그 다음 검색 키 값으로 교체
	•	다음 검색 키가 이미 존재하면, 해당 항목을 삭제

⸻

인덱스 갱신: 삽입

단일 수준 인덱스 삽입:
	•	삽입될 레코드의 검색 키로 조회 수행
	•	조밀 인덱스: 검색 키가 없으면 추가
	•	희소 인덱스: 블록당 하나의 항목이면 블록이 새로 생긴 경우에만 인덱스 갱신
	•	새 블록이 생기면, 그 블록의 첫 검색 키 값을 인덱스에 삽입

다단계 삽입/삭제: 단일 수준 알고리즘의 확장

⸻

보조 인덱스 (Secondary Indices)

기본 인덱스의 검색 키가 아닌 다른 필드 값을 조건으로 레코드를 찾고 싶을 때 사용

예제 1: instructor 테이블이 ID 기준으로 정렬되어 있을 때, 특정 학과의 교수 찾기
예제 2: 특정 급여 또는 급여 범위에 속한 교수 찾기
	•	각 검색 키 값에 대해 인덱스 레코드가 있는 조밀 인덱스 필요

⸻

보조 인덱스 예시
	•	인덱스 레코드는 해당 검색 키 값을 가진 모든 실제 레코드들의 포인터가 들어있는 버킷을 가리킴
	•	보조 인덱스는 항상 조밀 인덱스여야 함

⸻

기본 인덱스와 보조 인덱스
	•	인덱스는 레코드 검색 시 큰 이점을 제공
	•	단점: 인덱스를 업데이트해야 하므로 DB 수정 시 오버헤드 발생
	•	파일이 수정될 때, 해당 파일의 모든 인덱스도 수정 필요
	•	기본 인덱스를 이용한 순차 스캔은 효율적
	•	그러나 보조 인덱스를 이용한 순차 스캔은 비효율적
	•	각 레코드 접근 시 디스크에서 블록을 새로 불러올 수 있음
	•	디스크 접근 시간: 약 5~10밀리초, 메모리 접근 시간: 약 100나노초

⸻
다음은 B+ 트리 인덱스 파일에 대한 텍스트의 한국어 번역입니다:

⸻

B+ 트리 인덱스 파일

B+ 트리는 인덱스 순차 파일(indexed-sequential files)의 대안입니다.

인덱스 순차 파일의 단점:
	•	파일이 커질수록 성능이 저하됩니다. 이는 많은 오버플로 블록이 생성되기 때문입니다.
	•	전체 파일을 주기적으로 재구성해야 합니다.

B+ 트리 인덱스 파일의 장점:
	•	삽입과 삭제가 발생하더라도 소규모의 국소적인 변경만으로 자동으로 스스로를 재구성합니다.
	•	성능을 유지하기 위해 전체 파일을 재구성할 필요가 없습니다.

B+ 트리의 (작은) 단점:
	•	삽입 및 삭제 시 추가적인 오버헤드와 공간 사용이 발생합니다.

그러나 B+ 트리의 장점은 단점을 상쇄하고도 남습니다.
	•	실제로 B+ 트리는 널리 사용됩니다.

⸻

왜 B+ 트리인가?

모든 관계형 데이터베이스 시스템은 B+ 트리를 지원합니다.
지원 DBMS 예:
	•	IBM DB2, Informix, MS SQL, Oracle, Sybase, SQLite, MySQL, PostgreSQL, Tibero 등

다른 인덱스 유형도 지원하지만, **가장 널리 사용되는 인덱스는 B+ 트리와 그 변형(B-트리, B*-트리 등)**입니다.

거의 모든 파일 시스템도 B+ 트리를 사용합니다.
예: NTFS, EXT4, ReiserFS, NSS, XFS, JFS, ReFS, BFS 등

⸻

B+ 트리의 정의

B+ 트리는 다음 조건을 만족하는 루트 트리입니다:
	•	루트에서 리프까지의 모든 경로의 길이는 동일합니다.
	•	루트나 리프가 아닌 각 노드는 최소 ⌈n/2⌉개에서 최대 n개의 자식 노드를 가집니다.
	•	리프 노드는 최소 ⌈(n–1)/2⌉개에서 최대 n–1개의 값을 가집니다.

특수한 경우:
	•	루트가 리프가 아닐 경우, 최소 2개의 자식을 가집니다.
	•	루트가 리프인 경우(트리에 다른 노드가 없을 때), 0개에서 n–1개 사이의 값을 가질 수 있습니다.

⸻

B+ 트리 노드 구조

일반적인 노드:
	•	Kᵢ는 검색 키 값입니다.
	•	Pᵢ는 자식 노드(비리프일 경우) 또는 레코드/레코드 버킷(리프일 경우)을 가리키는 포인터입니다.
	•	노드 내 검색 키들은 정렬되어 있음: K₁ < K₂ < K₃ < ... < Kₙ₋₁
(초기에는 중복 키는 없다고 가정)

⸻

리프 노드의 특성
	•	i = 1, 2, …, n–1에 대해, 포인터 Pᵢ는 검색 키 값 Kᵢ를 가진 파일 레코드를 가리킴
	•	리프 노드 Lᵢ, Lⱼ에서 i < j이면, Lᵢ의 키 값들은 Lⱼ의 키 값들보다 작거나 같음
	•	Pₙ은 다음 리프 노드를 가리킴 (검색 키 순서로)

⸻

비리프 노드의 특성
	•	비리프 노드는 리프 노드에 대한 다단계 희소 인덱스를 형성함
	•	포인터가 m개인 비리프 노드에서:
	•	P₁이 가리키는 서브트리의 모든 키는 K₁보다 작음
	•	2 ≤ i ≤ n–1인 경우, Pᵢ가 가리키는 서브트리의 키는 Kᵢ₋₁ 이상이고 Kᵢ 미만
	•	Pₙ이 가리키는 서브트리의 키는 Kₙ₋₁ 이상

⸻

B+ 트리 예시
	•	instructor 파일에 대한 B+ 트리 예 (n = 6)
	•	리프 노드는 3~5개의 값을 가짐 (⌈(n–1)/2⌉ = 3, n–1 = 5)
	•	루트를 제외한 비리프 노드는 3~6개의 자식 (⌈n/2⌉ = 3, n = 6)
	•	루트는 최소 2개의 자식을 가져야 함

⸻

B+ 트리에 대한 관찰
	•	노드 간 연결은 포인터로 이루어지므로, 논리적으로 가까운 블록이 물리적으로 가까울 필요는 없음
	•	비리프 노드는 리프에 대한 계층적 희소 인덱스를 형성함
	•	B+ 트리는 상대적으로 적은 수의 레벨을 가짐:
	•	루트 바로 아래 수준: 최소 2 × ⌈n/2⌉ 개의 값
	•	그다음 수준: 최소 2 × ⌈n/2⌉ × ⌈n/2⌉
	•	…
	•	K개의 검색 키가 있을 때, 트리의 높이는 최대 ⌈log⌈n/2⌉(K)⌉

→ 따라서 검색은 매우 효율적입니다.

→ 삽입 및 삭제도 로그 시간 내에 처리 가능

⸻

B+ 트리에서의 쿼리 처리

검색 키 값 V를 가진 레코드 찾기
	1.	C를 루트 노드로 설정
	2.	C가 리프 노드가 아닐 동안:
	•	V ≤ Kᵢ를 만족하는 가장 작은 i를 찾음
	•	해당 i가 없다면, 마지막 포인터 Pn으로 이동
	•	그렇지 않으면 V = Kᵢ이면 Pᵢ₊₁, 아니면 Pᵢ로 이동
	3.	리프 노드 도달 후, Kᵢ = V인 i가 있는지 확인
	•	있다면 Pᵢ가 해당 레코드를 가리킴
	•	없다면 해당 키를 가진 레코드는 없음

⸻

효율성 비교
	•	K개의 검색 키가 있을 때, 트리 높이는 최대 ⌈log⌈n/2⌉(K)⌉
	•	일반적으로 노드 하나는 디스크 블록 크기와 같고, 보통 4KB
	•	인덱스 항목 하나당 약 40바이트라고 하면, n ≈ 100

예:
	•	검색 키가 100만 개이고 n = 100이면,
	•	최대 log₅₀(1,000,000) ≈ 4개의 노드만 접근 필요

비교:
	•	균형 이진 트리로는 약 20개의 노드를 접근해야 함

→ 디스크 I/O가 필요한 노드 접근이 적기 때문에 큰 성능 차이 발생
→ 디스크 접근은 약 20ms, 메모리 접근은 약 100ns로 차이가 큼
다음은 요청하신 텍스트의 한글 번역입니다:

⸻

B+ 트리의 갱신: 삽입
	1.	검색 키 값이 들어갈 리프 노드를 찾습니다.
	2.	해당 키 값이 이미 리프 노드에 있다면:
	•	파일에 레코드를 추가합니다.
	•	필요하다면 버킷에 포인터를 추가합니다.
	3.	검색 키 값이 리프 노드에 없다면:
	•	메인 파일에 레코드를 추가하고, 필요 시 버킷을 생성합니다.
	•	리프 노드에 공간이 있으면 (키 값, 포인터) 쌍을 삽입합니다.
	•	공간이 없다면, 노드를 분할합니다 (다음 슬라이드에서 설명).

⸻

리프 노드 분할
	•	삽입될 키와 기존 키들을 정렬된 순서로 정리합니다.
	•	처음 ⌈n/2⌉개는 기존 노드에, 나머지는 새 노드에 저장합니다.
	•	새 노드를 p라고 하고, p의 최소 키 값을 k라고 합시다.
	•	k와 p를 부모 노드에 삽입합니다.
	•	부모 노드가 가득 찼다면 역시 분할하고 상위로 분할을 전파합니다.
	•	최악의 경우 루트 노드도 분할되어 트리의 높이가 1 증가합니다.

예: Brandt, Califieri, Crick가 있는 노드에 Adams를 삽입해 분할
→ Califieri와 새 노드 포인터를 부모에 삽입

⸻

비리프 노드 분할

(k, p)를 이미 가득 찬 내부 노드 N에 삽입할 때:
	1.	N을 n+1개의 포인터와 n개의 키를 수용할 수 있는 메모리 공간 M에 복사
	2.	(k, p)를 M에 삽입
	3.	M에서 P₁, K₁, ..., K⌈n/2⌉₋₁, P⌈n/2⌉를 다시 N으로 복사
	4.	나머지를 새 노드 N'에 복사
	5.	(K⌈n/2⌉, N')을 N의 부모에 삽입

⸻

삭제 전후 예시
	•	“Srinivasan” 삭제 전후: 삭제로 인해 리프 노드가 부족해 병합 발생
	•	“Singh”와 “Wu” 삭제: 리프 노드가 부족해 왼쪽 형제 노드로부터 “Kim”을 빌려옴
→ 부모 노드의 키 값 변경
	•	“Gold” 삭제 전후:
	•	“Gold”와 “Katz”가 있는 노드가 부족해 형제와 병합됨
	•	부모 노드도 부족해 형제와 병합됨
	•	부모 노드의 키가 아래로 내려옴
	•	루트 노드에 자식이 하나만 남으면, 루트는 삭제되고 해당 자식이 새 루트가 됨

⸻

B+ 트리의 갱신: 삭제
	1.	삭제할 레코드를 찾아 메인 파일 및 버킷(있다면)에서 제거
	2.	버킷이 없거나 비어 있다면, 리프 노드에서 (검색 키 값, 포인터) 제거
	3.	노드가 삭제로 인해 엔트리가 부족할 경우:
	•	형제 노드와 병합이 가능하면 병합:
	•	두 노드의 검색 키를 하나로 합쳐 왼쪽 노드에 저장하고, 오른쪽 노드 삭제
	•	삭제된 노드에 대한 포인터 (Kᵢ₋₁, Pᵢ)를 부모에서 제거 (재귀적 수행)
	4.	병합이 불가능한 경우:
	•	형제 노드와 엔트리를 재분배하여 둘 다 최소 엔트리를 유지
	•	부모 노드의 키 값을 업데이트
	•	삭제는 상위 노드로 연쇄될 수 있으며, 포인터 수가 ⌈n/2⌉ 이상인 노드에서 멈춤
	5.	루트 노드에 자식이 하나만 남으면 루트는 제거되고 자식이 새 루트가 됨

⸻

B+ 트리 파일 조직 (B+-Tree File Organization)
	•	인덱스 파일의 성능 저하 문제는 B+ 트리 인덱스로 해결
	•	데이터 파일의 성능 저하 문제는 B+ 트리 파일 조직으로 해결

특징:
	•	리프 노드는 포인터 대신 레코드 자체를 저장
	•	여전히 리프 노드는 절반 이상 차 있어야 함
	•	레코드가 포인터보다 크기 때문에, 리프 노드에 저장할 수 있는 수가 적음
	•	삽입/삭제는 인덱스의 처리 방식과 동일

⸻

B+ 트리 파일 조직 예시
	•	레코드는 포인터보다 크므로 공간 활용이 매우 중요
	•	공간 활용을 위해 분할/병합 시 형제 노드를 더 많이 포함하여 재분배 수행
	•	예: 가능한 한 분할/병합을 피하기 위해 2개의 형제를 재분배에 포함시키면,
각 노드는 최소 ⌊2n/3⌋ 엔트리 유지 가능

⸻

인덱싱의 기타 이슈

레코드 이동과 보조 인덱스 문제:
	•	레코드가 이동하면, 레코드 포인터를 저장하는 모든 보조 인덱스를 업데이트해야 함
	•	B+ 트리 파일 조직에서 노드 분할이 매우 비쌈

해결책:
	•	보조 인덱스에서 레코드 포인터 대신 기본 인덱스의 검색 키 사용
	•	레코드 위치 탐색 시 기본 인덱스를 한 번 더 탐색해야 함 → 쿼리 비용 증가
	•	기본 키가 유일하지 않다면 레코드 ID 추가 필요

⸻

B-트리 인덱스 파일
	•	B+ 트리와 유사하나, 검색 키 값을 한 번만 저장해 중복 제거
	•	비리프 노드의 키 값은 트리 내에서 한 번만 등장, 각 키에 대해 추가 포인터 필드 필요

예시:
	•	일반적인 B-트리 리프 노드와 비리프 노드 구조

⸻

B-트리 인덱스 예

같은 데이터를 사용한 B-트리(위)와 B+ 트리(아래)

⸻

B-트리의 장점:
	•	B+ 트리에 비해 트리 노드 수가 적을 수 있음
	•	리프에 도달하기 전에 키 값을 찾을 수 있는 경우 있음

B-트리의 단점:
	•	검색 키 중 일부만 일찍 발견 가능
	•	비리프 노드가 커서 **팬 아웃(fan-out)**이 작아짐 → 트리 깊이 증가
	•	삽입/삭제 알고리즘이 더 복잡, 구현 난이도 높음

→ B-트리의 장점은 단점을 상쇄하지 못하는 경우가 대부분

⸻

다중 키 접근 (Multiple-Key Access)

복합 쿼리 처리 시 여러 인덱스를 사용할 수 있음

예:

select ID from instructor
where dept_name = "Finance" and salary = 80000

가능한 전략:
	1.	dept_name 인덱스로 “Finance” 교수 찾고, salary 조건 검사
	2.	salary 인덱스로 $80,000 교수 찾고, dept_name 조건 검사
	3.	두 인덱스를 각각 사용하여 포인터 집합을 얻고, 교집합 계산

⸻

다중 속성 인덱스 (Composite Search Keys)
	•	복합 검색 키는 둘 이상의 속성을 포함한 키
예: (dept_name, salary)

사전식 순서(Lexicographic ordering):
	•	(a₁, a₂) < (b₁, b₂)
→ a₁ < b₁ 또는 a₁ = b₁이고 a₂ < b₂

⸻

복합 속성 인덱스 활용

예: (dept_name, salary)에 대한 인덱스 존재 시

where dept_name = "Finance" and salary = 80000

→ 인덱스를 사용하여 두 조건을 모두 만족하는 레코드만 검색 가능

단일 속성 인덱스 사용 시 문제점:
	•	조건 하나만 만족하는 레코드를 많이 가져오게 되어 비효율적

다음 조건도 효율적으로 처리 가능:

where dept_name = "Finance" and salary < 80000

하지만 다음 조건은 비효율적:

where dept_name < "Finance" and balance = 80000

→ 첫 조건은 만족해도 두 번째는 아닐 수 있는 레코드를 많이 가져오게 됨

⸻

필요하시면 특정 부분에 대해 더 자세히 설명하거나 그림을 추가해 드릴 수 있습니다.