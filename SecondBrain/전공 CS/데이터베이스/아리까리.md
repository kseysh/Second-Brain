###### 스키마의 뜻과 스키마의 종류
- *데이터 베이스의 논리적 구조*
- physical schema
	- physical level에서의 schema
- logical schema
	- logical level에서의 schema
###### Theta Join을 다르게 표현
![[Pasted image 20250318142719.png|300]]
###### ID 10101을 가진 강사가 가르친 과정 섹션을 수강한 학생을 중복을 제외한 총 수 찾기 (nested subquery 이용)
```sql
select count (distinct ID)
from takes
where (course_id, sec_id, semester, year) in // 4개가 다 pk라 4개 다 써줘야 함 (중요)
	(select course_id, sec_id, semester, year
	from teaches
	where teaches.ID= 10101);
```
###### 급여가 강사의 평균 급여보다 적은 모든 강사를 삭제
```sql
DELETE FROM instructor
WHERE ID IN (
        SELECT ID
        FROM instructor
        WHERE salary < (
            SELECT AVG(salary)
            FROM instructor
		)
);
```
###### insert 문
```sql
insert into course
values ('CS-437', 'Database Systems', 'Comp. Sci.', 4);
```
value x values O
```sql
insert into course (course_id, title, dept_name, credits)
values ('CS-437', 'Database Systems', 'Comp. Sci.', 4);
```
###### 모든 instructor를 student 테이블로 옮기되, tot_creds(총 이수 학점)는 0으로 설정
```sql
insert into student
	select ID, name, dept_name, 0
	from instructor
```
###### 급여가 $100,000 이상인 강사의 급여를 3% 인상하고, 다른 모든 강사는 5% 인상을 받기 (case 사용)
```sql
update instructor
set salary = salary * 1.03
where salary > 100000;
---
update instructor
set salary = salary * 1.05
where salary <= 100000;
```

```sql
update instructor
set salary = case
	when salary <= 100000 then salary * 1.05
	else salary * 1.03
	end
```
case when then else end
###### 각 학생의 tot_cred를, F학점이 아니고 NULL이 아닌 성적을 받은 과목들의 총 학점 합으로 업데이트
```sql
update student S
set tot_cred = ( select sum(credits)
	from takes natural join course
	where S.ID= takes.ID and
		takes.grade <> ’F’ and
		takes.grade is not null);
```
표준 SQL에서는 <>가 공식적인 같지 않음 연산자임

###### 위 문제에서 sum(credit)이 null인 학생들은 tot_creds를 0으로 설정
```sql
update student S
set tot_cred = ( select case
							when sum(credits) is not null then sum(credits)
							else 0
						end
	from takes natural join course
	where S.ID= takes.ID and
		takes.grade <> ’F’ and
		takes.grade is not null);
```
###### views
모든 사용자가 전체 논리 모델을 보는 것이 바람직하지 않은 경우에 사용
특정 사용자에게 특정 데이터를 숨기기 위한 메커니즘 제공
개념적 모델에는 없지만 사용자에게 가상 릴레이션으로 보이는 릴레이션
```sql
create view v as <쿼리 표현식>
```
###### 2009년 가을 학기에 열렸던 물리학과(Physics)의 모든 강의에 대해 course_id, sec_id, building, room_number를 모아 physics_fall_2009라는 뷰(view)를 생성, 
```sql
create view physics_fall_2009 as  
select course.course_id, sec_id, building, room_number  
from course, section  
where course.course_id = section.course_id  
	and course.dept_name = 'Physics'  
	and section.semester = 'Fall'  
	and section.year = 2009;
```
##### 아래 코드의 문제
```sql
create view instructor_info as
select ID, name, building
from instructor, department
where instructor.dept_name = department.dept_name;
```
위 뷰에 아래처럼 insert를 시도하면,
```sql
insert into instructor_info values ('69987', 'White', 'Taylor');
```
###### A
Taylor 건물에 여러 개의 학과가 있다면 어떤 학과로 지정해야 할지 모르며,
Taylor 건물에 어떤 학과도 없다면 삽입이 불가능한 문제가 발생한다.
###### 일반적으로 SQL view가 updatable하다고 판단되는 경우
- **from 절에 하나의 relation만 포함**되어 있을 때
- **select절에 relation의 속성 이름만 포함**되어 있고, 표현식, 집계 함수, distinct등이 포함되어 있지 않을 때
- select 절에 포함되지 않은 속성이 nullable할 때
- **group by나 having 절**이 쿼리에 포함되어 있지 않을 때
###### spouse 컬럼이 person 테이블을 참조하는 외래 키 제약 조건 정의
```sql
constraint spouse_ref foreign key (spouse) references person
```
###### spouse_ref 제약 조건을 지연 모드(deferred)로 설정
```sql
set constraints spouse_ref deferred;
```
###### index 생성
`create index id_idx on student(id)`
###### BCNF 정규형이란?
BCNF(Boyce-Codd Normal Form)는 모든 결정자가 후보키인 정규형
###### BCNF 정규형 조건
릴레이션 스키마 R이 함수적 종속성 집합 F에 대해 BCNF에 속한다는 것은, F⁺에 속하는 모든 함수적 종속성 α → β에 대해 다음 조건 중 하나 이상을 만족하는 경우를 말한다:
•	α ⊆ R, β ⊆ R이고,
1.	α → β가 자명하다 (즉, β ⊆ α)
2.	α가 **R에 대한** 슈퍼키이다
###### trivial 하다
종속되는 속성이 결정자에 포함되어 있는 경우
###### 3NF란?
 모든 함수적 종속성에서 결정자가 후보키이거나, 종속자가 후보키에 속하는 속성인 정규형
 (결정자 -> 종속자)
###### 3NF 조건
릴레이션 스키마 R이 제3정규형에 속하려면,
F⁺에 속하는 모든 함수적 종속성 α → β에 대해 다음 조건 중 하나 이상을 만족해야 한다:
	1.	α → β가 자명하다 (즉, β ⊆ α)
	2.	α가 R의 super key이다
	3.	**β − α에 속한** 각 속성 A(종속자)는 R의 어떤candidate key에 포함되어야 한다 (BCNF와 달리 추가된 조건)

## ㅇㄹㄲㄹ

모호할 수 있는 값 꼭 확인하기

```sql
create table course (
  ...
  dept_name varchar(20),
  foreign key (dept_name) references department
    on delete cascade
    on update cascade,
  ...
);
```
references임

count 사용시 distinct