###### 인접 행렬, 인접 리스트 공간 복잡도
O(n<sup>2</sup>)
O(n + m)
###### DFS Tree 만드는 법
시작 정점을 루트로 하고, dfs를 이용해 방문한 경로를 이으면 DFS Tree가 된다
###### Tree edge란?
vw가 탐색될 때, w가 미발견된 정점이었다면 tree edge
###### back edge란?
w가 v의 조상이면, vw가 back edge (자손에서 ancestor 방향의 edge)
###### forward edge란?
descendant edge로도 불리며, ancestor -> descendant 방향의 edge
###### cross edge
descendant, back도 아닌 나머지 edge
###### Strongly Connected Components란
방향 그래프 G의 최대 강하게 연결된 부분 그래프
###### spanning tree란?
연결된 undirected graph G=(V,E)에 대해 G의 모든 정점을 포함하는 subgraph
###### prim algorithm 수행 중 정점들의 범주
•	트리 정점(Tree vertices): 지금까지 구성된 트리에 포함된 정점들,
•	경계 정점(Fringe vertices): 트리에 속하지는 않지만 트리 내 어떤 정점과 인접한 정점들,
•	미탐색 정점(Unseen vertices): 그 외의 모든 정점들.
###### prim 시간 복잡도 분석
![[Pasted image 20250530173638.png|500]]
프림 알고리즘은 우선 순위 큐에서 가장 작은 정점을 찾고, 삭제하는 과정을 n번 반복한다.
또한 새로운 후보 정점들을 n번 삽입하므로 삽입과정도 n번 반복한다.
후보 정점이 이미 큐에 있고, 기존보다 작은 비용으로 연결된다면 key값을 감소시켜야 하는데, 이 과정은 최대 m번 일어날 수 있다.
이 때 가장 작은 정점을 찾는 연산이 (  )이고, 삭제하는 연산이 (  )이고, 삽입 연산이 (  )이고, key 값을 감소시키는 연산이 (  )이므로 총 연산은 (  )이다.

프림 알고리즘의 시간 복잡도 T(n, m) = O(n x (T(getMin) + T(deleteMin) + T(insert)) + m x T(decreaseKey))이므로
###### kruskal algorithm 과정
1. 모든 edge의 집합을 오름차순으로 정렬
2. R에서 가장 가중치가 작은 간선을 꺼낸다
3. 간선 vw를 추가했을 때 cycle이 생기지 않는다면 F에 추가
4. n-1개의 간선이 포함되면 종료한다.
###### 최단 경로의 성질
- 가중치 그래프 G에서 x에서 z로 가는 최단 경로가 x에서 y까지의 경로 P와 y에서 z까지의 경로 Q로 구성되어 있다면,
- P는 x에서 y까지의 최단 경로이고 Q는 y에서 z까지의 최단 경로이다.
###### dijkstra algorithm의 특징
가중치가 양수인 그래프에서 사용
항상 현재까지 거리 합이 최소인 경로를 확정해나감
###### dijkstra algorithm 과정
1. 모든 정점을 unseen으로 초기화
2. 시작 정점 s를 tree로 지정하고, d(s, s) = 0
3. s와 인접한 정점들을 fringe로 재분류
4. while (fringe 정점이 존재하는 동안)
	1. tree 정점 t와 fringe 정점 v 간의 edge 중 (d(s, t) + W(tv)값이 최소인 (t, v)선택)
	2. v를 tree로 재분류, edge (t, v)를 트리에 추가
	3. v와 인접한 unseen 정점들을 fringe로 재분류
###### dijkstra algorithm Correctness 증명
Dijkstra 알고리즘에서 확정된 정점 집합에서 최단 경로를 따라 새로운 정점으로 확장할 때, d(s, y) + W(yz)가 최소인 간선을 선택하면 s -> y -> z 경로가 항상 최단 경로가 됨을 보장한다. 이는 모든 간선 가중치가 0 이상이기 때문에 이미 확정된 정점까지의 거리는 최단 거리이며, 더 짧은 경로가 존재한다면 선택된 간선이 최소가 아니라는 모순이 발생하므로, 알고리즘의 선택이 올바름을 증명
###### dijkstra algorithm 시간 복잡도
insert or decrease key: 우선 순위 큐를 사용하므로 연산당 비용 O(log n), 간선 수만큼 반복
가장 가까운 정점 꺼내기: 우선 순위 큐를 사용하므로 연산당 비용 O(log n), 정점 수만큼 반복
	따라서 Dijkstra 알고리즘 시간 복잡도 O((n + m)log n) = O(mlogn)
###### Transitive Closure란?
방향 그래프 G가 주어졌을 때, G와 동일한 정점을 갖는다.
•	G에 정점 u에서 v로 가는 경로가 존재한다면 (단, u ≠ v), G\*에는 u에서 v로 가는 간선이 존재한다.
![[Pasted image 20250521165334.png|100]]
###### 각 정점에서 DFS를 수행함으로써 Transitive Closure를 계산할 때의 시간 복잡도
O(n(n + m))이다.
###### Floyd-Warshall을 이용한 모든 정점 쌍 간 최단 거리 구하는 시간
O(n<sup>3</sup>) (예: 인접 행렬 사용 시)
###### 행렬 곱셈시 계산 식
`m[i,j]` = min { `m[i,k]` + `m[k+1,j]` + p<sub>i-1</sub>•p<sub>k</sub>•p<sub>j</sub> } (i ≤ k < j)
###### brute-force algorithm의 패턴 매칭 시간 복잡도
O(nm)
###### brute force 패턴 매칭 최악의 경우, 시간 복잡도
•	T = aaa…ah
•	P = aaah
 O(nm)
###### kmp 시간 복잡도 계산
- 패턴 P의 길이를 m이라 할 때, 각 문자에 대해 최대 한 번씩만 비교하거나 실패 함수 값을 따라 이동(j 감소)하기 때문에 O(m) 시간에 계산된다.
O(m + n)
실패 함수 계산: 패턴 P의 길이를 m이라 할 때, 각 문자에 대해 최대 한 번씩만 비교하거나 실패 함수 값을 따라 이동(j 감소)하기 때문에 최대 2m번의 루프 반복으로 계산되어 O(m)의 시간 복잡도를 가진다.
문자열 매칭: - 텍스트 T의 길이를 n이라 할 때, 각 문자를 최대 한 번씩만 비교하거나 실패 함수 값을 따라 이동하며 건너뛰므로 O(n) 시간이 걸린다.
따라서, 전체 KMP 알고리즘의 시간 복잡도는 O(m + n)으로, 텍스트와 패턴의 길이에 비례하는 선형 시간 내에 동작한다.
###### Boyer-Moore 휴리스틱 두 가지
1.	거울 휴리스틱(looking-glass heuristic): P와 T의 일부분을 오른쪽에서 왼쪽으로 비교
2.	문자 점프 휴리스틱(character-jump heuristic): `T[i]` = c에서 불일치 발생 시
	•	P에 c가 있다면, P 내 c의 가장 마지막 위치에 맞춰 이동
	•	없다면, `P[0]`을 `T[i+1]`과 맞춰 이동
###### 최종 발생 함수란?
P 내에서 문자 σ가 가장 마지막으로 등장하는 위치를 알아내는 함수
###### 최종 발생 함수의 시간 복잡도
O(m + s)
(m: P의 길이, s: Σ의 크기)
###### Boyer-Moore 알고리즘 최악의 경우 시간복잡도 분석, 예시
Boyer-Moore 알고리즘은 최악의 경우 O(nm + s) 시간에 동작한다.
s: 알파벳의 개수
nm이 나오는 경우 최악의 예시:
	•	T = aaa…a
	•	P = baaa

길이가 n인 텍스트를 비교할 때, 불일치가 자주 발생하면서 한 칸씩 밖에 이동하지 못하게 되면 각 위치마다 패턴의 크기인 최대 m번까지 비교가 일어나 시간 복잡도는 O(m·n)이고, 최종 발생 함수의 시간 복잡도가 O(m + s)이므로 O(m·n + s)이다.
###### 해밀턴 사이클 문제란?
그래프 G가 있을 때, 모든 정점을 정확히 한 번씩 방문하는 순환 경로가 존재하는가? 해결법
Hamiltonian-Cycle 문제: VERTEX-COVER로부터 환원
###### 외판원 순회 문제란?
완전 가중 그래프 G가 주어졌을 때, 총 비용이 K 이하인 전체 정점을 순회하는 경로가 존재하는가?
외판원 순회 문제 (Traveling Salesperson Tour) : Hamiltonian-Cycle로부터 환원