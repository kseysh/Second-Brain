###### 인접 행렬, 인접 리스트 공간 복잡도
O(n<sup>2</sup>)
O(n + m)
###### 어떤 그래프 G의 정점들과 간선의 일부만을 포함하여 만든 그래프
부분 그래프
###### 모든 정점 쌍 사이에 간선이 존재하는 그래프
완전 그래프
###### 두 정점이 간선으로 직접 연결되어 있는 관계
인접 관계
###### 한 정점에서 다른 정점까지 정점과 간선의 연결
경로
###### 정점이 중복 없이 등장하는 경로
단순 경로
###### 정점 u에서 v까지 경로가 존재하면 u는 v로 부터 도달 가능
도달 가능성
###### 무방향 그래프에서 정점 쌍 사이에 경로 존재
연결됨 (Connected)
###### 강하게 연결됨 (Strongly Connected)
directed graph에서 u, v에서 u->v, v->u가 모두 존재
###### 시작 정점과 끝 정점이 같은 경우
cycle
###### 중복된 정점 없이(시작/끝 제외) 순환 
simple cycle
###### 사이클이 없는 그래프
Acyclic
###### 사이클이 없는 무방향 그래프
undirected forest
###### 연결되어 있고 사이클이 없는 무방향 그래프
Free tree, undirected tree
###### 무방향 그래프에서 서로 도달 가능한 정점들만으로 구성된 최대 부분 그래프
연결 성분 (Connected component)
###### root가 있는 free tree
rooted tree
###### DFS Tree 만드는 법
시작 정점을 루트로 하고, dfs를 이용해 방문한 경로를 이으면 DFS Tree가 된다
###### Tree edge란?
vw가 탐색될 때, w가 미발견된 정점이었다면 tree edge
###### back edge란?
w가 v의 조상이면, vw가 back edge (자손에서 ancestor 방향의 edge)
###### forward edge란?
descendant edge로도 불리며, ancestor -> descendant 방향의 edge
###### cross edge
descendant, back도 아닌 나머지 edge
###### Strongly Connected Components란
방향 그래프 G의 최대 강하게 연결된 부분 그래프
###### greedy algorithm
일련의 선택을 할 때 각각의 선택이 제한된 “단기” 기준에서 최선이 되도록 한다.
###### greedy algorithm 단점
작은 단기 비용의 선택이 장기적으로 큰 비용이 불가피한 상황으로 이어질 수 있다.
###### spanning tree란?
연결된 undirected graph G=(V,E)에 대해 G의 모든 정점을 포함하는 subgraph
###### prim algorithm 수행 중 정점들의 범주
•	트리 정점(Tree vertices): 지금까지 구성된 트리에 포함된 정점들,
•	경계 정점(Fringe vertices): 트리에 속하지는 않지만 트리 내 어떤 정점과 인접한 정점들,
•	미탐색 정점(Unseen vertices): 그 외의 모든 정점들.
###### kruskal algorithm 과정
1. 모든 edge의 집합을 오름차순으로 정렬
2. R에서 가장 가중치가 작은 간선을 꺼낸다
3. 간선 vw를 추가했을 때 cycle이 생기지 않는다면 F에 추가
4. n-1개의 간선이 포함되면 종료한다.
###### 최단 경로의 성질
- 가중치 그래프 G에서 x에서 z로 가는 최단 경로가 x에서 y까지의 경로 P와 y에서 z까지의 경로 Q로 구성되어 있다면,
- P는 x에서 y까지의 최단 경로이고 Q는 y에서 z까지의 최단 경로이다.
###### dijkstra algorithm의 특징
가중치가 양수인 그래프에서 사용
항상 현재까지 거리 합이 최소인 경로를 확정해나감
###### dijkstra algorithm 과정
1. 모든 정점을 unseen으로 초기화
2. 시작 정점 s를 tree로 지정하고, d(s, s) = 0
3. s와 인접한 정점들을 fringe로 재분류
4. while (fringe 정점이 존재하는 동안)
	1. tree 정점 t와 fringe 정점 v 간의 edge 중 (d(s, t) + W(tv)값이 최소인 (t, v)선택)
	2. v를 tree로 재분류, edge (t, v)를 트리에 추가
	3. v와 인접한 unseen 정점들을 fringe로 재분류
###### dijkstra algorithm Correctness 증명
Dijkstra 알고리즘에서 확정된 정점 집합에서 최단 경로를 따라 새로운 정점으로 확장할 때, d(s, y) + W(yz)가 최소인 간선을 선택하면 s -> y -> z 경로가 항상 최단 경로가 됨을 보장한다. 이는 모든 간선 가중치가 0 이상이기 때문에 이미 확정된 정점까지의 거리는 최단 거리이며, 더 짧은 경로가 존재한다면 선택된 간선이 최소가 아니라는 모순이 발생하므로, 알고리즘의 선택이 올바름을 증명
###### Transitive Closure란?
방향 그래프 G가 주어졌을 때, G와 동일한 정점을 갖는다.
•	G에 정점 u에서 v로 가는 경로가 존재한다면 (단, u ≠ v), G\*에는 u에서 v로 가는 간선이 존재한다.
![[Pasted image 20250521165334.png|100]]
###### 각 정점에서 DFS를 수행함으로써 Transitive Closure를 계산할 때의 시간 복잡도
O(n(n + m))이다.
###### Floyd-Warshall algorithm 실행 시간
O(n<sup>3</sup>) (예: 인접 행렬 사용 시)
###### brute-force algorithm의 패턴 매칭 시간 복잡도
O(nm)
###### brute force 패턴 매칭 최악의 경우, 시간 복잡도
•	T = aaa…ah
•	P = aaah
 O(nm)
###### kmp 시간 복잡도 계산
- 패턴 P의 길이를 m이라 할 때, 각 문자에 대해 최대 한 번씩만 비교하거나 실패 함수 값을 따라 이동(j 감소)하기 때문에 O(m) 시간에 계산된다.
O(m + n)
실패 함수 계산: 패턴 P의 길이를 m이라 할 때, 각 문자에 대해 최대 한 번씩만 비교하거나 실패 함수 값을 따라 이동(j 감소)하기 때문에 최대 2m번의 루프 반복으로 계산되어 O(m)의 시간 복잡도를 가진다.
문자열 매칭: - 텍스트 T의 길이를 n이라 할 때, 각 문자를 최대 한 번씩만 비교하거나 실패 함수 값을 따라 이동하며 건너뛰므로 O(n) 시간이 걸린다.
따라서, 전체 KMP 알고리즘의 시간 복잡도는 O(m + n)으로, 텍스트와 패턴의 길이에 비례하는 선형 시간 내에 동작한다.
###### Boyer-Moore 휴리스틱 두 가지
1.	거울 휴리스틱(looking-glass heuristic): P와 T의 일부분을 오른쪽에서 왼쪽으로 비교
2.	문자 점프 휴리스틱(character-jump heuristic): `T[i]` = c에서 불일치 발생 시
	•	P에 c가 있다면, P 내 c의 가장 마지막 위치에 맞춰 이동
	•	없다면, `P[0]`을 `T[i+1]`과 맞춰 이동
###### 최종 발생 함수란?
P 내에서 문자 σ가 가장 마지막으로 등장하는 위치를 알아내는 함수
###### 최종 발생 함수의 시간 복잡도
O(m + s)
(m: P의 길이, s: Σ의 크기)
###### Boyer-Moore 알고리즘 최악의 경우 시간복잡도 분석, 예시
Boyer-Moore 알고리즘은 최악의 경우 O(nm + s) 시간에 동작한다.
s: 알파벳의 개수
nm이 나오는 경우 최악의 예시:
	•	T = aaa…a
	•	P = baaa

길이가 n인 텍스트를 비교할 때, 불일치가 자주 발생하면서 한 칸씩 밖에 이동하지 못하게 되면 각 위치마다 패턴의 크기인 최대 m번까지 비교가 일어나 시간 복잡도는 O(m·n)이고, 최종 발생 함수의 시간 복잡도가 O(m + s)이므로 O(m·n + s)이다.
###### 다항 시간 알고리즘이란?
어떤 알고리즘이 T(n) = O(n<sup>k</sup>) (단, k는 상수)라면 다항 시간 알고리즘이라 부름
###### 클래스 P란?
- 어떤 문제에 대해 다항 시간 알고리즘이 존재하면 그 문제는 클래스 P에 속한다고 말함
	- 즉, 그 문제의 해를 다항 시간 안에 구할 수 있음
###### 클래스 NP란?
- 어떤 문제에 대해 비결정론적 다항 시간 알고리즘이 존재한다면, 그 문제는 클래스 NP에 속함
	- 즉, 해가 주어졌을 때 그 해가 맞는지 다항 시간 안에 검증할 수 있음
- 따라서 클래스 P에 속하는 문제는 항상 NP에도 속함 (해를 구할 수 있다면 당연히 검증도 가능)
	- 즉, P는 NP의 부분집합
###### 어떤 그래프가 가중치 K 이하의 최소 신장 트리를 가지는가에 대한 검증
- 검증 알고리즘:
	1.	증명으로서 n-1개의 간선 집합 T를 제시
	2.	T가 스패닝 트리인지 확인
	3.	T의 가중치가 K 이하인지 확인
- 분석: 검증은 O(n+m) 시간 안에 가능하므로 다항 시간에 수행됨
###### NP-hard, NP-complete
- 문제 Q가 NP-hard라면, 모든 NP 문제들을 다항 시간 안에 Q로 변환(reduce)할 수 있다
- 문제 Q가 NP-complete란, Q가 NP에 속하면서 동시에 NP-hard임을 의미
###### Polynomial Reduction이란?
어떤 문제 P를 다항 시간에 문제 Q로 변환할 수 있다면, Q를 푸는 알고리즘을 이용해서 P도 풀 수 있다
###### 최초의 NP-완전 문제
CIRCUIT-SAT 문제
###### m개의 집합이 주어질 때, 이들 중 K개의 집합의 합집합이 전체 m개의 집합과 동일한가? 해결법
SET-COVER문제: VERTEX-COVER 문제로부터의 환원으로 NP-완전
###### 정수 집합과 정수 K가 주어졌을 때, 합이 K가 되는 부분집합이 존재하는가? 해결법
SUBSET-SUM 문제: VERTEX-COVER로부터의 환원으로 NP-완전
###### 무게와 이익이 있는 아이템들이 주어졌을 때, 무게의 합이 W 이하이고 이익의 합이 K 이상인 부분집합이 존재하는가? 해결법
0/1 배낭 문제: SUBSET-SUM으로부터 환원
###### 그래프 G가 있을 때, 모든 정점을 정확히 한 번씩 방문하는 순환 경로가 존재하는가? 해결법
Hamiltonian-Cycle 문제: VERTEX-COVER로부터 환원
###### 완전 가중 그래프 G가 주어졌을 때, 총 비용이 K 이하인 전체 정점을 순회하는 경로가 존재하는가?
외판원 순회 문제 (Traveling Salesperson Tour) : Hamiltonian-Cycle로부터 환원
###### 논리식 S가 주어졌을 때, 0과 1을 변수에 적절히 할당하여 S를 참으로 만들 수 있는가?
SAT 문제: 0과 1의 할당을 비결정론적으로 선택 후 각 절을 검사 모든 절이 참이면 전체 식도 참이므로 CNF-SAT이 NP에 속함은 자명하다, 또한 SAT은 CIRCUIT-SAT으로 부터 환원되어 NP-complete이다.
###### 3SAT
SAT으로 부터 환원되어 NP-complete
######  그래프 G와 정수 K가 주어졌을 때, 크기가 K 이하인 Vertex Cover가 존재하는가?
크기 K의 W를 비결정론적으로 선택 후 모든 간선이 W에 의해 커버되는지 확인할 수 있으므로 NP에 속하고, VERTEX-COVER는 3SAT로부터의 환원으로 NP-complete이다.
###### 동적 계획법 알고리즘 개발 단계
1.	최적 해의 구조를 파악한다.
2.	최적 해의 값을 재귀적으로 정의한다.
3.	최적 해의 값을 Bottom-up 방식으로 계산한다.
4.	계산된 정보를 바탕으로 최적 해를 구성한다.
###### prim 시간 복잡도 분석
![[Pasted image 20250530173638.png|500]]
프림 알고리즘은 우선 순위 큐에서 가장 작은 정점을 찾고, 삭제하는 과정을 n번 반복한다.
또한 새로운 후보 정점들을 n번 삽입하므로 삽입과정도 n번 반복한다.
후보 정점이 이미 큐에 있고, 기존보다 작은 비용으로 연결된다면 key값을 감소시켜야 하는데, 이 과정은 최대 m번 일어날 수 있다.
이 때 가장 작은 정점을 찾는 연산이 (  )이고, 삭제하는 연산이 (  )이고, 삽입 연산이 (  )이고, key 값을 감소시키는 연산이 (  )이므로 총 연산은 (  )이다.
######  tree, unseen, fringe
tree: 현재까지 구성된 최소 신장 트리에 포함된 정점.
unseen: - 아직 최소 신장 트리(MST) 구축에 고려되지 않은 정점
fringe: 이미 tree에 포함된 정점들과 인접해 있고, 아직 tree에는 포함되지 않은 정점.
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
