###### Boyer-moore 무지성 암기
```
l <- L[T[i]]
i <- i + m - min(j, 1 + l)
j <- m - 1
```
###### 인접 행렬, 인접 리스트 공간 복잡도
O(n<sup>2</sup>)
O(n + m)
###### Tree edge란?
vw가 탐색될 때, w가 미발견된 정점이었다면 tree edge
###### back edge란?
w가 v의 조상이면, vw가 back edge (자손에서 ancestor 방향의 edge)
###### forward edge란?
descendant edge로도 불리며, ancestor -> descendant 방향의 edge
###### cross edge
descendant, back도 아닌 나머지 edge
###### prim algorithm 수행 중 정점들의 범주
•	트리 정점(Tree vertices): 지금까지 구성된 트리에 포함된 정점들,
•	경계 정점(Fringe vertices): 트리에 속하지는 않지만 트리 내 어떤 정점과 인접한 정점들,
•	미탐색 정점(Unseen vertices): 그 외의 모든 정점들.
###### prim 시간 복잡도
삽입, getMin, 삭제 n
key 값 감소 m
###### 최단 경로의 성질
- 가중치 그래프 G에서 x에서 z로 가는 최단 경로가 x에서 y까지의 경로 P와 y에서 z까지의 경로 Q로 구성되어 있다면,
- P는 x에서 y까지의 최단 경로이고 Q는 y에서 z까지의 최단 경로이다.
즉, 최단 경로끼리 이으면 최단 경로이다
###### dijkstra algorithm 시간 복잡도
insert or decrease key: 우선 순위 큐를 사용하므로 연산당 비용 O(log n), 간선 수만큼 반복
가장 가까운 정점 꺼내기: 우선 순위 큐를 사용하므로 연산당 비용 O(log n), 정점 수만큼 반복
	따라서 Dijkstra 알고리즘 시간 복잡도 O((n + m)log n) = O(mlogn)
###### 각 정점에서 DFS를 수행함으로써 Transitive Closure를 계산할 때의 시간 복잡도
O(n(n + m))이다.
dfs: 각 정점과 간선을 한 번씩 방문하므로 n + m
###### Floyd-Warshall을 이용한 모든 정점 쌍 간 최단 거리 구하는 시간
O(n<sup>3</sup>) (예: 인접 행렬 사용 시)
###### brute force 패턴 매칭 최악의 경우, 시간 복잡도
•	T = aaa…ah
•	P = aaah
 O(nm)
###### Boyer-Moore 휴리스틱 두 가지
1.	거울 휴리스틱(looking-glass heuristic): P와 T의 일부분을 오른쪽에서 왼쪽으로 비교
2.	문자 점프 휴리스틱(character-jump heuristic): `T[i]` = c에서 불일치 발생 시
	•	P에 c가 있다면, P 내 c의 가장 마지막 위치에 맞춰 이동
	•	없다면, `P[0]`을 `T[i+1]`과 맞춰 이동
###### 최종 발생 함수란?
P 내에서 문자 σ가 가장 마지막으로 등장하는 위치를 알아내는 함수
###### 최종 발생 함수의 시간 복잡도
O(m + s) 
(m: P의 길이, s: Σ의 크기)
O(s): s 초기화 시간
O(m): 패턴을 한 번 순회하며 업데이트
###### Boyer-Moore 알고리즘 최악의 경우 시간복잡도 분석, 예시
Boyer-Moore 알고리즘은 최악의 경우 O(nm + s) 시간에 동작한다.
s: 알파벳의 개수
nm이 나오는 경우 최악의 예시:
	•	T = aaa…a
	•	P = baaa

길이가 n인 텍스트를 비교할 때, 불일치가 자주 발생하면서 한 칸씩 밖에 이동하지 못하게 되면 각 위치마다 패턴의 크기인 최대 m번까지 비교가 일어나 시간 복잡도는 O(m·n)이고, 최종 발생 함수의 시간 복잡도가 O(m + s)이므로 O(m·n + s)이다.
###### 클래스 P에 속하려면
어떤 문제에 대해 다항 시간 알고리즘이 존재
#####

# 빡센 암기

## prim 시간 복잡도 분석
![[Pasted image 20250530173638.png|500]]
프림 알고리즘은 우선 순위 큐에서 새로운 후보 정점들을 n번 삽입하며, 가장 작은 정점을 찾고, 삭제하는 과정도 n번 반복한다.
후보 정점이 이미 큐에 있고, 기존보다 작은 비용으로 연결된다면 key값을 감소시켜야 하는데, 이 과정은 최대 m번 일어날 수 있다.
이 때 가장 작은 정점을 찾는 연산이 (  )이고, 삭제하는 연산이 (  )이고, 삽입 연산이 (  )이고, key 값을 감소시키는 연산이 (  )이므로 총 연산은 (  )이다.

프림 알고리즘의 시간 복잡도 T(n, m) = O(n x (T(getMin) + T(deleteMin) + T(insert)) + m x T(decreaseKey))이므로
삽입, getMin, 삭제 n
key 값 감소 m
## dijkstra algorithm Correctness 증명
Dijkstra 알고리즘에서 확정된 정점 집합에서 최단 경로를 따라 새로운 정점으로 확장할 때, d(s, y) + W(yz)가 최소인 간선을 선택하면 s -> y -> z 경로가 항상 최단 경로가 됨을 보장한다. 이는 *모든 간선 가중치가 0 이상이기 때문에 이미 확정된 정점까지의 거리는 최단 거리이며, 더 짧은 경로가 존재한다면 선택된 간선이 최소가 아니라는 모순이 발생*하므로, 알고리즘의 선택이 올바름을 증명
## kmp 시간 복잡도 계산
O(m + n)
실패 함수 계산: 패턴 P의 길이를 m이라 할 때, 각 문자에 대해 최대 한 번씩만 비교하거나 실패 함수 값을 따라 이동(j 감소)하기 때문에 최대 2m번의 루프 반복으로 계산되어 O(m)의 시간 복잡도를 가진다.

문자열 매칭: - 텍스트 T의 길이를 n이라 할 때, 각 문자를 최대 한 번씩만 비교하거나 실패 함수 값을 따라 이동하며 건너뛰므로 O(n) 시간이 걸린다.
따라서, 전체 KMP 알고리즘의 시간 복잡도는 O(m + n)으로, 텍스트와 패턴의 길이에 비례하는 선형 시간 내에 동작한다.
## TSP가 NP에 속하는가
후보해로 주어진 순회 경로가 각 정점을 정확히 한 번씩 포함하며, 시작점으로 되돌아오는 사이클인지, 총 비용이 K 이하인지는 단순한 루프와 배열 등을 통해 다항 시간 내에 검증 가능하므로 NP에 속한다.
## TSP는 NP-hard인가
**NP-complete를 무언가로 환원해야 함**
TSP가 NP-Hard임을 보이기 위해, 이미 NP-완전임이 알려진 Hamiltonian Cycle 문제로부터 다항 시간 환원을 수행한다. Hamiltonian Cycle 문제를 TSP 결정 문제로 환원하기 위해, 무가중치 그래프 G를 기반으로 한 완전 가중치 그래프 G′를 만든다.

G'에서 G에 존재하는 간선에는 가중치 1을 부여하고, 존재하지 않는 간선에는 가중치 ∞를 부여한다.
이후 TSP 결정 문제의 상한값 K를 |V|로 설정한다.

Hamiltonian Cycle이 존재하면 가중치 1의 간선만으로 구성된 순회가 존재하므로 비용은 정확히 |V|가 되고, TSP는 “yes”가 된다. 반대로 TSP가 “yes”라면 비용이 |V| 이하의 순회가 존재하므로, 이는 곧 Hamiltonian Cycle의 존재를 의미한다.

이러한 변환은 다항 시간에 수행 가능하므로, TSP는 NP-Hard임이 성립한다.
## 무향 해밀토니안 사이클이 NP에 속함
후보해로 주어진 정점 순열이 모든 정점을 정확히 한 번씩 포함하며, 인접한 정점 간에 간선이 존재하며, 시작점으로 되돌아오는 사이클인지는 단순한 루프와 배열 등을 통해 다항 시간 내에 검증 가능하므로 NP에 속한다.
## 무향 해밀토니안 사이클이 NP-Hard임을 증명
Q가 NP-Hard임을 보이기 위해, 유향 Hamiltonian-Cycle 결정 문제(P)를 무향 문제(Q)로 다항시간 환원한다.

•	유향 그래프 G를 기반으로 무향 그래프 G'를 구성한다.
•	G의 각 정점 v에 대해 G'의 정점에는 세 정점 v<sub>in</sub>, v, v<sub>out</sub>을 생성하고 세 정점들끼리 무향 간선으로 잇는다
•	유향 간선 (v → w)이 존재하면, 무향 간선 (v<sub>out</sub> - w<sub>in</sub>)을 G′에 추가한다.

타당성 증명:
- G에 유향 Hamiltonian Cycle C가 있다면, G′에도 대응되는 무향 Hamiltonian Cycle C'이 존재한다
	- G의 해밀토니안 사이클 C가 존재하면, G′에서 경로 C를 대응시키는 경로 C′를 구성할 수 있으며, C′는 모든 정점을 정확히 한 번씩 방문하며, 존재하는 간선만을 이용한 순회 경로가 된다. 따라서 G′는 무향 Hamiltonian Cycle을 가진다. *(G에서 C는 G'에서 C'으로 대응가능, C'은 조건을 만족하므로 가능)*
- G′에 무향 Hamiltonian Cycle C'이 있다면, G에도 대응되는 유향 Hamiltonian Cycle C가 존재한다
	- G′에서 v<sub>out</sub> 다음에 w<sub>in</sub>이 등장하면 이는 G에서 (v → w) 간선이 있었음을 의미하므로 경로가 존재한다.
	- 결국 C′는 v<sub>0in</sub> - v<sub>0</sub> - v<sub>0out</sub> ... - v<sub>kin</sub> - v<sub>k</sub> - v<sub>kout</sub> - v<sub>0in</sub>의 형태를 가지며, 
	  이는 G 상에서 v<sub>0</sub>  ... → v<sub>k</sub> → v<sub>0</sub>이라는 유향 해밀토니안 사이클이 존재함을 보장한다
	- *(vout->win은 v->w니까 G에서도 간선이 존재하므로 가능)*
이 변환은 다항 시간에 수행 가능하므로 유향 HC ≤p 무향 HC이고, 따라서 무향 HC 문제는 NP-Hard이다