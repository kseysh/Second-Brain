###### shiftVacRec 기능
정렬된 영역에 삽입할 위치를 찾고, 뒤로 민다.
###### QuickSort의 특징
분할 정복
randomized sorting algorithm
in-place 가능
###### partition 수도코드 p: pivot 위치, L, E, G
![[Pasted image 20250409153302.png|300]]
###### In-place Quick Sort S, l, r
![[Pasted image 20250328220218.png|300]]
###### mergeSort 의사 코드 (merge 포함) Element\[] E, int first, int last
![[Pasted image 20250331151445.png|200]]
###### merge 의사 코드 A, B, C
![[Pasted image 20250409155536.png|200]]
###### heapSort 의사코드 H, n
![[Pasted image 20250409163104.png|300]]
###### deleteMax 의사코드 H
![[Pasted image 20250409163116.png|300]]
###### fixHeap 의사코드 힙 H, key K
![[Pasted image 20250409163129.png|300]]
###### deleteMax 기능
힙에서 최댓값 삭제 후 fixHeap 호출로 힙 성질 복원
###### fixHeap 기능
힙 성질을 복구하는 함수, 루트 노드로 올라온 노드 K를 자기 자리로 찾게 하기
###### ConstructHeap(H) 수도 코드
![[Pasted image 20250410150557.png|300]]
###### Partial order tree property
트리의 어떤 노드든지 그 자식 노드들보다 값이 크거나 같아야 한다.
###### bubbleUpHeap(Element\[] E, int root, Element K, int vacant) 수도코드
![[Pasted image 20250410151648.png|300]]
###### fixHeapFast(Element\[] E, int n, Element K, int vacant, int h) 수도코드
![[Pasted image 20250410151854.png|300]]
###### promote(Element\[] E, int hS, int vacant, int h) 수도코드
![[Pasted image 20250410151907.png|300]]
###### fixHeapFast 기능
빈 자리에 새로운 요소 K를 삽입하면서 힙을 빠르게 재구성
###### promote 기능
힙 아래쪽에서 값을 위로 “승격”시켜서 vacant 자리를 채우기 위한 가장 적절한 노드를 찾아줌c
###### radixSort(List L, int radix, int numFields) 역할
![[Pasted image 20250410230942.png|400]]
###### distribute(List L, List\[] buckets, int radix, int field) 역할
리스트 L의 원소들을 주어진 field 기준으로 buckets에 분배
###### distribute(List L, List\[] buckets, int radix, int field) 수도코드
![[Pasted image 20250410230955.png|400]]
###### combine(List\[] buckets, int radix) 역할
분산된 buckets의 원소들을 다시 하나의 리스트로 병합합니다.
###### combine(List\[] buckets, int radix) 역할
![[Pasted image 20250410231005.png|400]]
###### Array Doubling 총 비용 분석
- (n+1)번째 요소 삽입이 배열 확장을 유발할 경우
	- 이 배열 확장 작업의 비용은 t * n
	- 이전 배열 확장들의 비용은 t * n/2 + t * n/4 + t * n/8 + ...로, 이는 t * n보다 작음
- 총 비용은 2t * n을 초과하지 않음
###### amortized cost 계산 식
amortized cost = actual cost + accounting cost
###### Amortzed Analysis란?
최악의 경우에 대해 **확률적 가정을 하지 않고** 평균 비용을 논하는 방법
###### 배열 확장이 있을 때, 배열 확장이 없을 때 push의 actual cost
•	배열 확장이 일어나지 않을 때, push나 pop의 실제 비용은 1
•	배열 확장이 필요한 경우, push의 실제 비용은 1 + t * n
		n: 현재 배열에 있는 원소 개수, t: 복사할 때 한 요소당 드는 비용
###### 회계 비용 할당 방식에서 배열 확장이 있을 때, 배열 확장이 없을 때 push의 Accounting cost
•	배열 확장이 없을 때 push의 Accounting cost는 2t로 설정
•	배열 확장이 있을 때 push의 Accounting cost는 –t * n + 2t로 설정
•	각 push 연산의 amortized cost은 1 + 2t
###### bstSearch(BinTree bst, Key K)의 수도코드
![[Pasted image 20250410155036.png|300]]
###### Red-Black Tree 정의
레드-블랙 트리는 다음의 성질들을 만족하는 이진 탐색 트리로 정의할 수 있다: (시)
•	루트 속성: 루트는 검정색이다.
•	외부 속성: 모든 리프 노드는 검정색이다.
•	내부 속성: 빨간 노드의 자식은 모두 검정색이다.
•	깊이 속성: *모든 리프 노드는 같은 검정색 깊이(black depth)를 가진다.*
###### insertItem(k, o) 수도 코드
![[Pasted image 20250410162823.png|200]]
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
