**비교 몇 번 일어났는지 F(x), L(x) 함수 만들기**
KMP 부분 보기
빈칸 안나올지..도?
패턴 매칭 알고리즘
	•	브루트포스(Brute-force) 알고리즘
	•	Knuth-Morris-Pratt 알고리즘
	•	Boyer-Moore 알고리즘
## 브루트포스 알고리즘 
브루트포스 패턴 매칭 알고리즘은,
텍스트 T에 대해 가능한 모든 위치에 패턴 P를 비교한다.
•	일치하는 경우: 종료
•	모든 위치를 시도한 경우: 종료
![[Pasted image 20250521174026.png|300]]
브루트포스 패턴 매칭은 시간 복잡도 O(nm)이다.
최악의 예시:
•	T = aaa…ah
•	P = aaah
이러면 최악의 경우 O(|A| x |B|)에 동작함
이미지나 DNA 서열에서는 흔히 발생하지만, 영문 텍스트에서는 드물다.
## KMP 알고리즘 - 동기
Knuth-Morris-Pratt 알고리즘은 왼쪽에서 오른쪽으로 비교하지만, 브루트포스보다 더 똑똑하게 패턴을 이동시킨다.
불일치가 발생했을 때, 중복 비교를 피하면서 패턴을 얼마나 많이 이동시킬 수 있을까?
→ 정답: `P[0..j]`의 가장 긴 접두사 중, `P[1..j]`의 접미사이기도 한 것
## KMP Algorithm - Idea
![[Pasted image 20250521174128.png|200]]
## KMP 실패 함수
![[Pasted image 20250521174155.png|200]]
KMP 알고리즘은 패턴의 접두사들이 패턴 내 다른 위치에서 일치하는지를 사전 처리한다.
실패 함수 F(j)는 `P[0..j]`의 접두사 중, `P[1..j]`의 접미사이기도 한 가장 긴 접두사의 길이이다.
KMP 알고리즘은 불일치 발생 시 `P[j]` ≠ `T[i]`이면 j ← F(j − 1)로 이동한다.

## KMP 알고리즘
![[Pasted image 20250521174245.png|200]]
KMP도 실패함수랑 똑같음
i: T idx
j: P idx
일치하면 i++, j++
j > 0 이면, j에 F\[j - 1] (이전까지 일치했던 접두사의 길이를 이용해 패턴을 되돌려 재비교하지 않고도 효율적으로 건너뛰기 위해 사용)
else, i++

실패 함수는 배열로 표현할 수 있고, O(m) 시간에 계산 가능하다.
while 루프의 각 반복에서
•	i는 1 증가하거나
•	i − j (이동량)는 최소 1 이상 증가한다. (F(j−1) < j 이므로)
따라서 while 루프는 최대 2n번 반복되며, KMP 알고리즘의 전체 시간 복잡도는 O(m + n)이다.
## 실패 함수 계산
![[Pasted image 20250521174317.png|200]]
i: 현재까지 확인한 idx
j: 현재까지 일치한 문자 수
일치하면, F\[i]에 j+1 넣고, i++, j++
j > 0 이면, j에 F\[j - 1] (이전까지 일치했던 접두사의 길이를 이용해 패턴을 되돌려 재비교하지 않고도 효율적으로 건너뛰기 위해 사용)
else, F\[i]에 0 넣고 i++

실패 함수는 배열로 표현되며, O(m) 시간에 계산된다.
구성 방식은 KMP 알고리즘과 유사하다.
while 루프의 각 반복에서
•	i는 1 증가하거나
•	i − j는 최소 1 이상 증가한다.
→ 최대 2m번의 루프 반복으로 계산됨.
#### Example
![[Pasted image 20250521174339.png|300]]
## Boyer-Moore 휴리스틱
Boyer-Moore 패턴 매칭 알고리즘은 두 가지 휴리스틱에 기반한다.
1.	거울 휴리스틱(looking-glass heuristic): P와 T의 일부분을 오른쪽에서 왼쪽으로 비교
2.	문자 점프 휴리스틱(character-jump heuristic): `T[i]` = c에서 불일치 발생 시
	•	P에 c가 있다면, P 내 c의 가장 마지막 위치에 맞춰 이동
	•	없다면, `P[0]`을 `T[i+1]`과 맞춰 이동
#### Example
![[Pasted image 20250521174430.png|400]]
## 최종 발생 함수 (Last-Occurrence Function)
Boyer-Moore 알고리즘은 패턴 P와 알파벳 Σ에 대해 최종 발생 함수 L(σ)를 만든다.
L(σ): P 내에서 문자 σ가 가장 마지막으로 등장하는 위치의 인덱스
	•	존재하지 않으면 −1로 설정
#### Example
특정한 글자의 마지막 위치를 알아내는 함수
패턴 내에서 char가 등장하지 않으면 -1 (한 번의 jump가 일어남)
![[Pasted image 20250521174517.png|300]]
최종 발생 함수는 문자의 코드값으로 인덱싱된 배열로 표현 가능하다.
시간 복잡도는 O(m + s) (m: P의 길이, s: Σ의 크기)
## The Boyer-Moore Algorithm
![[Pasted image 20250521174604.png|400]]
i와 j는 패턴을 기준으로 맨 뒤에서 시작함

#### Example
![[Pasted image 20250521175650.png|400]]
## 분석
![[Pasted image 20250521175707.png|300]]
Boyer-Moore 알고리즘은 최악의 경우 O(nm + s) 시간에 동작한다.
s: 알파벳의 개수
nm이 나오는 경우 최악의 예시:
	•	T = aaa…a
	•	P = baaa
이러한 경우는 이미지나 DNA 서열에서 발생할 수 있으나, 영문 텍스트에서는 드물다.
영문 텍스트에서는 Boyer-Moore 알고리즘이 브루트포스보다 훨씬 빠르다.