패턴 매칭 알고리즘
	•	브루트포스(Brute-force) 알고리즘
	•	Knuth-Morris-Pratt 알고리즘
	•	Boyer-Moore 알고리즘
## 문자열 
문자열은 문자들의 순서열이다.
문자열 예시:
•	C++ 프로그램
•	HTML 문서
•	DNA 서열
•	디지털 이미지

알파벳 Σ는 문자열 집합에서 사용 가능한 문자들의 집합이다.
알파벳 예시:
•	ASCII
•	{0, 1}
•	{A, C, G, T}

길이 m인 문자열 P가 있을 때,
•	부분 문자열 `P[i .. j]`는 i번부터 j번까지의 문자로 구성된 부분 시퀀스이다.
•	접두사(Prefix)는 `P[0 .. i]` 형태의 부분 문자열이다.
•	접미사(Suffix)는 `P[i .. m−1]` 형태의 부분 문자열이다.
문자열 T (텍스트)와 P (패턴)가 주어졌을 때, 패턴 매칭 문제란 T에서 P와 일치하는 부분 문자열을 찾는 것이다.

활용 분야:
•	텍스트 편집기
•	검색 엔진
•	생물학 연구
## 브루트포스 알고리즘 (1/3)
브루트포스 패턴 매칭 알고리즘은,
텍스트 T에 대해 가능한 모든 위치에 패턴 P를 비교한다.
•	일치하는 경우: 종료
•	모든 위치를 시도한 경우: 종료
![[Pasted image 20250521174026.png|300]]
브루트포스 패턴 매칭은 시간 복잡도 O(nm)이다.
최악의 예시:
•	T = aaa…ah
•	P = aaah
이미지나 DNA 서열에서는 흔히 발생하지만, 영문 텍스트에서는 드물다.
## KMP 알고리즘 - 동기
Knuth-Morris-Pratt 알고리즘은 왼쪽에서 오른쪽으로 비교하지만, 브루트포스보다 더 똑똑하게 패턴을 이동시킨다.
불일치가 발생했을 때, 중복 비교를 피하면서 패턴을 얼마나 많이 이동시킬 수 있을까?
→ 정답: `P[0..j]`의 가장 긴 접두사 중, `P[1..j]`의 접미사이기도 한 것
## KMP Algorithm - Idea
![[Pasted image 20250521174128.png|200]]
## KMP 실패 함수
![[Pasted image 20250521174155.png|200]]
KMP 알고리즘은 패턴의 접두사들이 패턴 내 다른 위치에서 일치하는지를 사전 처리한다.
실패 함수 F(j)는 `P[0..j]`의 접두사 중, `P[1..j]`의 접미사이기도 한 가장 긴 접두사의 길이이다.
KMP 알고리즘은 불일치 발생 시 `P[j]` ≠ `T[i]`이면 j ← F(j − 1)로 이동한다.
## KMP 알고리즘
![[Pasted image 20250521174245.png|200]]
실패 함수는 배열로 표현할 수 있고, O(m) 시간에 계산 가능하다.
while 루프의 각 반복에서
•	i는 1 증가하거나
•	i − j (이동량)는 최소 1 이상 증가한다. (F(j−1) < j 이므로)
따라서 while 루프는 최대 2n번 반복되며, KMP 알고리즘의 전체 시간 복잡도는 O(m + n)이다.
## 실패 함수 계산
![[Pasted image 20250521174317.png|200]]
실패 함수는 배열로 표현되며, O(m) 시간에 계산된다.
구성 방식은 KMP 알고리즘과 유사하다.
while 루프의 각 반복에서
•	i는 1 증가하거나
•	i − j는 최소 1 이상 증가한다.
→ 최대 2m번의 루프 반복으로 계산됨.
#### Example
![[Pasted image 20250521174339.png|300]]
## Boyer-Moore 휴리스틱
Boyer-Moore 패턴 매칭 알고리즘은 두 가지 휴리스틱에 기반한다.
1.	거울 휴리스틱(looking-glass heuristic): P와 T의 일부분을 오른쪽에서 왼쪽으로 비교
2.	문자 점프 휴리스틱(character-jump heuristic): `T[i]` = c에서 불일치 발생 시
	•	P에 c가 있다면, P 내 c의 가장 마지막 위치에 맞춰 이동
	•	없다면, `P[0]`을 `T[i+1]`과 맞춰 이동
#### Example
![[Pasted image 20250521174430.png|400]]
## 최종 발생 함수 (Last-Occurrence Function)
Boyer-Moore 알고리즘은 패턴 P와 알파벳 Σ에 대해 최종 발생 함수 L(σ)를 만든다.
L(σ): P 내에서 문자 σ가 가장 마지막으로 등장하는 위치의 인덱스
	•	존재하지 않으면 −1로 설정
#### Example
![[Pasted image 20250521174517.png|300]]
최종 발생 함수는 문자의 코드값으로 인덱싱된 배열로 표현 가능하다.
시간 복잡도는 O(m + s) (m: P의 길이, s: Σ의 크기)
## The Boyer-Moore Algorithm
![[Pasted image 20250521174604.png|400]]
⸻

분석
Boyer-Moore 알고리즘은
최악의 경우 O(nm + s) 시간에 동작한다.

최악의 예시:
	•	T = aaa…a
	•	P = baaa
이러한 경우는 이미지나 DNA 서열에서 발생할 수 있으나,
영문 텍스트에서는 드물다.

영문 텍스트에서는
Boyer-Moore 알고리즘이 브루트포스보다 훨씬 빠르다.