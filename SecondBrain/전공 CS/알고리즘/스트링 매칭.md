패턴 매칭 알고리즘
	•	브루트포스(Brute-force) 알고리즘
	•	Knuth-Morris-Pratt 알고리즘
	•	Boyer-Moore 알고리즘
## 문자열 
문자열은 문자들의 순서열이다.
문자열 예시:
•	C++ 프로그램
•	HTML 문서
•	DNA 서열
•	디지털 이미지

알파벳 Σ는 문자열 집합에서 사용 가능한 문자들의 집합이다.
알파벳 예시:
•	ASCII
•	{0, 1}
•	{A, C, G, T}

길이 m인 문자열 P가 있을 때,
•	부분 문자열 `P[i .. j]`는 i번부터 j번까지의 문자로 구성된 부분 시퀀스이다.
•	접두사(Prefix)는 `P[0 .. i]` 형태의 부분 문자열이다.
•	접미사(Suffix)는 `P[i .. m−1]` 형태의 부분 문자열이다.
문자열 T (텍스트)와 P (패턴)가 주어졌을 때, 패턴 매칭 문제란 T에서 P와 일치하는 부분 문자열을 찾는 것이다.

활용 분야:
•	텍스트 편집기
•	검색 엔진
•	생물학 연구
## 브루트포스 알고리즘 
브루트포스 패턴 매칭 알고리즘은,
텍스트 T에 대해 가능한 모든 위치에 패턴 P를 비교한다.
•	일치하는 경우: 종료
•	모든 위치를 시도한 경우: 종료
![[Pasted image 20250521174026.png|300]]
브루트포스 패턴 매칭은 시간 복잡도 O(nm)이다.
최악의 예시:
•	T = aaa…ah
•	P = aaah
이러면 최악의 경우 O(|A| x |B|)에 동작함
이미지나 DNA 서열에서는 흔히 발생하지만, 영문 텍스트에서는 드물다.
## KMP 알고리즘 - 동기
Knuth-Morris-Pratt 알고리즘은 왼쪽에서 오른쪽으로 비교하지만, 브루트포스보다 더 똑똑하게 패턴을 이동시킨다.
불일치가 발생했을 때, 중복 비교를 피하면서 패턴을 얼마나 많이 이동시킬 수 있을까?
→ 정답: `P[0..j]`의 가장 긴 접두사 중, `P[1..j]`의 접미사이기도 한 것
## KMP Algorithm - Idea
![[Pasted image 20250521174128.png|200]]
## KMP 실패 함수
![[Pasted image 20250521174155.png|200]]
KMP 알고리즘은 패턴의 접두사들이 패턴 내 다른 위치에서 일치하는지를 사전 처리한다.
실패 함수 F(j)는 `P[0..j]`의 접두사 중, `P[1..j]`의 접미사이기도 한 가장 긴 접두사의 길이이다.
KMP 알고리즘은 불일치 발생 시 `P[j]` ≠ `T[i]`이면 j ← F(j − 1)로 이동한다.

실패함수 F(x): 문자열 S\[0:x+1]에서 접두사와 접미사가 일치하는 최대 길이
문자열 S의 앞 x글자가 아니라 앞 x+1글자에서 접두사와 접미사의 최대 일치하는 길이다!
![[Pasted image 20250529202711.png|300]]
![[Pasted image 20250529202859.png|300]]
F(5) = 1인 것을 구해두었음
F(6)을 구하기 위해서 F(5) = 1이라는 것을 이용하자
F(6)을 구하려면, S\[6]이 S\[F(5)]와 같은지를 확인하고, 맞다면 F(6) = F(5) + 1 이다.
![[Pasted image 20250529203122.png|300]]
위 예제를 일반화하면 아래와 같다. (k = 6일 때)
S\[F(k-1)] S\[k]를 비교하면 된다.
![[Pasted image 20250529203439.png|200]]
S\[F(k-1)]=  S\[k] 이므로, F(k) = F(k - 1) + 1
![[Pasted image 20250529203532.png|200]]
S\[F(k-1)]=  S\[k] 이므로, F(k) = F(k - 1) + 1

![[Pasted image 20250529204551.png|200]]
F(3) = 2니 두 칸 밀어버린 모습
![[Pasted image 20250529204522.png|200]]

현재의 F(i)값을 구할 때에는 길이 F(i - 1)만큼의 구간을 그대로 가져온 후 다음 한 글자가 일치하는지를 확인한다.
일치한다면 F(i) = F(i-1) + 1로 쉽게 계산이 가능하다.
일치하지 않는다면, 문자열을 적절히 밀어주어야 하는데, 얼마나 밀어줄지 결정하기 위해서 현재 겹친 영역에서 접두사와 접미사가 얼마나 겹쳤는지를 참고할 수 있다.
이전에 일치하던 구간에서 접두사와 접미사가 겹치는 구간을 그대로 살려 아래의 문자열을 밀어준 후 마지막 글자를 비교하면 된다.
만약 마지막 글자가 다르다면 초록색 구간 안에서 접두사와 접미사가 얼마나 겹쳤는지를 확인해 그 구간을 그대로 살려 다시 아래의 문자열을 밀어주는걸 반복한다.
## KMP 알고리즘
![[Pasted image 20250521174245.png|200]]
실패 함수는 배열로 표현할 수 있고, O(m) 시간에 계산 가능하다.
while 루프의 각 반복에서
•	i는 1 증가하거나
•	i − j (이동량)는 최소 1 이상 증가한다. (F(j−1) < j 이므로)
따라서 while 루프는 최대 2n번 반복되며, KMP 알고리즘의 전체 시간 복잡도는 O(m + n)이다.
## 실패 함수 계산
![[Pasted image 20250521174317.png|200]]
실패 함수는 배열로 표현되며, O(m) 시간에 계산된다.
구성 방식은 KMP 알고리즘과 유사하다.
while 루프의 각 반복에서
•	i는 1 증가하거나
•	i − j는 최소 1 이상 증가한다.
→ 최대 2m번의 루프 반복으로 계산됨.
#### Example
![[Pasted image 20250521174339.png|300]]
## Boyer-Moore 휴리스틱
Boyer-Moore 패턴 매칭 알고리즘은 두 가지 휴리스틱에 기반한다.
1.	거울 휴리스틱(looking-glass heuristic): P와 T의 일부분을 오른쪽에서 왼쪽으로 비교
2.	문자 점프 휴리스틱(character-jump heuristic): `T[i]` = c에서 불일치 발생 시
	•	P에 c가 있다면, P 내 c의 가장 마지막 위치에 맞춰 이동
	•	없다면, `P[0]`을 `T[i+1]`과 맞춰 이동
#### Example
![[Pasted image 20250521174430.png|400]]
## 최종 발생 함수 (Last-Occurrence Function)
Boyer-Moore 알고리즘은 패턴 P와 알파벳 Σ에 대해 최종 발생 함수 L(σ)를 만든다.
L(σ): P 내에서 문자 σ가 가장 마지막으로 등장하는 위치의 인덱스
	•	존재하지 않으면 −1로 설정
#### Example
![[Pasted image 20250521174517.png|300]]
최종 발생 함수는 문자의 코드값으로 인덱싱된 배열로 표현 가능하다.
시간 복잡도는 O(m + s) (m: P의 길이, s: Σ의 크기)
## The Boyer-Moore Algorithm
![[Pasted image 20250521174604.png|400]]
#### Example
![[Pasted image 20250521175650.png|400]]
## 분석
![[Pasted image 20250521175707.png|300]]
Boyer-Moore 알고리즘은 최악의 경우 O(nm + s) 시간에 동작한다.
최악의 예시:
	•	T = aaa…a
	•	P = baaa
이러한 경우는 이미지나 DNA 서열에서 발생할 수 있으나, 영문 텍스트에서는 드물다.
영문 텍스트에서는 Boyer-Moore 알고리즘이 브루트포스보다 훨씬 빠르다.