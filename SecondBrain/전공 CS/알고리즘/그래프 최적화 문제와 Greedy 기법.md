## 목차
•	최적화 문제
	•	비용 최소화 또는 이익 최대화
•	그리디 알고리즘
	•	지금 당장 최선의 선택을 하라!
•	그래프 최적화 문제
	•	최소 신장 트리
		•	모든 정점을 연결하는 최소 비용
	•	단일 시작점 최단 경로
		•	두 정점 간의 최단 경로
## 최적화 문제
총 비용을 최소화하거나
총 이익을 최대화하는 문제
모든 가능한 결과를 분석하고 최적의 해를 찾는다.
최적을 달성하기 위해 일련의 선택을 한다.
## 그리디 알고리즘
- 일련의 선택을 할 때
- 각각의 선택이 제한된 “단기” 기준에서 최선이 되도록 한다.
	- 이 기준은 평가 비용이 너무 크지 않아야 한다.
- 나중에 그 선택이 잘못된 것으로 드러나더라도 한 번 선택하면 되돌릴 수 없다!

- 가능한 단점
	- 작은 단기 비용의 선택이 장기적으로 큰 비용이 불가피한 상황으로 이어질 수 있다.
## 그래프 최적화 문제
일부 최적화 문제는 그리디 알고리즘으로 정확히 해결 가능하다.
•	모든 정점을 연결하는 최소 비용 → 최소 신장 트리 알고리즘
•	두 정점 간의 최단 경로 → 단일 시작점 최단 경로 알고리즘
## Minimum Spanning Tree
- 스패닝 트리는 연결된 undirected graph G=(V,E)에 대해 G의 모든 정점을 포함하는 subgraph이다.
- weighted graph G=(V,E,W)에서 subgraph의 가중치는 해당 subgraph에 포함된 간선들의 가중치의 합이다.
- 가중치 그래프의 최소 신장 트리는 가중치의 합이 최소인 스패닝 트리이다.
![[Pasted image 20250512151904.png|400]]
## Prim 알고리즘
프림 알고리즘 (Prim’s Algorithm)
•	임의의 시작 정점을 선택한다 (루트).
•	현재까지 구성된 트리에서 뻗어나가며, 매 반복마다 간선을 하나 선택한다.
	•	트리에 연결할 수 있는 모든 간선 중 가중치가 가장 작은 간선을 트리에 추가한다.
	•	간선에 연결된 정점을 트리에 추가한다.
•	알고리즘 수행 중, 정점들은 세 가지 서로 겹치지 않는 범주로 나뉜다:
	•	트리 정점(Tree vertices): 지금까지 구성된 트리에 포함된 정점들,
	•	경계 정점(Fringe vertices): 트리에 속하지는 않지만 트리 내 어떤 정점과 인접한 정점들,
	•	미탐색 정점(Unseen vertices): 그 외의 모든 정점들.
### The Algorithm in Action, Example
![[Pasted image 20250512152240.png|400]]
### Prim’s Algorithm: Outline
![[Pasted image 20250512152304.png|400]]
### 시간 복잡도 분석
![[Pasted image 20250530173638.png|500]]
프림 알고리즘은 우선 순위 큐에서 가장 작은 정점을 찾고, 삭제하는 과정을 n번 반복한다.
또한 새로운 후보 정점들을 n번 삽입하는데

프림 알고리즘의 시간 복잡도 T(n, m) = O(n x (T(getMin) + T(deleteMin) + T(insert)) + m x T(decreaseKey))이므로

unsorted array 사용 시: 
최솟 값 가져오는 연산: O(n) (최악의 경우, 모든 )


### Kruskal’s Algorithm: Outline
![[Pasted image 20250512152334.png|400]]
R은 남은 edges, F는 결과인 forest edges
1. 모든 edge의 집합을 오름차순으로 정렬
2. R에서 가장 가중치가 작은 간선을 꺼낸다
3. 간선 vw를 추가했을 때 cycle이 생기지 않는다면 F에 추가
4. n-1개의 간선이 포함되면 종료한다.
## Kruskal 알고리즘을 위한 자료구조
•	알고리즘은 여러 개의 트리(포레스트)를 유지
•	간선이 서로 다른 트리를 연결할 때만 선택
•	서로소 집합(disjoint set)을 유지하기 위한 자료구조 필요
필요한 연산:
	•	find(u): u를 포함하는 집합 반환
	•	union(u, v): u와 v가 속한 집합을 병합
#### example
![[Pasted image 20250512152423.png|300]]
![[Pasted image 20250512152439.png|300]]
![[Pasted image 20250512152454.png|300]]
![[Pasted image 20250512152506.png|300]]
![[Pasted image 20250512152519.png|300]]
![[Pasted image 20250512152540.png|300]]
![[Pasted image 20250512152552.png|300]]
740을 받아들이면, 사이클이 생겨버리므로 제외함
![[Pasted image 20250512152606.png|300]]
![[Pasted image 20250512152616.png|300]]
849을 받아들이면, 사이클이 생겨버리므로 제외함
![[Pasted image 20250512152629.png|300]]
867을 받아들이면, 사이클이 생겨버리므로 제외함
![[Pasted image 20250512152640.png|300]]
![[Pasted image 20250512152651.png|300]]
1090을 받아들이면, 사이클이 생겨버리므로 제외함
![[Pasted image 20250512152701.png|300]]
1121을 받아들이면, 사이클이 생겨버리므로 제외함
![[Pasted image 20250512152712.png|300]]
모든 정점이 연결되었으므로 종료
## 문제: 단일 시작점 최단 경로
- 두 지정된 정점 사이의 최소 가중치 경로를 찾는다.
- 최악의 경우, 특정한 정점 쌍 s와 t 사이의 최소 가중치 경로를 찾는 것은 정점 s에서 도달 가능한 모든 정점까지의 최소 가중치 경로를 찾는 것보다 더 쉽지 않다.
	- 이것이 단일 시작점 최단 경로 문제이다.
## 최단 경로 정의
 -  그래프 G = (V, E, W)에서 P를 k개의 간선으로 구성된 비어 있지 않은 경로라고 하자. 이 경로는 xv<sub>1</sub>, v<sub>1</sub>, v<sub>2</sub>, ...., v<sub>k-1</sub>y (여기서 v<sub>1</sub> = y일 수도 있음)로 이루어져 있다.
- 경로 P의 가중치 W(P)는 각 간선의 가중치 W(xv<sub>1</sub>), W(v<sub>1</sub>v<sub>2</sub>), ..., W(v<sub>k-1</sub>y)의 합이다.
- 만약 x = y라면, 빈 경로(empty path)는 x에서 y로 가는 경로로 간주한다. 이때 빈 경로의 가중치는 0이다.
- x에서 y까지의 경로 중 W(P)보다 더 작은 가중치를 가진 경로가 없다면, P는 최단 경로(shortest path) 또는 최소 가중치 경로(minimum-weight path) 라고 한다.
## 최단 경로의 성질
보조정리: 최단 경로 성질
- 가중치 그래프 G에서 x에서 z로 가는 최단 경로가 x에서 y까지의 경로 P와 y에서 z까지의 경로 Q로 구성되어 있다면,
- P는 x에서 y까지의 최단 경로이고 Q는 y에서 z까지의 최단 경로이다.
## Dijkstra's Shortest-Path Algorithm
Weight는 음수가 아님
![[Pasted image 20250512153135.png|400]]
1. 모든 정점을 unseen으로 초기화
2. 시작 정점 s를 tree로 지정하고, d(s, s) = 0
3. s와 인접한 정점들을 fringe로 재분류
4. while (fringe 정점이 존재하는 동안)
	1. tree 정점 t와 fringe 정점 v 간의 edge 중 (d(s, t) + W(tv)값이 최소인 (t, v)선택)
	2. v를 tree로 재분류, edge (t, v)를 트리에 추가
	3. v와 인접한 unseen 정점들을 fringe로 재분류

![[Pasted image 20250512153145.png|400]]
A에서 목적지 어딘가로 가는 shortest path를 찾고자 하는 문제임
## 정당성 (Correctness)
### 정리
- G=(V,E,W)가 가중치가 모두 0 이상인 그래프라고 하자.
- V’는 V의 부분 집합이며, s는 V’에 포함된 정점이다.
- 모든 y ∈ V’에 대해, d(s,y)는 s에서 y까지의 최단A 거리라고 하자.

- 만약 yz라는 간선을 선택할 때 y ∈ V’, z ∈ V-V’인 모든 간선 중에서 d(s,y) + W(yz)를 최소화하는 간선을 선택하면, 
	- s에서 y까지의 최단 경로 뒤에 yz 간선을 연결한 경로는 s에서 z까지의 최단 경로가 된다.
### 정리
- 방향성 가중 그래프 G와 음수가 아닌 가중치를 갖는 간선들, 그리고 시작 정점 s가 주어졌을 때,
	- Dijkstra 알고리즘은 s로부터 도달 가능한 각 정점까지의 최단 거리를 계산한다.