###### dijkstra algorithm 시간 복잡도
insert or decrease key: 우선 순위 큐를 사용하므로 연산당 비용 O(log n), 간선 수만큼 반복
가장 가까운 정점 꺼내기: 우선 순위 큐를 사용하므로 연산당 비용 O(log n), 정점 수만큼 반복
	따라서 Dijkstra 알고리즘 시간 복잡도 O((n + m)log n) = O(mlogn)
###### 각 정점에서 DFS를 수행함으로써 Transitive Closure를 계산할 때의 시간 복잡도
O(n(n + m))이다.
dfs: 각 정점과 간선을 한 번씩 방문하므로 n + m
###### brute force 패턴 매칭 최악의 경우, 시간 복잡도
•	T = aaa…ah
•	P = aaah
 O(nm)
###### Boyer-Moore 알고리즘 최악의 경우 시간복잡도 분석, 예시
nm이 나오는 경우 최악의 예시:
•	T = aaa…a
•	P = baaa

(m: P의 길이, s: Σ의 크기)
최종 발생 함수: 최종 발생 함수를 -1로 초기화 하는 시간 O(s) + 패턴을 한 번 순회하며 업데이트하는 시간 O(m) 즉, O(m + s)

문자열 매칭: 길이가 n인 텍스트를 비교할 때, 최악의 경우 불일치가 자주 발생하며 한 칸씩 이동하며 각 위치마다 최대 패턴의 크기인 m번까지 비교가 일어나 시간 복잡도는 O(m·n)

따라서, O(m·n + s)
###### kmp 시간 복잡도 계산
O(m + n)
실패 함수 계산: 패턴 P의 길이를 m이라 할 때, 각 문자에 대해 한 번씩만 비교하거나 실패 함수 값을 따라 이동(j 감소)하기 때문에 최대 2m번의 루프 반복으로 계산되어 O(m)의 시간 복잡도를 가진다.
**각 문자에 대해 최대 한 번 비교 && 실패 함수 값을 따라 이동 => 최대 2m번**

문자열 매칭: - 텍스트 T의 길이를 n이라 할 때, 각 문자를 최대 한 번씩만 비교하거나 실패 함수 값을 따라 이동하며 건너뛰므로 O(n) 시간이 걸린다.
따라서, 전체 KMP 알고리즘의 시간 복잡도는 O(m + n)으로, 텍스트와 패턴의 길이에 비례하는 선형 시간 내에 동작한다.


###### 서술형
TSP
TSP가 NP-hard임을 보이려면, NP-complete임이 알려진 HC 결정문제를 TSP로 다항 시간 환원해야 한다.

이를 위해 무가중치 그래프 G에 대응하는 G'을 만든다.
G에 존재하는 간선을 G'에서는 가중치가 1인 간선으로 대응시키고, 나머지 간선들은 


무향 해밀토니안