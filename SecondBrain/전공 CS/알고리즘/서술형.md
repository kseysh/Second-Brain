###### dijkstra algorithm 시간 복잡도
insert or decrease key: 우선 순위 큐를 사용하므로 연산당 비용 O(log n), 간선 수만큼 반복
가장 가까운 정점 꺼내기: 우선 순위 큐를 사용하므로 연산당 비용 O(log n), 정점 수만큼 반복
	따라서 Dijkstra 알고리즘 시간 복잡도 O((n + m)log n) = O(mlogn)
###### 각 정점에서 DFS를 수행함으로써 Transitive Closure를 계산할 때의 시간 복잡도
O(n(n + m))이다.
dfs: 각 정점과 간선을 한 번씩 방문하므로 n + m
###### brute force 패턴 매칭 최악의 경우, 시간 복잡도
•	T = aaa…ah
•	P = aaah
 O(nm)
###### Boyer-Moore 알고리즘 최악의 경우 시간복잡도 분석, 예시
nm이 나오는 경우 최악의 예시:
•	T = aaa…a
•	P = baaa

(m: P의 길이, s: Σ의 크기)
최종 발생 함수: 최종 발생 함수를 -1로 초기화 하는 시간 O(s) + 패턴을 한 번 순회하며 업데이트하는 시간 O(m) 즉, O(m + s)

문자열 매칭: 길이가 n인 텍스트를 비교할 때, 최악의 경우 불일치가 자주 발생하며 한 칸씩 이동하며 각 위치마다 최대 패턴의 크기인 m번까지 비교가 일어나 시간 복잡도는 O(m·n)

따라서, O(m·n + s)
###### kmp 시간 복잡도 계산
O(m + n)
실패 함수 계산: 패턴 P의 길이를 m이라 할 때, 각 문자에 대해 한 번씩만 비교하거나 실패 함수 값을 따라 이동(j 감소)하기 때문에 최대 2m번의 루프 반복으로 계산되어 O(m)의 시간 복잡도를 가진다.
**각 문자에 대해 최대 한 번 비교 && 실패 함수 값을 따라 이동 => 최대 2m번**

문자열 매칭: - 텍스트 T의 길이를 n이라 할 때, 각 문자를 최대 한 번씩만 비교하거나 실패 함수 값을 따라 이동하며 건너뛰므로 O(n) 시간이 걸린다.
따라서, 전체 KMP 알고리즘의 시간 복잡도는 O(m + n)으로, 텍스트와 패턴의 길이에 비례하는 선형 시간 내에 동작한다.


###### 서술형
TSP
TSP가 NP-hard임을 보이려면, NP-complete임이 알려진 HC 결정문제를 TSP로 다항 시간 환원해야 한다.

이를 위해 무가중치 그래프 G에 대응하는 완전 가중치 무향 그래프 G'을 만든다.
G에 존재하는 간선을 G'에서는 가중치가 1인 간선으로 대응시키고, 나머지 간선들은 무한의 가중치를 둔다.
이후 순회시의 가중치 합의 상한선을 |V|로 둔다.

이 때, G'에서 HC가 존재하면, 가중치 합이 |V|인 사이클이 존재한다는 뜻이고, TSP가 yes이다. 반대로 TSP가 yes이면, G'에는 가중치 합이 |V|이하인 사이클이 존재하며 이는 모든 정점을 포함하며 존재하는 간선으로만 이루어진 사이클이므로 HC가 존재함을 보장할 수 있다.


무향 해밀토니안
무향 hc가 np-hard임을 보이려면, np-complete임이 알려진 유향 hc 결정문제를 무향 hc 문제로 다항 시간 환원해야 한다.

이를 위해 무향 그래프 G에 대응하는 유향 그래프 G'을 만든다.
G의 각 간선 v에 대해 G'에서 vin-v-vout을 대응시키고, 세 정점을 무향 간선으로 잇는다.
또한 G에서 유향간선 v->w가 존재한다면, G'에서 vout->vin의 무향 간선을 이어준다.

유향 hc가 존재하면 무향 hc가 존재한다
=> G에서 유향 hc인 C가 (v0->...vk->v0)를 가지면, G'에서도 이에 대응하는 C' = (v0in->v0...v0)를 갖는다.
이는 

무향 hc가 존재하면 유향 hc가 존재한다.