###### dijkstra algorithm 시간 복잡도
insert or decrease key: 우선 순위 큐를 사용하므로 연산당 비용 O(log n), 간선 수만큼 반복
가장 가까운 정점 꺼내기: 우선 순위 큐를 사용하므로 연산당 비용 O(log n), 정점 수만큼 반복
	따라서 Dijkstra 알고리즘 시간 복잡도 O((n + m)log n) = O(mlogn)
###### 각 정점에서 DFS를 수행함으로써 Transitive Closure를 계산할 때의 시간 복잡도
O(n(n + m))이다.
dfs: 각 정점과 간선을 한 번씩 방문하므로 n + m
###### brute force 패턴 매칭 최악의 경우, 시간 복잡도
•	T = aaa…ah
•	P = aaah
 O(nm)
###### 최종 발생 함수의 시간 복잡도
O(m + s) 
(m: P의 길이, s: Σ의 크기)
O(s): s 초기화 시간
O(m): 패턴을 한 번 순회하며 업데이트
###### Boyer-Moore 알고리즘 최악의 경우 시간복잡도 분석, 예시
Boyer-Moore 알고리즘은 최악의 경우 O(nm + s) 시간에 동작한다.
s: 알파벳의 개수
nm이 나오는 경우 최악의 예시:
	•	T = aaa…a
	•	P = baaa

길이가 n인 텍스트를 비교할 때, 불일치가 자주 발생하면서 한 칸씩 밖에 이동하지 못하게 되면 각 위치마다 패턴의 크기인 최대 m번까지 비교가 일어나 시간 복잡도는 O(m·n)이고, 최종 발생 함수의 시간 복잡도가 O(m + s)이므로 O(m·n + s)이다.
###### kmp 시간 복잡도 계산
O(m + n)
실패 함수 계산: 패턴 P의 길이를 m이라 할 때, 각 문자에 대해 한 번씩만 비교하거나 실패 함수 값을 따라 이동(j 감소)하기 때문에 최대 2m번의 루프 반복으로 계산되어 O(m)의 시간 복잡도를 가진다.
**각 문자에 대해 최대 한 번 비교 && 실패 함수 값을 따라 이동 => 최대 2m번**

문자열 매칭: - 텍스트 T의 길이를 n이라 할 때, 각 문자를 최대 한 번씩만 비교하거나 실패 함수 값을 따라 이동하며 건너뛰므로 O(n) 시간이 걸린다.
따라서, 전체 KMP 알고리즘의 시간 복잡도는 O(m + n)으로, 텍스트와 패턴의 길이에 비례하는 선형 시간 내에 동작한다.
