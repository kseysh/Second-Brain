###### dijkstra algorithm 시간 복잡도
insert or decrease key: 우선 순위 큐를 사용하므로 연산당 비용 O(log n), 간선 수만큼 반복
가장 가까운 정점 꺼내기: 우선 순위 큐를 사용하므로 연산당 비용 O(log n), 정점 수만큼 반복
	따라서 Dijkstra 알고리즘 시간 복잡도 O((n + m)log n) = O(mlogn)
###### 각 정점에서 DFS를 수행함으로써 Transitive Closure를 계산할 때의 시간 복잡도
O(n(n + m))이다.
dfs: 각 정점과 간선을 한 번씩 방문하므로 n + m
###### brute force 패턴 매칭 최악의 경우, 시간 복잡도
•	T = aaa…ah
•	P = aaah
 O(nm)
###### Boyer-Moore 알고리즘 최악의 경우 시간복잡도 분석, 예시
nm이 나오는 경우 최악의 예시:
•	T = aaa…a
•	P = baaa

(m: P의 길이, s: Σ의 크기)
최종 발생 함수: 최종 발생 함수를 -1로 초기화 하는 시간 O(s) + 패턴을 한 번 순회하며 업데이트하는 시간 O(m) 즉, O(m + s)

문자열 매칭: 길이가 n인 텍스트를 비교할 때, 최악의 경우 불일치가 자주 발생하며 한 칸씩 이동하며 각 위치마다 최대 패턴의 크기인 m번까지 비교가 일어나 시간 복잡도는 O(m·n)

따라서, O(m·n + s)
###### kmp 시간 복잡도 계산
O(m + n)
실패 함수 계산: 패턴 P의 길이를 m이라 할 때, 각 문자에 대해 한 번씩만 비교하거나 실패 함수 값을 따라 이동(j 감소)하기 때문에 최대 2m번의 루프 반복으로 계산되어 O(m)의 시간 복잡도를 가진다.
**각 문자에 대해 최대 한 번 비교 && 실패 함수 값을 따라 이동 => 최대 2m번**

문자열 매칭: - 텍스트 T의 길이를 n이라 할 때, 각 문자를 최대 한 번씩만 비교하거나 실패 함수 값을 따라 이동하며 건너뛰므로 O(n) 시간이 걸린다.
따라서, 전체 KMP 알고리즘의 시간 복잡도는 O(m + n)으로, 텍스트와 패턴의 길이에 비례하는 선형 시간 내에 동작한다.


###### 서술형
TSP 증명
후보해의 순회가 주어졌을 때, 순회가 각 정점을 모두 포함하고, 정점 간 이동시에 실제 간선이 있는지 확인하며 총 가중치의 비용이 K 이하임을 확인하는 작업은 단순한 루프를 통해 다항시간에 확인가능하다.
따라서 TSP는 NP에 포함된다.

TSP가 np-hard임을 보이려면, np-complete라고 알려진 hc를 TSP로 다항시간 환원한다.

그래프 G에 대응하는 완전 무향 가중치 그래프 G'을 만들고, G에 존재하는 간선은 G'에서 가중치가 1인 간선으로 만들고 나머지 간선은 무한의 가중치를 둔다.
또한 TSP 문제의 총 비용 상한선인 K를  |V|로 둔다.

이제 G에서 HC가 존재하면, 가중치가 1인 간선만을 이용해 모든 정점을 순회하는 비용이 정확히 |V|인 순회가 존재하게 된다. 따라서 TSP는 yes이다.
반대로 G'에서 TSP가 yes라면, 이는 G에서 모든 정점을 순회하는 비용 |V|이하의 순회가 존재한다고 할 수 있다. 따라서 G에는 hc이 존재한다.

이를 통해 hc를 TSP로 다항시간 환원할 수 있으며, n


무향 HC 증명
후보해의 사이클이 존재할 때, 사이클이 모든 정점을 포함하고, 사이클이 존재하는 간선으로만 이루어져 있는지 확인하는 것은 다항시간 내에 확인이 가능하다. 따라서 무향 hc




