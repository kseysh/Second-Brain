###### Google 접속시 일어나는 일
1. (Application) 브라우저가 URL에 적힌 값을 파싱해서 HTTP Request Message를 만들고, OS에 전송 요청
2. DNS Look up을 진행
	1. hosts 파일 -> local DNS Server -> Root DNS Server -> 계속 다음 레벨의 DNS 서버에 ip 정보가 있는지 확인
3. (Transport) ip를 찾았다면 port to port로 packet 전송
4. (Network) packet을 
5. (Data Link) hop to hop으로 switch 끼리 데이터를 전송함
6. (Physical)
A
###### TCP의 특징
Stream delivary: Application Layer에서 만든 boundary를 상관하지 않고 보낸다.
이는 Sending buffer와 Listening Buffer를 이용하여 가능할 수 있다.
Cumulative ACK: 어디까지 받았다라고 응답하는 Selective ACK이 아닌 어디부터 받고 싶다라고 응답하는 방식
###### 3- way handshake
TCP 연결 전 상대가 응답할 수 있는지 확인하기 위해 set up하는 단계입니다.
SYN, ACK 패킷을 주고 받으며 SYN에서 sequence number로 임의의 난수를 전송하고, ACK 패킷에는 ack number로 1을 더해 잘 받았다고 응답합니다. 따라서 A가 syn을 보내면, B는 잘 받았다고 ACK을 보내며 A가 연결가능한지 SYN을 보내고, A가 마지막으로 ACK을 보내면 3-way-handshake가 완료됩니다.
###### 4-way-handshake
TCP 연결을 해제하는 단계로 set up 단계와 달리 3-way-handshake가 아닌 이유는 Half-Close를 하기 위함입니다. 종료 요청은 보통 클라이언트 쪽에서 요청합니다. 이 때, 서버쪽에서 아직 전송해야 할 데이터가 남아있다면 클라이언트의 연결 종료 요청인 FIN에게 ACK을 보내고, 데이터 전송을 마무리 한 후 클라이언트에게 FIN을 보내기 위함입니다.
###### 클라이언트가 FIN을 받고 TIME-WAIT 시간이 필요한 이유
서버는 이전 연결과 이후 연결을 포트 번호로 구분하는데, 이후 연결이 IP 주소와 port번호를 똑같이 다시 오게 되면 새로운 것이 온건지 이전 것이 온건지 구분하기가 어려워진다.
따라서 포트를 반납하지 않고 Time wait을 걸어 못쓰게 만든다.
어차피 패킷은 1-2분 후에 자동 소멸 하므로 Time wait만큼 기다리면 다시 요청이 들어오지 않게 된다.
또한, FIN/ACK을 보내고 ACK을 못 받았을 때, ACK을 다시 요청하면 ACK을 보내야하므로 대기 시켜놓는다.
###### flow control이란?
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
###### Q
A
