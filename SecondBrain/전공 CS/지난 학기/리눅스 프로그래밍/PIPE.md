## 파이프 (Pipes)
- *파이프는 가장 오래된 유닉스 시스템의 IPC(프로세스 간 통신) 방식으*로, *모든 유닉스 시스템에 제공*됩니다.
- 가장 단순한 유닉스 IPC 메커니즘이며, 특수 파일로 표현됩니다.
![[Pasted image 20241126115806.png|400]]

## `pipe(2)` 시스템 호출 (1/2)
```c
int pipe(int filedes[2]); // pipe는 fd가 두개 있어야 하므로 array 사용
```
- 선입선출(FIFO) 방식으로 동작합니다.
- *`lseek`가 파이프에서 작동하지 않으므로 순서를 변경할 수 없습니다*. (lseek는 disk에서만 쓸 수 있다)
- 제한사항:
  - 단 방향 통신 (양 방향으로 쓸 수는 있음)
  - 파이프는 부모와 자식 프로세스 간에 사용됩니다.(fd를 공유할 수 있는 자식은 파이프를 사용할 수 있다.)
- 인자 - `filedes`: `filedes[0]` - 읽기, `filedes[1]` - 쓰기
###### 파이프에서 `read`와 `write` 호출 시 동작 (중요)
- `read` 호출 시:
  - 파이프에 데이터가 있을 때: 즉시 반환됩니다.
  - 파이프가 비어 있을 때: 파이프에 데이터가 쓰여질 때까지 block한다.
- `write` 호출 시:
  - 파이프가 가득 차지 않았을 때: 즉시 반환됩니다.
  - 파이프가 가득 찬 경우: 공간이 생길 때까지 block 한다.
###### 파이프의 한 쪽 끝이 닫힌 경우 (중요)
- 쓰기 끝이 닫힘: 모든 데이터를 읽은 후 `read`는 파일 끝(EOF)을 나타내기 위해 0을 반환합니다.
- 읽기 끝이 닫힘: SIGPIPE 신호가 생성됩니다.
  - 이 신호를 무시하거나 잡아서 신호 처리기로부터 반환하면, `write()`는 -1을 반환하고 `errno`는 `EPIPE`로 설정됩니다.
  - pipe에 대한 write는 slow system call로 간주하기 때문에 SIGPIPE를 받으면 write()는 실패한다.

![[Pasted image 20241126122855.png|500]]
- 두 프로세스가 파이프에 대해 동시에 자유롭게 읽고 쓴다면 혼란이 발생할 것입니다.
- 이를 피하기 위해, 각 프로세스는 파이프에 대해서 읽기만 하거나 쓰기만 하고, 필요 없는 파일 디스크립터는 닫는 것이 관례입니다.
- 만약 3을 4로 변경하면, 자식 프로세스가 종료되었을 때 부모 프로세스는 여전히 파이프에 쓰기 위해 파일 디스크립터 \[4]를 열어두고 있습니다. 부모 프로세스는 추가 데이터를 기다리면서 무기한으로 블록됩니다. (deadlock 상황이 발생할 수 있다.)
- 만약 p\[1](쓰는 fd)을 close해두었다면, 파이프의 쓰기 끝이 닫힌 경우가 되며 모든 데이터를 읽고 read가 즉각 0을 반환하며 deadlock을 방지할 수 있다. (따라서 읽기/쓰기 중 자신이 사용하지 않는 fd는 close해주어야 한다.)
![[Pasted image 20241126123923.png|500]]
=> 이렇게 자신이 사용하지 않는 fd는 close해주고 사용해야 함
## 파이프 크기
- 파이프의 크기는 유한하며, POSIX에서는 512바이트로 지정하지만, 대부분의 시스템에서 이보다 크게 설정됩니다.
###### 파이프가 가득 찬 경우
- `write`가 차단되어 다른 프로세스가 파이프에서 읽을 때까지 대기합니다.
###### 여러 프로세스 간의 동작
- `PIPE_BUF` 바이트 이하의 쓰기는 다른 쓰기 데이터와 interleaved되지(섞이지) 않는다. (같은 pipe에서 여러개의 프로세스가 write하더라도, 그 프로세스간 interleaved되지 않는다.)
- `PIPE_BUF` 바이트를 초과하여 쓰는 경우, 데이터가 다른 프로세스의 쓰기 데이터와 섞일 수 있다.
## Blocking & Non-Blocking
- 영원히 호출자를 차단할 수 있는 시스템 호출
  - 읽기: 데이터가 없을 때 특정 파일 타입(파이프, 터미널 장치, 네트워크 장치)에서 Block됩니다.
  - 쓰기: 데이터가 즉시 받아들여지지 않을 때 Block됩니다 (예: 파이프가 가득 찼을 때).
  - 열기: 특정 파일 타입에서 조건이 발생할 때까지 차단됩니다 (FIFO).
###### Non-Blocking I/O를 지정하는 두 가지 방법
1. 파일 디스크립터를 열 때: `O_NONBLOCK` 옵션을 지정합니다.
2. 이미 열린 디스크립터의 경우: `fcntl`을 호출하여 `O_NONBLOCK` 파일 상태 플래그를 켭니다.
## Non-Blocking write and read
- 파이프에서 `read` 또는 `write`가 차단되지 않도록 보장하는 방법:
	-  `fcntl`: `O_NONBLOCK` 플래그를 사용합니다.
  ```c
  if(fcntl(p[1], F_SETFL, O_NONBLOCK)==-1)
  perror(“fcntl”);
  ```
- 파이프가 가득 찬 경우: `fcntl(p[1], F_SETFL, O_NONBLOCK)`
	- 이후에 write 호출은 절대 블록되지 않습니다.
	- 반환 값은 -1이 되고, errno는 EAGAIN으로 설정됩니다.
- 파이프가 비어 있는 경우: `fcntl(p[0], F_SETFL, O_NONBLOCK)`
	- 이후에 read 호출은 절대 블록되지 않습니다.
	- 반환 값은 -1이 되고, errno는 EAGAIN으로 설정됩니다.