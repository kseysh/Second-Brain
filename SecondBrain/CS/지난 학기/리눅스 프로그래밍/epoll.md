## select의 방식
- 소켓 서버가 시작되면, 커널로 FD의 목록 복사본을 보낸다. (복사에 많은 비용이 든다)
- 소켓에 새 데이터가 들어오면 깨어달라는 요청을 한 후 sleep
- 새로운 데이터가 들어오면 네트워크 하드웨어가 CPU 인터럽트를 트리거한다
- CPU가 idle상태에 빠진 프로세스를 깨운다
- 프로세스가 깨어난 이후 어떤 소켓이 해당 FD에 해당하는지 탐색한다 (O(N))

=> 다수의 소켓 포트가 단일 프로세스에 의해 핸들링 될 수 있어서 c10k 문제를 해결할 수 있다.
지원하는 연결의 최대 수가 1024여서 그 이상 처리할 수 없는 단점이 있다.
## poll의 방식
select와 거의 유사하다
## epoll의 방식
- 커널 스페이스에 epoll red black Tree와 waitlist 큐를 저장한다 (user -> kernel 데이터 복사를 하지 않는다)
- 유저 프로세스에서 하나 이상의 소켓 FD를 epoll을 호출해 RB 트리에 저장한다
- 유저 프로세스는 waitlist 큐에 listen을 시작해서 새 데이터가 들어오는 것을 주시한다
- 네트워크 드라이버로부터 새 데이터가 들어오면 OS는 소켓 포트에 기반하여 FD를 찾고 FD를 waitlist 큐에 삽입한다
- 유저 프로세스는 waitlist 큐로부터 파일 디스크립터와 들어

## epoll에서 fd를 trigger하는 2가지 방식
### level-triggered
특정 상태가 유지되는 동안 감지
입력 버퍼에 데이터가 수신된 상황에서 빠르게 읽지 않으면 epoll_wait()함수를 호출할 때마다 이벤트가 발생하고 이로 인해 발생하는 이벤트의 수가 계속 누적되어 정상적인 처리가 불가능해질 수 있다.
### edge-triggered (default)
특정 상태가 변화하는 시점에서만 감지
소켓 버퍼에 대응하면, 한 번에 읽을 수 있는 데이터 버퍼가 600인데, 데이터가 1000byte가 도착했다면 600바이트만 읽고 나머지 400바이트는 읽지 않은 상태에서 더 이상의 이벤트는 발생하지 않는다.

ex)
0000111000011100  
LT의 경우 1이 유지되는 동안 감지를 합니다. 즉 6회 입니다.  
ET의 경우 특정 상태가 변하는 시점에서만 발생하기 때문에 2회 감지

## epoll_create
`epoll_create(int size)`
fd들의 입출력 이벤트 저장을 위한 공간을 만든다.
커널이 필요한 데이터 구조의 크기를 동적으로 조정하기 때문에 size에 0보다 큰 값만 입력한다.
epoll fd를 반환하며, 이를 이용해 epoll에 등록된 fd를 조작한다.
## epoll_ctl
`epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)`
epoll에 fd들을 등록/수정/삭제하는 함수

* epfd : epoll fd 값
* fd : epfd에 등록할 관심있는 파일 디스크립터 값
* op : 관심가질 fd를 등록할지, 등록되어 있는 fd의 설정을 변경할지, 등록되어 있는 fd를 관심 목록에서 제거할지에 대한 옵션값

| EPOLL_CTL_ADD | fd를 epfd의 관심 목록에 추가, 이미 목록에 존재한다면 EEXIST에러를 발생 시킨다. event 집합은 `*event`에 저장 된다.              |
| ------------- | ------------------------------------------------------------------------------------------- |
| EPOLL_CTL_MOD | `*event`에 지정된 정보를 이용해 fd 설정 변경. 관심 목록에 없는 fd라면 ENOENT 에러를 발생시킨다.                            |
| EPOLL_CTL_DEL | epfd 에서 fd를 제공 한다. epfd 관심 목록에 없는 fd를 제거하려면 ENOENT 에러를 발생한다. fd를 닫으면 epoll관심 목록에서 자동 제거 된다. |
- event : epfd에 등록할 관심있는 fd가 어떤 이벤트가 발생할 때 관심을 가질지에 대한 구조체. 관찰 대상의 관찰 이벤트 유형

| EPOLLIN      | 수신할 데이터가 있다.                  |
| ------------ | ----------------------------- |
| EPOLLOUT     | 송신 가능하다.                      |
| EPOLLPRI     | 중요한 데이터(OOB) 발생.              |
| EPOLLRDHUD   | 연결 종료 또는 Half-close 발생        |
| EPOLLERR     | 에러 발생                         |
| EPOLLET      | 엣지 트리거 방식으로 설정(기본은 레벨 트리거 방식) |
| EPOLLONESHOT | 한번만 이벤트 받음                    |
## epoll_wait
`int epoll_wait(int epfd,  struct epoll_event * events, int maxevents, int timeout)`
관심있는 fd들에 무슨 일이 일어났는지 조사한다.
* events : 이벤트가 발생된 fd들을 모아놓은 구조체 배열.
* maxevents : 실제 동시접속수와 상관없이 maxevents 파라미터로 최대 몇개까지의 event만 처리할 것임을 지정해 주도록 하고 있다. 만약 현재 접속수가 1만이라면 최악의 경우 1만개의 연결에서 사건이 발생할 가능성도 있기 때문에 1만개의 events[] 배열을 위해 메모리를 확보해 놓아야 하지만, 이 maxevents 파라미터를 통해 한번에 처리하길 희망하는 숫자를 제한할 수 있다
* timeout : epoll_wait의 동작특성을 지정해주는 중요한 요소인데, 밀리세컨드 단위로 지정해주도록 되어 있다. 이 시간만큼 사건발생을 기다리라는 의미이며 기다리는 도중에 사건이 발생하면 즉시 리턴된다.
	* timeout(-1)로 지정해주면 영원히 사건을 기다리는 blocking상태가 된다.
	* timeout(0)로 지정해주면 사건이 있건 없건 조사만 하고 즉시 리턴하는 상태가 된다.
### timeout 사용 예
#### timeout (양수)
온라인게임(특히 MMORPG)의 경우에는, 이용자의 입력이 전혀 없는 도중이라고 하더라도, 몬스터에 관련된 처리, 적절한 저장, 다른 서버와의 통신들을 해야 하므로 적절한 timeout (필자의 경우에는 1/100 sec, 즉 10ms를 선호한다)을 지정해 준다.
#### timeout (0)
뭔가의 프로세싱을 주로 하면서 잠깐잠깐 통신이벤트를 처리하고자 하는 경우, 즉 프로세스의 CPU 점유를 높게해서 무언가를 하고 싶은 경우에는, timeout 0을 설정하여 CPU를 독점하도록 설계할 수도 있다.
#### timeout(-1)
채팅서버의 경우를 살펴보자. 서버가 어떠한 일을 해야하는 시점은 이용자 누군가가 데이터를 보내왔을 때인데, 아무도 아무말도 하지 않는다면 서버는 굳이 프로세싱을 할 이유가 없다. 
이럴때 timeout을 (-1)로 지정해두고 이용자들의 입력이 없는 동안 운영체제에 프로세싱 타임을 넘기도록 한다.

별도 thread를 구성하여 이 thread 가 입출력을 전담하도록 프로그램을 작성하고자 하는 경우에는, 당연히 timeout을 (-1)로 설정하여 남는 시간을 다른 thread, 혹은 운영체제에 돌려 주도록 한다.

epoll을 이용해 채팅 서버 만들기..?

## epoll 사용하는 곳
nginx와 redis가 C10K문제를 해결하기 위해서 1만개의 스레드가 서로 폴링 경합을 벌이며 CPU 낭비를 하지 않고 CPU가 사용가능할 때 epoll을 호출하여 대기 중인 스레드 중 하나를 깨워 일을 할 수 있도록 해준다.
JAVA -> NIO