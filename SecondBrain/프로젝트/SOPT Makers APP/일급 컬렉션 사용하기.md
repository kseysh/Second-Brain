# 일급 컬렉션이란?
소트웍스 앤솔로지의 객체 지향 생활 체조 파트에서 언급된 단어로 아래와 같이 정의되어 있습니다.
	규칙 8: 일급 콜렉션 사용  
	이 규칙의 적용은 간단하다.  
	콜렉션을 포함한 클래스는 반드시 다른 멤버 변수가 없어야 한다.  
	각 콜렉션은 그 자체로 포장돼 있으므로 이제 콜렉션과 관련된 동작은 근거지가 마련된셈이다.  
	필터가 이 새 클래스의 일부가 됨을 알 수 있다.  
	필터는 또한 스스로 함수 객체가 될 수 있다.  
	또한 새 클래스는 두 그룹을 같이 묶는다든가 그룹의 각 원소에 규칙을 적용하는 등의 동작을 처리할 수 있다.  
	이는 인스턴스 변수에 대한 규칙의 확실한 확장이지만 그 자체를 위해서도 중요하다.  
	콜렉션은 실로 매우 유용한 원시 타입이다.  
	많은 동작이 있지만 후임 프로그래머나 유지보수 담당자에 의미적 의도나 단초는 거의 없다. - 소트웍스 앤솔로지 객체지향 생활체조편

Collection을 Wrapping하면서, 그 외 다른 멤버 변수가 없는 상태를 일급 컬렉션이라고 합니다.

### 일급 컬렉션의 장점
1. 비즈니스에 종속적인 자료구조
2. Collection의 불변성을 보장
3. 상태와 행위를 한 곳에서 관리
4. 이름이 있는 컬렉션

## 실전 예제
백문이 불어일타! 제가 사용하던 코드에서 직접 클래스에 종속되어 있던 컬렉션들을 Wrapping하며 일급 컬렉션으로 변환하면서 일급 컬렉션의 장점을 한 번 느껴봅시다!

```java
public class SoptampPartRankCalculator {  
  
    private final List<SoptampUserInfo> userInfos;  
  
    private final HashMap<String, Long> partScores =  
            new HashMap<>(Map.of(  
            Part.SERVER.getPartName(), 0L,  
            Part.WEB.getPartName(), 0L,  
            Part.DESIGN.getPartName(), 0L,  
            Part.ANDROID.getPartName(), 0L,  
            Part.IOS.getPartName(), 0L,  
            Part.PLAN.getPartName(), 0L  
    )); // 문제점 1 final을 달고 있어 불변인척 하는 HashMap
  
    private final List<Part> partReturnOrder = List.of(  
            Part.PLAN, Part.DESIGN, Part.WEB, Part.IOS, Part.ANDROID, Part.SERVER  
    );  
  
    public List<PartRank> calculatePartRank() {  
        userInfos.forEach(this::calculatePartScore);  
        return partReturnOrder.stream().map(part -> PartRank.builder()  
                .part(part.getPartName())  
                .rank(getTargetPartRank(partScores.get(part.getPartName())))  
                .points(partScores.get(part.getPartName()))  
                .build()).toList();  
    }  
  
    private void calculatePartScore(SoptampUserInfo userInfo) {  
        String nickname = userInfo.getNickname();  
        partReturnOrder.forEach(part -> {  
            if(nickname.startsWith(part.getPartName())){  
                this.putPartScore(part.getPartName(), userInfo.getTotalPoints());  
            }  
        });  
    }  
  
    private void putPartScore(String partName, Long point) {  
        partScores.put(partName, partScores.get(partName) + point);  
    }  
  
    private int getTargetPartRank(Long targetPartPoint) {  
        int rankPoint = 1;  
  
        for (Long partScore : partScores.values()) {  
            if (targetPartPoint < partScore) {  
                rankPoint++;  
            }  
        }  
        return rankPoint;  
    }  
}
```