# 들으면서 깨달은 것
랭킹 시스템도 Redis로 구현하면 좋겠다!
파트별 랭킹 및 사람 별 랭킹 
레디스의 sorted set을 이용해보자!

## Sorted Sets
Sorted Sets의 score는 double 타입이기 때문에, 값이 정확하지 않을 수 있다.
클라이언트(자바스크립트)에서는 실수가 표현할 수 없는 정수값들이 존재할 수 있다. (Long은 String으로 보내야한다.)

## Collection 주의 사항
- 하나의 컬렉션에 너무 많은 아이템을 담으면 좋지 않음
	- 10000개 이하 몇천개 수준으로 유지하는게 좋은
- Expire은 Collection의 item 개별로 걸리지 않고 전체 Collection에 대해서만 걸림
	- 즉 해당 10000개의 아이템을 가진 Collection에 expire가 걸려있다면 그 시간 후에 10000개의 아이템이 모두 삭제됨

## 메모리 관리
- Physical Memory 이상을 사용하면 Redis에서 문제가 발생한다.
	- Swap이 있다면 Swap 사용으로 해당 메모리 Page 접근시마다 늦어지게 된다.
	- Swap이 없다면 Redis가 멈출 수 있음
![[Pasted image 20240910235436.png]]
Maxmemory를 설정하더라도 메모리 단편화로 인해 이보다 더 사용할 가능성이 있어. RSS 값을 모니터링 해야한다.

- 큰 메모리를 사용하는 instance 하나보다는 적은 메모리를 사용하는 instance 여러개가 안전하다.
![[Pasted image 20240911162749.png]]

## 메모리가 부족할 때는
- 좀 더 메모리가 많은 장비로 migration한다 (메모리가 빡빡하면 문제가 발생할 수 있어 75%정도 사용할 때 migration한다)
- 있는 데이터를 줄인다. (swap을 이미 사용중이면 프로세스를 재시작 한다.)
### 메모리를 줄이기 위한 설정
- 기본적으로 Collection들은 아래와 같은 자료구조를 사용
	- Hash -> HashTable을 하나 더 사용
	- Sorted Set -> Skiplist와 HashTable을 이용
	- Set -> HashTable 사용
- 속도가 조금 느리지만 메모리를 덜 잡아먹는 Ziplist를 이용하는 방안도 있음
![[Pasted image 20240911163319.png]]
## Redis가 동시에 처리할 수 있는 명령
- get/set은 초당 10만 TPS 이상 가능하다
- redis는 single thread이기 때문에 O(N) 관련 명령어를 주의해야 한다.
### 사용하면 안되는 명령
KEYS => scan 명령으로 변경할 수 있음
FLUSHALL, FLUSHDB
Delete Collections (1-2초 걸림)
Get All Collections

### Collection의 모든 item을 가져와야 할 때
Collection의 일부만 가져온다 (Sorted Set 이용)
큰 Collection을 작은 여러개의 Collection으로 나눠서 저장한다. (하나당 몇천개 안쪽으로 저장한다.)

# 데이터 분산 방법
모듈러 연산을 사용시에는 서버가 한 대가 추가되거나 삭제될 때 문제가 발생할 수 있다.

### Consistent Hashing
자신의 해시 값보다 크면서 가장 가까운 서버로 이동한다.

Consistent Hashing을 이용하면 서버가 4대일 때 1대가 고장나면 1/4만 이동해도 되고, 서버가 3대일 때 1대가 추가되어도 1/4만 이동해도 된다.

## shading
데이터를 어떻게 나눌 것인가 = 데이터를 어떻게 찾을 것인가
### Range
샤딩의 가장 쉬운 방법으로 특정 Range를 정의하고 해당 Range에 속하면 거기에 저장
#### 단점
서버의 상황에 따라서 노는 서버와 바쁜 서버의 차이가 날 수 있음
그렇다고 놀고 있는 서버에 데이터를 넣기도 어려움
### Modular
한 대씩 추가가 되면 Modular는 좋은 성능을 내기 어렵다.
하지만 Modular는 2의 배수로 증가할 때 좋은 성능을 낼 수 있다.
