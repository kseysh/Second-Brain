Binary Tree가 자신의 key값을 기준으로 자식의 key 값 범위를 지정하는 것 처럼, 
B Tree는 자녀 노드의 최대 개수를 늘리기 위해서 한 노드에 key를 하나 이상 저장하고, 
key를 오름차순으로 정렬해 
정렬된 순서에 따라 자녀 노드들의 key값 범위를 결정한다.
=> BST를 일반화한 Tree
![[Pasted image 20250509212757.png|200]]

## B Tree 주요 파라미터
M : 각 노드의 최대 자녀 노드 수
=> 최대 M개의 자녀를 가질 수 있는 B Tree를 M차 B Tree라고 한다.
M-1 : 각 노드의 최대 key 수
⌈M/2⌉ : 각 노드의 최소 자녀 노드 수 (root node, leaf node 제외)
⌈M/2⌉ - 1: 각 노드의 최소 key 수 (root node 제외) 

## B Tree 규칙
internal 노드의 key 수가 x개라면, 자녀 노드의 수는 언제나 x+1개다.
모든 leaf 노드들은 같은 레벨에 있다 (balanced tree)
### 삽입
데이터 추가는 항상 leaf노드에 한다.
노드가 넘치면 가운데 key를 기준으로 좌우 key들은 분할하고 가운데 key는 승진한다.
#### example
![[Pasted image 20250509221058.png|300]]
여기서 70을 넣으면
![[Pasted image 20250509221122.png|300]]
leaf 노드에 70넣기 -> 70 승격 50, 90 분리
### 삭제
데이터 삭제도 항상 leaf 노드에서 발생한다.
삭제 후 최소 key 수(⌈M/2⌉ - 1)보다 적어졌다면 재조정한다.
- 재조정 과정
1. key 수가 여유있는 형제의 지원을 받는다
	1. 왼쪽 형제가 여유가 있으면
		- 동생의 가장 큰 key를 부모 노드의 나와 동생 사이에 둔다
		- 원래 그 자리에 있던 key는 나의 가장 왼쪽에 둔다
	2. 형이 여유가 있으면
		- 형의 가장 작은 key를 부모 노드의 나와 형 사이에 둔다
		- 원래 그 자리에 있던 key는 나의 가장 오른쪽에 둔다.
2. 1번이 불가능하면 부모의 지원을 받고 형제와 합친다.
3. 2번 후 부모에 문제가 있다면 거기서 다시 재조정한다.
#### example 1
![[Pasted image 20250509222436.png|200]]
![[Pasted image 20250509222500.png|200]]
#### example 2
![[Pasted image 20250509222843.png|200]]
![[Pasted image 20250509222859.png|200]]
#### example 3
