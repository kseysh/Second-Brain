> RESTful api란?

###### RESTful api란?
HTTP URI를 통해 자원을 표시하고 HTTP Method를 통해 자원에 대한 처리를 표현합니다. 사람이 읽을 수 있는 API라는 것이 특징입니다. HTTP를 사용하기 때문에 HTTP의 특성을 그대로 반영합니다.
###### CORS란?
서로 다른 도메인간에 자원을 공유하는 것을 뜻합니다. 대부분의 브라우저에서는 이를 기본적으로 차단하며, 서버측에서 헤더를 통해서 사용가능한 자원을 알려줍니다.
###### 트랜잭션이란?
트랜잭션이란 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위라고 할 수 있으며, 트랜잭션에는 여러개의 연산이 수행될 수 있습니다.

트랜잭션은 수행중에 한 작업이라도 실패하면 전부 실패하고, 모두 성공해야 성공이라고 할 수 있습니다.
###### ACID란?
ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질

- Atomicity(원자성): 트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 한 연산이라도 실패하면 트랜잭션 내의 모든 연산은 실패해야 합니다.
- Consistency(일관성): 트랜잭션은 유효한 상태로만 변경될 수 있습니다.
- Isolation(고립성): 트랜잭션은 동시에 실행될 경우 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행되어야 합니다.
- Durability(내구성): 트랜잭션이 커밋된 이후에는 시스템 오류가 발생하더라도 커밋된 상태로 유지되는 것을 보장해야 합니다. (일반적으로 비휘발성 메모리에 데이터가 저장되는 것을 의미)
###### RDBMS vs NOSQL에 대해서 설명해주세요.
RDBMS는 데이터베이스를 이루는 객체들의 릴레이션을 통해서 데이터를 저장하는 데이터베이스입니다. SQL을 사용해 데이터의 저장, 질의, 수정, 삭제를 할 수 있으며 데이터를 효율적으로 보관하는 것을 목적으로 하고 구조화가 굉장히 중요합니다.

장점으로는 명확한 데이터 구조를 보장하고, 중복을 피할 수 있습니다.

NOSQL은 RDBMS에 비해 자유로운 형태로 데이터를 저장합니다. 또한 수평확장을 할 수 있고 분산처리를 지원합니다. 다양한 형태의 NOSQL 데이터베이스가 있고, 대표적으로 key-value store, bigtable, dynamo, document db, graph db 등이 있습니다.

둘은 대체될 수 있는 것이 아니고, 각각 필요한 시점에 적절히 선택해서 사용해야 합니다. 둘 다 같이쓰는 상호보완적인 존재가 될 수도 있습니다.
###### Session 대신 JWT를 사용한 이유
Session 저장소 방식은 서버에서 session에 대한 정보를 통제해야 하므로 stateful하다.
현재는 단일 서버이지만 나중에 다중 서버를 운영하게 되면 redis같은 in-memory DB를 사용하게 되었을 때 사용자가 로그인한 서버가 아닌 다른 서버로 요청이 요청이 보내지면 다시 재로그인해야한다. 그렇다고 DB에 저장하게 되면 로그인 정보를 DB에 저장해야 해서 무겁고, 매 인증마다 DB에서 인증정보를 가져와야 해서 연결 비용이 커지게 된다
JWT는 클라이언트가 토큰을 보관하여 비교적 서버 부하가 덜하지만 Token을 검증하는 것이지 해당 토큰을 관리하는 것이 아니기 때문에 세션보다 보안상 취약하고 세션에서 가능한 토큰 만료같은 기능이 불가능하다.
세션은 JWT보다 보안에 강하고, 세션의 추가적인 기능을 사용할 수 있지만 느리고 stateful하다. 따라서 세션의 추가기능이 필요하거나 보안이 중요하다면 Session을 사용하고, 이외에는 scale out이 편한 JWT를 사용하는 것이 좋을 듯?
[[서버 인증의 종류]]
###### Redis가 무엇이고 Redis를 사용한 이유
[[In-memory DB]]
###### OAuth란?
OAuth는 제3자 인증방식 입니다. 기본적으로 사용자는 서버를 신뢰할 수 없습니다. 그렇기 때문에, 민감정보를 작성하는 것을 꺼립니다. 서버측에서도 마찬가지 입니다. 사용자의 민감정보를 관리하는 것은 리소스가 필요합니다.

그래서 OAuth를 사용해서 신뢰할 수 있는 서버에게 정보를 맡겨놓고 접근할 수 있는 권한을 주는 것이라고 이해하면 됩니다. 그러면 사용자 측에서는 민감정보를 굳이 입력하지 않고도 서비스를 사용할 수 있고, 서버측에서도 민감정보를 굳이 관리하지 않아도 되기 때문에 이점이라고 볼 수 있습니다.
###### 오버로딩과 오버라이딩
오버라이딩: 상위 클래스의 메소드를 재정의 하는 것을 의미합니다. 또, 런타임 다형성이기도 합니다.

오버로딩: 같은 클래스 내에서 동일한 메소드 이름을 가지지만, 매개변수의 타입, 개수가 다르게 구현할 수 있는 것을 의미하며 컴파일 타임 다형성이기도 합니다. 따라서 오버라이딩 될 수 있습니다.
###### 인터페이스와 추상클래스의 차이
추상클래스는 객체의 추상적인 상위 개념으로 공통된 개념을 표현할 때 사용합니다. 단일 상속만 가능합니다. 추상클래스를 상속하는 집합간에는 연관관계가 있습니다.

인터페이스는 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용합니다. 다중 상속이 가능합니다. 인터페이스를 구현하는 집합간에는 관계가 없을 수 있습니다.
###### 객체 지향이란?
객체지향을 정의하면, 의존성 관리입니다.

객체지향으로 의존성을 관리함으로써 변경 영향을 최소화하고 독립적인 배포가 가능해지며 독립적인 개발이 가능해집니다.
###### SOLID(객체지향 5대원칙)에 대해서 설명해주세요.  

SRP(단일책임원칙)은 한 클래스의 하나의 책임만 가져야 합니다.
OCP(개방-폐쇄 원칙)은 확장에는 열려 있으나 변경에는 닫혀 있어야 하며, 다형성을 활용해야 합니다.
LSP(리스코프 치환 원칙)은 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야하는 원칙으로 상위 타입을 상속해서 재정의 했을 때 프로그램이 깨지지 않아야 합니다.
ISP(인터페이스 분리 원칙)은 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안되는 원칙입니다. 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 더 낫습니다. 즉, 비대한 인터페이스보단 더 작고 구체적인 인터페이스로 분리해야합니다.
DIP(의존관계 역전 원칙)은 추상적인 것은 자신보다 구체적인 것에 의존하지 않고, 변화하기 쉬운 것에 의존해서는 안된다는 원칙입니다. 구체적으론 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 하는 원칙입니다.
###### 원시타입과 참조타입의 차이
원시타입은 null을 지닐 수 없지만, 참조타입은 null을 지닐 수 있음
###### 동일성과 동등성
동일성은 객체의 주소 비교 (\=\=), 동등성은 객체의 값 비교 (equals())
###### 질
답
###### 질
답
###### 질
답
###### 질
답
###### 질
답
###### 질
답
###### 질
답
###### 질
답

###### 질
답
