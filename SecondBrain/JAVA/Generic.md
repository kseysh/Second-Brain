# 제네릭
> 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법

## 제네릭의 장점
- 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있다 => 런타임에 발생할 수 있는 타입에러를 컴파일전에 검출할 수 있기 때문이다.
- 클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없다. 즉, 관리하기가 편하다.
- 비슷한 기능을 지원하는 경우 코드의 재사용성이 높아진다.
## 제네릭의 단점
- 반환값에 대한 타입 변환 및 타입 검사에 들어가는 노력을 줄일 수 있다.

## 제네릭의 예시
```java
class MyArray<T> {

    T element;

    void setElement(T element) { this.element = element; }

    T getElement() { return element; }

}
```
예시에서 사용된 'T'를 타입 변수라고 하며, 임의의 참조형 타입을 의미한다.

## 제네릭의 특징 및 사용법
- 클래스 혹은 메소드에 선언할 수 있다.
- 동시에 여러 타입을 선언할 수 있다.
- 와일드 카드를 이용하여 타입에 대하여 유연한 처리를 가능케 한다.
- 제네릭 선언 및 정의시에 타입의 상속관계를 지정할 수 있다.

### 와일드 카드란?
제네릭 타입을 더 유연하게 다룰 수 있게 하는 기능으로 크게 세 가지 종류가 있다.

#### 물음표(`?`) 와일드카드:
`<?>`를 사용하여 "알 수 없는 타입"을 나타냅니다. 이것은 모든 제네릭 타입을 나타내며, 제네릭 타입 파라미터에 대한 정보를 요구하지 않습니다.
    
#### 상한 와일드카드(`? extends T`):
`? extends T` 형태로 사용되며, T 타입과 T의 하위 타입들만을 나타냽니다. 이것은 읽기 작업(read-only)에 사용됩니다. 리스트나 컬렉션을 읽기 전용으로 다룰 때 유용합니다.
    
#### 하한 와일드카드(`? super T`):
`? super T` 형태로 사용되며, T 타입과 T의 상위 타입들만을 나타냅니다. 이것은 쓰기 작업(write-only)에 사용됩니다. 리스트나 컬렉션에 요소를 추가할 때 유용합니다.
### 와일드 카드의 예시
```
// 물음표 와일드카드: 모든 제네릭 타입을 나타냄
public void printList(List<?> list) {
    for (Object item : list) {
        System.out.print(item + " ");
    }
}

// 상한 와일드카드: T와 T의 하위 타입만 허용 (읽기 전용)
public double sumList(List<? extends Number> numbers) {
    double sum = 0;
    for (Number number : numbers) {
        sum += number.doubleValue();
    }
    return sum;
}

// 하한 와일드카드: T와 T의 상위 타입만 허용 (쓰기 전용)
public void addNumbers(List<? super Integer> list) {
    list.add(42);
}
```

## 제네릭의 제거 시기
자바 코드에서 선언되고 사용된 제네릭 타입은 컴파일 시 컴파일러에 의해 자동으로 검사되어 타입 변환된다.

그리고서 코드 내의 모든 제네릭 타입은 제거되어, 컴파일된 class 파일에는 어떠한 제네릭 타입도 포함되지 않게 된다.

이런 식으로 동작하는 이유는 제네릭을 사용하지 않는 코드와의 호환성을 유지하기 위해서이다.