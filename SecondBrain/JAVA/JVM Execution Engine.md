런타임 데이터 영역에 배치된 바이트코드를 명령어 단위로 읽어서 실행

### Interpreter
바이트 코드 명령어를 하나씩 읽어서 해석하고 실행
인터프리터는 바이트코드를 해석하고, JVM 내부에 이미 기계어로 컴파일된 구현을 실행한다

#### Interpreter 과정
Fetch → Decode → Execute  
- Fetch(PC가 가리키는 Opcode를 읽음) 
- Decode(Opcode의 피연산자 가져옴) 
- Execute(Opcode의 실제 구현을 실행)

### JIT 컴파일러
반복되는 코드(hot spot)을 발견하여 바이트 코드 전체를 컴파일하여 Native Machine Code(≒ 기계어)로 변경하고 이후에 메서드를 캐싱해두었다가 네이티브 코드로 직접 실행하는 방식 (마치... Interpreter의 Cache 개념..)

네이티브 머신 코드? =>CPU가 직접 실행하는 코드로, 내부적으로는 기계어이며 JIT 컴파일 결과물 순수한 기계어보다 약간 더 많은 런타임 관리 정보 포함 (메타 정보, GC용 맵... 등등)  
#### 주요 최적화 기법 
- 인라이닝: 메서드 호출을 제거하고, 호출부에 메서드 바디를 직접 삽입 
- 루프 언롤링: loop를 펼쳐 루프 오버헤드 제거 
- 분기 예측 기반 최적화: 자주 사용하느 분기 경로를 기준으로 코드 생성 (jump가 적도록..)
### GC
Heap 영역에서 사용하지 않는 메모리 회수

## AOT(Ahead Of Time) 컴파일 방식을 사용하지 않는 이유
JIT 덕분에 실제 실행 빈도 및 실제 분기 패턴을 알게 되어 정적 컴파일보다 빠를 수도 
 - 미리 컴파일을 진행하면 컴파일 비용 낭비 및 메모리 낭비, 시작 시간 증가 발생  

- 실행 전에는 최적화에 필요한 실제 실행시 알 수 있는 정보가 없다.