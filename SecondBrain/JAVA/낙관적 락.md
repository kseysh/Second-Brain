## 낙관적 락
공유 데이터에 대한 충돌 가능성을 낮게 가정하고 작업을 수행하는 방식으로, 자원의 잠금을 최소화하여 성능을 높이는데 초점을 둔다.

### 낙관적 락 작동 방식
- 읽기 작업 시작 (락을 걸지 않음)
	- 데이터를 읽으면서 락을 걸지 않고, 현재 데이터가 유효하다는 가정을 한다.
	- `tryOptimisticRead()` 메서드를 호출하면 현재 데이터를 읽기 위한 스탬프라는 상태 값을 반환한다.
- 검증
	- 값을 읽어온 후, `validate(stamp)` 메서드를 상요해 데이터가 유효한지 확인한다.
	- 이 단계를 통해 데이터가 작업 중에 다른 쓰기 작업에 의해 수정되지 않았는지 확인한다.
- 락이 유효하지 않은 경우
	- 충돌이 발생했다고 판단되면, 읽기 락을 획득하여 데이터를 다시 읽는다.
- 락 해제
	- 읽기 락을 사용한 경우, 작업이 끝나면 락을 해제 한다.

### 예제
```java
int getBalance() {
    long stamp = lock.tryOptimisticRead(); // 낙관적 읽기 lock을 건다.
    int curBalance = this.balance; // 공유 데이터인 balance를 읽어온다.

    if (!lock.validate(stamp)) { // 데이터가 유효한지 확인
        stamp = lock.readLock(); // // 데이터가 변경된 경우 읽기 락 획득

        try {
            curBalance = this.balance; // 락이 유효하지 않은 경우 데이터를 다시 읽음
        } finally {
            lock.unlockRead(stamp); // 락 해제
        }
    }

    return curBalance; // 낙관적 읽기 lock이 풀리지 않았으면 곧바로 읽어온 값을 반환
}
```

## 장단점
### 장점
- 성능 향상 - 데이터 충돌이 적을 때 락을 걸지 않아 성능 개선
- 스레드 안전 - 데이터 변경을 확인하는 검증 단계로 인해 안전성 유지
### 단점
- 충돌 비용 - 데이터가 자주 변경되면 재시도 횟수가 증가해 성능 저하

따라서 쓰기 작업이 드물게 발생하는 읽기 위주의 작업에서 적합하다.