# 정리
### Table
Table은 Cook(생산자)와 Customer(소비자)의 공유 객체이다.
add와 remove는 [[임계 영역]]이므로 락을 얻어야만 수행될 수 있다.
#### add()
Table은 공유 객체가 설정한 MAX_FOOD보다 많으면 add 호출시에 현재 table 스레드를 waiting pool에 넣고 0.5초 기다린다.
음시깅 MAX_FOOD 이상일 때, wait으로 Cook이 lock을 풀고 기다리게 한다.
요리사가 음식을 추가하면, `notify`로 손님에게 알린다.
#### remove()
Table은 공유 객체의 변수가 0보다 작으면 remove 호출시에 현재 table 스레드를 waiting pool에 넣고 0.5초 기다린다.
음식이 없을 때,wait으로 Customer가 lock을 풀고 기다리게 한다
음식이 MAX_FOOD일 때 음식을 먹어 MAX_FOOD보다 적어지면, notify로 요리사에게 알린다.
### Cook
Cook은 0.01초당 한 번 `add()`를 호출해 랜덤한 dishName을 추가한다.
### Customer
Customer는 table에게서 0.1초당 한 번 `remove()`를 호출해 랜덤한 dishName을 제거한다.
## Cook
```java
public class Cook implements Runnable {  
    private final Table table;  
    public Cook(Table table){  
        this.table = table;  
    }  
  
    @Override  
    public void run() {  
        while (true) {  
            int idx = (int) (Math.random() * table.dishNum());  
            table.add(table.dishNames[idx]);  
            try { Thread.sleep(10); } catch (InterruptedException e) { }  
        }  
    }  
}
```

## Table
```java
public class Table {  
    String[] dishNames ={ "donut", "donut", "burger"};  
    private final int MAX_FOOD = 6;  
    private ArrayList<String> dishes = new ArrayList<>();  
  
    public synchronized void add(String dish) { // Table 인스턴스에 lock을 건다. 
        while(dishes.size() >= MAX_FOOD){  
            String name = Thread.currentThread().getName();  
            System.out.println(name+" is waiting");  
            try {  
                wait();  
                // wait를 이용해 lock을 풀고 waiting pool에 들어가 있으면, 다른 메서드가 notify를 통해 wait 상태를 풀어준다.
                Thread.sleep(500);  
            } catch (InterruptedException e){}  
        }  
  
        dishes.add(dish);  
        notify();  // waiting 상태에 있는 스레드가 있다면 wait 상태를 풀어준다
        
  
        System.out.println("Dishes : " + dishes.toString());  
    }  
  
    public void remove(String dishName) {  
        synchronized(this) {  // Table 인스턴스에 lock을 건다.
            String name = Thread.currentThread().getName();  
            while (dishes.size() == 0) {  
                System.out.println(name+" is waiting");  
  
                try {  
                    wait();  
                    Thread.sleep(500);  
                }  
                catch (InterruptedException e) { }  
            }  
  
            while (true) {  
                for(int i = 0; i < dishes.size(); i++) {  
                    if (dishName.equals(dishes.get(i))) {  
                        dishes.remove(i);  
                        notify();  
                        return;  
                    }  
                }  
  
                try {  
                    System.out.println(name+" is waiting");  
                    wait();  
                    Thread.sleep(500);  
                } catch (InterruptedException e){}  
            }  
        }
    }  
  
    public int dishNum(){ return dishNames.length; }  
}
```
## Customer
```java
public class Customer implements Runnable {  
    private final Table table;  
    private final String food;  
  
    public Customer(Table table, String name){  
        this.table = table;  
        this.food = name;  
    }  
  
    public void run(){  
        while(true) {  
            try { Thread.sleep(100); } catch (InterruptedException e){}  
            String name = Thread.currentThread().getName();  
            table.remove(food);  
            System.out.println(name +" ate a " + food);  
        }  
    }  
}
```
## Main
```java
public class Main {  
  
    public static void main(String[] args) throws InterruptedException {  
        Table table = new Table();  
        new Thread(new Cook(table), "COOK1").start();  
        new Thread(new Customer(table, "donut"), "CUST1").start();  
        new Thread(new Customer(table, "burger"), "CUST2").start();  
  
        Thread.sleep(2000);  
        System.exit(0);  
    }  
}
```