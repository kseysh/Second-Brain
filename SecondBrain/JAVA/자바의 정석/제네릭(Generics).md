컴파일시 타입을 체크해주는 기능
객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여준다. (하나의 컬렉션에는 대부분 한 종류의 객체만 저장한다.)

## 제네릭 클래스의 선언
클래스를 작성할 때, Object 타입 대신 T와 같은 타입변수를 사용한다.
![[Pasted image 20240425195352.png]]
참조변수, 생성자에 T대신 실제 타입을 지정하면 형변환을 생략할 수 있다.

## 제네릭 용어
- Box\<T>: 제네릭 클래스. 
- T 타입 변수 또는 타입 매개변수
- 원시 타입

## 제네릭 제약사항
- static멤버에는 타입 변수 T를 사용할 수 없다.
- 제네릭 타입의 배열 T\[]를 생성하는 것은 허용되지 않는다.

## 제네릭 클래스의 객체 생성과 사용
- Box\<T>의 객체 생성, 참조변수와 생성자에 대입된 타입이 일치해야 한다.
![[Pasted image 20240425195944.png]]
- 두 제네릭 클래스가 상속 관계이고, 대입된 타입이 일치하는 것은 OK
![[Pasted image 20240425200029.png]]
- 대입된 타입과 다른 타입의 객체는 추가할 수 없다.

## 제네릭 클래스 제한두기
- 제네릭 타입에 extends를 사용하여 특정 타입의 자손들만 대입할 수 있도록 제한할 수 있다.
![[Pasted image 20240425200348.png]]
- add()의 매개변수의 타입 T도 Fruit와 그 자손 타입이 될 수 있다.
![[Pasted image 20240425200435.png]]
- 인터페이스의 경우에도 'implements'가 아닌, 'extends'를 사용한다.
![[Pasted image 20240425200504.png]]

## 와일드 카드 '`?`'
제네릭 타입에 와일드 카드를 쓰면, 여러 타입을 대입가능
단, 와일드 카드에는 \<? extends T & E>와 같이 '`&`'를 사용불가
![[Pasted image 20240425200650.png]]

## 제네릭 메서드
반환타입 앞에 제네릭 타입이 선언된 메서드
![[Pasted image 20240425201253.png]]
클래스의 타입 매개변수\<T>와 메서드의 타입 매개변수 \<T>는 별개이다.
![[Pasted image 20240425201352.png]]
제네릭 메서드를 호출할 때, 타입 변수에 타입을 대입해야 한다. (하지만 대부분의 경우, 추정이 가능하므로 생략이 가능하다.)
![[Pasted image 20240425201425.png]]

## 제네릭 타입의 형변환
- 제네릭 타입과 원시 타입간의 형변환은 불가능하다.
![[Pasted image 20240425201830.png]]
- 와일드 카드가 사용된 제네릭 타입으로는 형변환 가능
![[Pasted image 20240425201914.png]]

## 제네릭 타입의 제거
- 컴파일러는 제네릭 타입을 제거하고, 필요한 곳에 형변환을 넣는다.
![[Pasted image 20240425202701.png]]
