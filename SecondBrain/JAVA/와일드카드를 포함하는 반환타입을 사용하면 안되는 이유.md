이 문장은 Java에서 와일드카드를 포함하는 반환 타입이 어떻게 좁혀질 수 없는지에 대한 내용을 설명하고 있습니다. 개발자의 의도가 아마도 다른 것이었을 것이라고 언급하며, 이러한 문제의 핵심이 타입 변이에 있다고 설명하고 있습니다.

1. **Type Variance (타입 변이):**
    
    - 입력 위치에서의 표현(예: 메소드에 전달되는 인수)은 메소드에서 기대하는 타입보다 구체적인 타입을 가질 수 있으며, 이를 공변성(covariance)이라고 합니다.
    - 출력 위치에서의 표현(예: 메소드에서 반환 결과를 받는 변수)은 메소드의 반환 타입보다 일반적인 타입을 가질 수 있으며, 이를 반공변성(contravariance)이라고 합니다.
    - 이러한 문제는 Liskov 치환 원칙에 기인합니다.
2. **Java에서의 제네릭 타입 매개변수의 무변성:**
    
    - Java에서는 제네릭 타입의 타입 매개변수가 무변성(invariant)이기 때문에 기본적으로 입력과 출력 위치에서 동시에 발생할 수 있습니다.
    - 예를 들어, java.util.List 인터페이스의 `T get()` (출력 위치) 및 `add(T element)` (입력 위치) 메소드가 무변성인 전형적인 예입니다.
3. **와일드카드를 사용한 Covariance 및 Contravariance:**
    
    - 와일드카드를 사용하면 타입 매개변수가 한 위치에서만 나타나는 상황에서 covariance나 contravariance를 달성할 수 있습니다.
    - `<? extends Foo>`는 covariance(입력 위치)에 사용되며, `<? super Foo>`는 contravariance(출력 위치)에 사용됩니다.
4. **메소드 반환 타입의 Covariance 문제:**
    
    - 하지만 메소드 반환 타입은 입력 위치가 아니기 때문에 covariance가 적용되지 않습니다.
    - 또한 contravariance도 효과가 없습니다. 반환 값의 수신자가 contravariant여야 하는데, Java에서는 사용 지점 변이(use-site variance)라 불리는 것입니다.
5. **결론적으로:**
    
    - 와일드카드를 포함하는 반환 타입은 일반적으로 잘못된 것으로 간주됩니다. 이는 일반적으로 오류의 원인이 됩니다.