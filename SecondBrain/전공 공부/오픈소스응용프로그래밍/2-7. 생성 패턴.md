---
sticker: emoji//1f3ed
---
# 생성 패턴
- **클래스의 인스턴스가 어떻게 생성되는가를 추상화 하여 나타낸 것**
- 객체가 생성, 합성, 표현되는 방식에 관계없이 시스템을 독립적으로 생성할 수 있도록 지원 
- 상속 개념을 사용하여 클래스의 내용을 변경하는 방법으로 정의 
- 객체의 생성을 다른 객체로 위임하는 방법으로 정의
## Factory method
>객체를 만들기 위한 인터페이스를 정의하되, 하위 클래스가 인스턴스를 생성하는 클래스를 결정하도록 한다.

[[팩토리 메서드]]

아래에서는 Product 인터페이스와 Creator 인터페이스를 만들고, 
Creator는 FactoryMethod를 만들어둔다.
ConcreateCreator는 FactoryMethod를 overriding하여 ConcreteProduct를 만든다.
![[Pasted image 20231208120315.png]]
![[Pasted image 20231208120341.png]]
### Factory method의 문제 및 동기
- 응용 클래스에서는 언제 문서가 생성되어야 하는지는 알고 있지만, 어떤 종류의 문서를 생성해야 하는지 모르는 경우가 있음
- **인스턴스 생성을 하위 클래스에 위임함으로써 문서 생성을 요청하지만, 실제 문서가 생성되는 시점은 하위 클래스에 의해 연기될 수 있음**
### 적용 대상
- **프로젝트의 코드가 함께 작동해야 하는 객체들의 정확한 유형들과 의존관계들을 미리 모르는 경우 사용**
- 프로젝트의 라이브러리 또는 프레임워크의 사용자들에게 내부 컴포넌트들을 확장하는 방법을 제공하고 싶을 때 사용
- 기존 객체들을 재사용하고 싶을 때 사용

>Creator / ConcreteCreator
  Product / ConcreteProduct 
  로 나눈다.
![[Pasted image 20231101130132.png]]

크리에이터는 추상 메서드를 통해 메서드의 자체 버전들을 구현하도록 강제할 수 있음
혹은 디폴트 제품 유형을 반환하도록 할 수도 있음
### 구현 방법
모든 제품이 같은 인터페이스를 따르도록 인터페이스를 생성한다.
크리에이터 클래스를 만들고 내부에 빈 팩토리 메서드를 만든다.
구체 크리에이터 클래스에서 구체 제품을 생성할 수 있게 팩토리 메서드를 오버라이딩한다. 

단계 1) 
	• 모든 제품이 같은 인터페이스를 따르도록 변경 
	• 이 인터페이스는 모든 제품에서 의미가 있는 메서드들을 선언해야 함 
단계 2) 
	• 크리에이터 클래스 내부에 빈 팩토리 메서드를 추가 
	• 이 메서드의 반환 유형은 공통 제품 인터페이스와 일치해야 함
단계 3) 
	• 크리에이터의 코드에서 제품 생성자들에 대한 모든 참조를 찾음 
	• 이 참조들을 하나씩 팩토리 메소드에 대한 호출로 교체하면서 제품 생성 코드를 팩토리 메서드로 추출
단계 4) 
	• 이제 팩토리 메서드에 나열된 각 제품 유형에 대한 크리에이터 자식 클래스들의 집합을 생성한 후, 자식 클래스들에서 팩토리 메서드를 오버라이딩하고 기초 메서드에서 생성자 코드의 적절한 부분들을 추출 
단계 5) 
	• 제품 유형이 너무 많아 모든 제품에 대하여 자식 클래스들을 만드는 것이 합리적이지 않을 경우, 자식 클래스들의 기초 클래스의 제어 매개변수를 재사용할 수 있음 
단계 6)
	• 추출이 모두 끝난 후 기초 팩토리 메서드가 비어 있으면, 해당 팩토리 메서드를 추상화할 수 있음 
	• 팩토리 메서드가 비어 있지 않으면, 나머지를 그 메서드의 디폴트 행동으로 만들 수 있음

### 장단점
#### 장점
크리에이터와 구상 제품들의 결합이 느슨해진다.
단일 책임의 원칙 : 제품 생성 코드를 프로그램의 한 위치로 이동하여 코드를 더 쉽게 유지관리할 수 있다.
개방/폐쇄의 원칙 : 기존 클라이언트 코드를 훼손하지 않고 새로운 유형의 제품을 프로그램에 도입할 수 있다.

# 빌더
[[빌더]]
복합 객체의 생성 과정과 표현 방법을 분리함으로써 동일한 생성 절차를 이용하여 서로 다른 표현을 갖는 객체를 만들 수 있게 제공하는 패턴

제품클래스를 이용하여 공통적인 몸체를 만든다.
Builder 클래스는 제품 클래스에 다른 표현을 가질 수 있도록하는 produce 함수를 만드는 인터페이스를 작성한다..
그리고 concreateBuilder 클래스를 통해 Builder 인터페이스를 구현한다.
Director는 concreateBuilder를 이용하여 제품을 생성하는 함수를 작성한다.
클라이언트는 director클래스에 concreateBuilder를 setter로 주입하여 director가 product를 생성할 수 있도록 한다.
![[Pasted image 20231208131602.png]]
![[Pasted image 20231208131611.png]]
### 적용 대상
- **“점층적 생성자”를 제거하기 위하여 빌더 패턴을 사용** 
- 빌더 패턴은 당신의 코드가 일부 제품의 다른 표현들(예: 석조 및 목조 주택들)을 생성할 수 있도록 하고 싶을 때 사용
- 빌더를 사용하여 복합체 트리들 또는 기타 복잡한 객체들을 생성
### 구현 방법
사용할 수 있는 모든 제품 표현을 생성하기 위한 공통 생성 단계들을 빌더 인터페이스에서 정의한다.
각 제품 표현에 대한 구현 빌더 클래스를 만들고 해당 생성 단계를 구현한다.
디렉터 클래스를 만드는 것을 고려한다 => 이를 통해 제품 제작 방법을 캡슐화 가능
클라이언트는 빌더 객체와 디렉터 객체를 생성해 디렉터 객체에 빌더 객체를 주입한다.
디렉터는 빌더 객체를 이용해 제품을 생성한다. 


단계 1) 
	• 사용할 수 있는 모든 제품 표현을 생성하기 위한 공통 생성 단계들을 명확하게 정의할 수 있는지 확인함 
	• 그렇게 하지 못하면, 패턴 구현을 진행할 수 없음 
• 단계 2) 
	• 기초 빌더 인터페이스에서 이 단계를 선언 
• 단계 3) 
	• 각 제품 표현에 대한 구상 빌더 클래스를 만들고 해당 생성 단계들을 구현 
• 단계 4) 
	• 디렉터 클래스를 만드는 것에 대해 고려함 
	• 같은 빌더 객체를 사용하여 제품을 제작하는 다양한 방법을 캡슐화할 수 있음 
• 단계 5)
	• 클라이언트 코드는 빌더 객체들과 디렉터 객체들을 모두 생성 
	• 제작이 시작되기 전에 클라이언트는 빌더 객체를 디렉터에게 전달해야 함 
	• 일반적으로 클라이언트는 디렉터의 클래스 생성자의 매개변수들을 통해 위 작업을 한 번만 수행
	• 그 후 디렉터는 모든 추가 제작에서 빌더 객체를 사용 
	• 혹은 빌더가 디렉터의 특정 제품 제작 메서드에 전달되는 것 
• 단계 6) 
	• 모든 제품이 같은 인터페이스를 따르는 경우에만 디렉터로부터 직접 생성 결과를 얻을 수 있음 
	• 그렇지 않으면 클라이언트는 빌더에서 결과를 가져와야 함

## 장단점
### 장점
- 객체들을 단계별로 생성하거나 생성 단계들을 연기하거나 재귀적으로 단계들을 실행할 수 있음 
- 제품들의 다양한 표현을 만들 때 같은 생성 코드를 재사용할 수 있음 
- 단일 책임 원칙. 제품의 비즈니스 로직에서 복잡한 생성 코드를 고립시킬 수 있음
### 단점
- 패턴이 여러 개의 새 클래스들을 생성해야 하므로 코드의 전반적인 복잡성이 증가

## 예시
![[Pasted image 20231101155513.png]]