# 객체지향개발 특성
## 추상화
[[추상화]]
## 캡슐화
[[캡슐화]]
데이터 보호, 은닉 
## 상속
[[상속]]
- 파생클래스가 기본클래스 속성을 포함하면서 접근 지정자의 확장이 필요할 수 있다.
- 상속관계의 클래스를 정의할 때는 각 클래스의 기능을 명확히 분류해야 한다. 
- 기본 클래스의 기능을 사용하고자 상속을 무분별하게 하면 난해하고 비효율적인 코드가 될 수 있다.
- 다중상속에 유의해야 한다.
## 다형성
[[다형성]]
다형성을 구현하는 대표적 두 가지 : 오버로딩, 오버라이딩
### 오버로딩
매개변수의 유형 또는 개수는 다르지만, *같은 이름의 메서드를 중복하여 정의*하는 것
ex) 오버로딩 오퍼레이터
매개변수는 같고 리턴 타입만 다르면 오버로딩이 성립되지 않음.
### 오버라이딩
*부모클래스가 가지고 있는 메서드를 하위 클래스가 재정의*해서 사용한다.
부모클래스의 메서드와 메서드 구성요소 모두가 동일해야한다.
메소드명 매개변수 리턴 타입이 모두 같아야한다.

## 정적 바인딩
![[Pasted image 20231012000929.png]]
## 동적 바인딩
![[Pasted image 20231012000944.png]]
# SOLID
[[객체 지향의 5대 설계 원칙 (SOLID)]]

[[단일 책임의 원칙]] : 클래스를 변경해야 하는 이유는 단 하나여야 한다.
- 하나의 클래스는 하나의 역할을 담당하여 하나의 책임을 수행하는데 집중되어야 있어야 한다는 의미
- 클래스의 설계가 변경되어야 할 경우는 한 클래스가 둘 이상의 역할을 책임질 경우이며, 이 때 역할별로 클래스를 각각 설계해주는 것이 바람직함
- 즉, 클래스는 그 책임을 완전히 캡슐화 하는 것.
![[Pasted image 20231012001756.png]]

[[개방 폐쇄의 원칙]] : 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다.

![[Pasted image 20231012001913.png]]
[[리스코브 치환의 원칙]] : 상위 클래스의 객체는 언제나 자신의 하위 클래스의 객체로 대체될 수 있어야 한다.
![[Pasted image 20231012002217.png]]
[[인터페이스 분리 원칙]] : 클라이언트는 자신이 사용하지 않는 메서드와 의존 관계를 맺으면 안 된다.
![[Pasted image 20231012002436.png]]
[[의존성 역전의 원칙]] : 클라이언트는 구체 클래스가 아닌 추상 클래스에 의존해야 한다.
![[Pasted image 20231012004502.png]]
