---
sticker: emoji//1f9d1-200d-2696-fe0f
---
## 화이트 박스 테스팅 기법들 장단점
### 장점
초기에 주어지는 파일이 소프트웨어를 테스트하기에 얼마나 효과적인 파일인지를 평가
코드 어디에서 문제가 일어났는지를 확인
## 퍼징
자동화된 메커니즘을 이용하여 소프트웨어의 취약점을 발견할 수 있는 방법
분석 대상 소프트웨어에 대해 입력 값을 변형하면서 소프트웨어 오류 및 결함을 찾아가는 기술
입력은 파일 기반이거나 네트워크 기반을 주로 사용
### 블랙박스 퍼징
대상 소프트웨어에 대한 이해 없이 퍼징 수행
### 그레이박스 퍼징
대상 소프트웨어에 대해서 사전에 분석된 정보 즉, 데이터 모델을 바탕으로 퍼징을 수행
## 초기 퍼징
무작위 텍스트 시퀀스를 생성해서 반복한다
### 단점
**무작위로 생성된 입력은 소스코드의 제한된 부분만을 다룬다.**
**무작위 입력은 종종 단순한 입력 문법 오류가 있을 가능성이 높기 때문에 빠르게 거부됨. 따라서 많은 테스트 케이스들이 의미 없이 버려지게 됨**
무작위로 생성된 텍스트가 문법 검사를 통과할 확률은 극히 낮음
## 돌연변이 기반 퍼징
**유효한 입력 테스트 케이스들의 집합으로 시작한다.**
**기존 입력에 작은 변경을 반복적으로 도입한다.**
- 오류를 야기시키는 입력들은 유효한 입력과 비슷한 경우가 많기 때문
- 입력의 영역은 몇 개의 프로그램 구성 요소와 연관되어 있고, 따라서 이런 방법이 문제를 찾는데 도움이 되기 때문
### 돌연변이 생성 연산 종류 
![[Pasted image 20231130094716.png]]
fine-grained : 프로그램을 세밀하게 나눈다.
Coarse-grained : 프로그램을 큰 덩어리로 나눈다.
## 그레이박스 퍼징
퍼징에 프로그램의 실행 정보를 일부만 사용하는 것
그레이박스 퍼징의 단계
- 유효한 입력을 나타내는 테스트 케이스 집합(seed)으로부터 시작 
- 기존의 입력에 반복적으로 작은 변경을 도입하면서 새로운 동작이 나타나기를 기대함 
- 새로운 동작을 탐색하는 돌연변이 입력이 있다면, 이를 시드로 추가함 
	- 새로운 구조적 테스트 요구사항을 포함하는 경우에만
## AFL++
AFL: 테스트 케이스의 코드 커버리지를 효과적으로 높이기 위해 유전 알고리즘을 사용하는 무료 소프트웨어 퍼저

## 정적 분석
### 테스팅의 장단점
- 테스트: 동적으로 프로그램의 정확성을 확인하기 위해 입력 값 집합을 사용
- 장점 : 특정한 실패를 초래하는 입력 값을 구체적으로 알 수 있으며 이를 통해 문제를 입증하여 수정하는 데 도움이 된다.
- 단점 : 비용이 많이 들고 어려우며 커버리지에 대한 확신이 없다.
### 코드 검수의 장단점
- 코드 검수: 다른 사람에게 코드가 정확하고 안전하다는 것을 확신시키기 위한 과정 
- 장점: 인간은 일반화가 가능함 
- 단점: 비용이 많이 들고 어려우며 엄밀성이 떨어짐
### 정적 분석
- 소스 코드의 실행 없이 정적으로 프로그램의 문제를 찾는 과정을 의미 
- 컴퓨터에게 코드 리뷰를 수행하도록 요청하는 것으로 이해 가능 
- 동적 분석과 가장 큰 차이는 분석 시점 
	- 동적 분석은 런타임 환경에서 코드의 문제를 발견 
	- 정적 분석은 비 런타임 환경에서 수행
### 장점
- (훨씬) 더 *높은 커버리지* 
- *프로그램의 여러 가능한 실행에 대해 추론*
- 때로는 그 중 모든 것을 보장함 
- 불완전한 프로그램에 대한 추론 가능 (예: 라이브러리) 
### 단점  
제한된 속성만 분석 가능 
일부 오류를 놓칠 수 있음 (false negative) 
잘못된 검지로 알림이 발생할 수 있음 (false positive) 
시간과 자원이 많이 소비될 수 있음
### 정적 분석의 장애물
#### 종료 문제
종료 문제는 어떤 프로그램이 항상 멈추는지를 확신하는 일이 어렵다는 것이다.
기계가 입력 문자열을 받아서 계산을 시작했을 때, 기계가 멈추는지 아니면 무한히 계산을 진행하는지를 판단하는 것이 목적이다.
**어떤 일반적인 알고리즘이 모든 입력에 대해 정확한 답을 주는 것이 불가능하다는 원리를 보여준다.**
#### Rice의 정리
**어떤 프로그램이 특정한 일을 항상 수행하는지를 완벽하게 예측하는 것이 어렵다**는 것을 나타낸다.
특정 함수 집합에 속하는 프로그램의 특정한 특성을 결정하는 것이 일반적으로 불가능하다
특정 함수 클래스에 속하는 프로그램에 대한 어떤 성질도 알고리즘적으로 결정할 수 없다는 것을 의미한다.

이 두 한계로 인해 모든 상황에 대해 정적 분석이 완벽하게 정확하지는 않다는 사실을 알 수 있다.

완벽한 정적 분석은 불가능 하지만, 유용한 정적 분석은 가능하다.

비종료 하는 분석이 제대로 수행되고 있는지 혼란스럽게 만들고, 무한히 분석이 수행 됨으로써 컴퓨터 자원을 낭비할 수 있기 때문에 정적 분석 도구들은 주로 잘못된 경보, 놓친 오류만을 신경 쓰는 경우가 많다.
- 비종료(nontermination) - 분석기가 종료하지 않음
- 잘못된 경보(false alarms) - 주장된 오류가 실제로는 오류가 아님
- 놓친 오류(missed errors) - 오류 보고가 없다고 해도 오류가 없는 것은 아님

#### 뭔가 나올 듯한... 완벽한 정적 분석이 불가능한 이유는?
정적 문제의 장애물인 종료 문제에 따라 일반적인 알고리즘이 모든 입력에 대해 정확한 답을 주는 것이 불가능하기 때문이며, Rice의 정리에 따라 어떤 프로그램이 특정한 일을 항상 수행하는지를 완벽하게 예측하는 것이 어렵기 때문이다.

### 정적 분석의 특성
#### soundness
> 어떠한 오답 사례도 정답 사례라고 잘못 판단하지 않는다. 

어떤 속성이나 명제가 참일 때 그 결과가 항상 참

"어떠한 오답 사례도 정답 사례라고 잘못 판단하지 않음"이라는 말은 정적 분석이 잘못된 오류를 발견하는 것을 방지하기 위해 신중하게 이루어져야 한다
"오류를 찾지 못하면 오류가 존재하지 않음"이라는 부분은 정적 분석이 오류를 놓치면 해당 오류가 없다고 잘못 판단할 수 있다
"경보는 가짜 오류일 수 있음"은 정적 분석이 때때로 실제로는 오류가 아닌데도 오류로 판단할 수 있다
#### Completeness
> 어떤 정답 사례던 다 찾아낼 수 있다.

어떤 속성이나 명제가 거짓일 때 그 결과가 항상 거짓

"모든 정답 사례를 찾아낼 수 있음"이라는 부분은 정적 분석이 가능한 모든 올바른 코드 구조를 식별할 수 있다
"어떤 오류라도 발견하면 실제 오류임"이라는 문구는 정적 분석이 오류를 찾으면 그것이 실제로 오류일 확률이 높다
"침묵은 오류가 없음을 보장하지 않음"은 정적 분석이 어떤 경우에는 오류를 감지하지 못할 수 있으며, 이로 인해 코드에 잠재적인 오류가 있는지 확인이 어려울 수 있다


기본적으로 유용한 분석은 soundness도 아니고 completeness도 아니지만 보통 한 쪽으로 기울어짐