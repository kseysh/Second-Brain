---
sticker: emoji//1f9d7-200d-2642-fe0f
---
# 행위 패턴

**객체 간의 효과적인 의사소통과 책임 할당을 처리**
- 객체에 주어지는 기능 및 책임과 관련 있으며, 객체 간의 상호작용을 표현
- 패턴은 제어 흐름에 집중하기보다 상호 연결 방식에 집중할 수 있도록 지원 
- 행위 패턴은 상속을 통해서 클래스에 존재하는 동작을 전달(배포)

## 옵서버
**객체 간에 일대다 의존성 관계를 부여하고, 한 객체의 상태가 변경되었을 때 다른 객체들에게 자동으로 알려주어 필요한 변경을 수행하고자 할 때 사용하는 패턴**

## 구현 코드
출판사 인터페이스를 상속받은 출판사 객체는 IObserver list를 가지며, observer를 추가하고, 지우고, notify하는 메서드를 작성함 (notify메서드는 Observer list에 있는 모두에게  update 함수를 이용해 특정 행동을 하게 한다.)
Observer 인터페이스를 상속받은 Observer 객체는 생성자에서 출판사 인터페이스를 생성자 주입 받으며 update함수를 이용해 수행할 특정 행동을 구현한다.
![[Pasted image 20231208142051.png]]
![[Pasted image 20231208142105.png]]
![[Pasted image 20231208142114.png]]
### 적용 대상
**한 객체의 변경이 발생하면 다른 객체가 동시에 변경되어야 하는 경우**
한 객체가 다른 객체에 영향을 주지만 어떤 가정이나 결합도 부여하지 않는 경우


## 구현 방법
구독자 인터페이스를 선언하고 update 메서드를 선언한다
출판사 인터페이스르 선언하고 구독자 객체를 구독자 리스트에 추가 및 제거하는 메서드들을 구현한다.
출판사 인터페이스에서 직접 파생된 추상 클래스에 코드를 넣는다.
구상 출판사 클래스들을 만들어 출판사 내부에서 중요한 일이 발생할 때마다 모든 구독자에게 알림을 전달하는 notify 메서드 작성
구상 구독자 클래스들에서 알림을 받는 update 메서드 구현
클라이언트는 필요한 모든 구독자를 생성하고 적절한 출판사들과 등록시켜야 한다.

단계 1) 
	• 앱의 비즈니스 로직을 살펴보고 두 부분으로 나눠야 됨
	• 핵심 기능들은 다른 코드와 독립적이며 출판사 역할을 함 • 나머지는 구독자 클래스들의 집합으로 바뀜 
단계 2) 
	• 구독자 인터페이스를 선언 
	• 이 인터페이스는 최소한 하나의 update 메서드를 선언해야 됨
단계 3) 
	• 출판사 인터페이스를 선언하고 구독자 객체를 구독자 리스트에 추가 및 제거하는 한 쌍의 메서드에 대해 기술 
	• 출판사들은 구독자 인터페이스를 통해서만 구독자들과 작업해야 함
단계 4) 
	• 구독 메서드들의 구현과 실제 구독 리스트를 어디에 배치할지 결정 
	• 일반적으로 모든 유형의 출판사에서 이 코드는 실질적으로 유사 
	• 따라서 출판사 인터페이스에서 직접 파생된 추상 클래스에 코드를 넣는 것이 가장 적합 
단계 5) 
	• 구상 출판사 클래스들을 만듦 
	• 출판사 내부에서 중요한 일이 발생할 때마다 모든 구독자에게 알림을 전달해야 함 
단계 6) 
	• 구상 구독자 클래스들에서 업데이트 알림 메서드들을 구현 
	• 대부분의 구독자는 이벤트에 대한 일부 콘텍스트 데이터가 필요하며, 이 데이터는 알림 메서드의 인수로 전달될 수 있음 
단계 7) 
	• 클라이언트는 필요한 모든 구독자를 생성하고 적절한 출판사들과 등록시켜야 함

## 장단점
### 장점
개방/폐쇄 원칙 
	• 출판사의 코드를 변경하지 않고도 새 구독자 클래스들을 도입할 수 있음 
	• 출판사 인터페이스가 있는 경우 그 반대로 구독자의 클래스들을 변경하지 않고 새 출판사 클래스들을 도입하는 것 역시 가능 
• 런타임에 객체 간의 관계들을 형성할 수 있음
### 단점
• 구독자들은 무작위로 알림을 받음