- **도메인(Domain)**: 소프트웨어가 해결하고자 하는 문제
- **유비쿼터스 언어(Ubiquitous Language)**: 도메인 전문가와 개발자가 공통으로 사용하는 언어로, 도메인 모델을 설명하는 데 사용됩니다. 이를 통해 팀원 간의 의사소통을 원활하게 하고, 도메인에 대한 이해를 높일 수 있습니다.
- **바운디드 컨텍스트(Bounded Context)**: 도메인을 명확하게 구분 짓는 경계입니다. 각 바운디드 컨텍스트는 독립적으로 개발되고 배포될 수 있으며, 서로 다른 바운디드 컨텍스트 간의 상호작용은 명확한 인터페이스를 통해 이루어집니다.
- **애그리거트(Aggregate)**: 도메인 모델의 일관성을 유지하기 위해 관련된 객체들을 묶어 관리하는 단위입니다. 애그리거트는 하나의 루트 엔티티(aggregate root)를 가지며, 외부에서는 루트 엔티티를 통해서만 접근할 수 있습니다.
- **엔티티(Entity)**: 고유한 식별자를 가지며, 상태와 행동을 갖는 객체입니다. 엔티티는 도메인 모델의 핵심 구성 요소입니다.
- **밸류오브젝트(Value Object)**: 고유한 식별자를 가지지 않으며, 불변성을 가지는 객체입니다. 값 객체는 도메인 모델의 속성을 표현하는 데 사용됩니다.

## 적용 범위
- 핵심 도메인만 집중적으로 적용하는 것이 좋음
	- DDD를 전사적으로 적용하는 것은 이상적이지만, 모든 영역에 적용하는 것은 비효율적일 수 있음
- Bounded Context 경계를 명확히 해야함
	- 컴텍스트 간 명확한 API 정의 및 동일한 도메인 용어라도 의미가 달라질 수 있으므로 구분 필요
- 모든 도메인을 객체로 추상화하는 초기 설계 과잉을 주의해야함

### ex)  전자상거래 시스템 (주문/결제 도메인)
주문, 결제, 배송은 복잡한 상태 전이와 예외 처리가 많음 → DDD 적용 적합
리뷰, 검색, 통계는 상대적으로 단순 → CRUD 기반 설계로 충분
→ 실제 적용에서는 '주문 애그리거트'를 중심으로 Command/Query, 이벤트 기반 설계 도입

## DDD를 선택해야 할 때
- 핵심 도메인이 명확하고 복잡할 때
- 유지보수와 확장 가능성이 높은 장기 프로젝트
- 도메인 전문가와 긴밀한 협업이 가능한 구조

#### DDD example
- Bounded Context
    1. 각 Context는 도메인 모델이 적용되는 명시적인 경계가 됩니다.
    2. Context는 하위 도메인으로 분할하여 관리 가능한 수준으로 만듭니다.
    3. Bounded Context는 Gradle module(Sub project)의 단위가 됩니다.
- Aggregate Root
    1. Aggregate는 데이터의 일관성을 유지하기 위한 트랜젝션의 경계가 됩니다.
    2. Aggregate Root를 통해서만 Aggregate 내부의 Entity, Value Object에 접근하고 수정할 수 있습니다.
- 도메인 모델 설계 원칙
	1. 도메인 모델은 나눌 수 있는 최대한 작은 단위로 나누어 설계합니다.
	2. 도메인에 종속된 데이터를 유일하게 관리하고 제어합니다.
	3. 도메인 모델은 도메인에 대한 비즈니스 규칙을 포함합니
![[Pasted image 20260119135807.png]]