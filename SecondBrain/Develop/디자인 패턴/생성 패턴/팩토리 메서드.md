# 팩토리 메서드

![[Pasted image 20231101130745.png]]
객체를 생성할 때 어떤 클래스의 인스턴스를 만들 지 서브 클래스에서 결정하게 한다.

즉, 인스턴스 생성을 서브 클래스에게 위임한다.

부모 추상 클래스는 인터페이스에만 의존하고 실제로 어떤 구현 클래스를 호출할 지는 서브 클래스에서 구현한다.

이렇게 하면 새로운 구현 클래스가 추가되어도 기존 Factory 코드의 수정 없이 새로운 Factory 를 추가하면 된다.

>클라이언트에서 직접 `new` 연산자를 통해 제품 객체를 생성하는 것이 아닌, 제품 객체들을 도맡아 생성하는 공장 클래스를 만들고, 이를 상속하는 서브 공장 클래스의 메서드에서 여러가지 제품 객체 생성을 각각 책임 지는 것

# 3. Example
사용자 관리 프로그램이 있고 네이버 계정으로 가입할 수 있다고 가정합니다.

## 2.1. Product (User)
```java
public interface User {
    void signup();
}
```
- `User` 인터페이스 정의

```java
public class NaverUser implements User {
    @Override
    public void signup() {
        System.out.println("네이버 아이디로 가입");
    }
}
```
- `User` 인터페이스를 구현하는 `NaverUser` 클래스 정의
- 오버라이드한 메서드에는 네이버 유저 전용 로직 추가
## 2.2. Creator (UserFactory)
```java
public abstract class UserFactory {

    public User newInstance() {
        User user = createUser();
        user.signup();
        return user;
    }

    protected abstract User createUser();
}
```
- 추상 클래스로 `UserFactory` 를 정의
- 외부에서 `User` 객체를 생성할 때는 `newInstance()` 메서드를 호출하면 되고, 실제로 어떤 객체를 생성할 지는 추상 메서드로 정의해서 하위 클래스에서 정의

```java
public class NaverUserFactory extends UserFactory {
    @Override
    protected User createUser() {
        return new NaverUser();
    }
}
```
- `UserFactory` 를 상속받는 `NaverUserFactory` 를 정의
- `NaverUser` 를 반환하도록 오버라이드
## 2.3. Client
```java
UserFactory userFactory = new NaverUserFactory();
User user = userFactory.newInstance();
```
- 클라이언트 코드에서 `NaverUser` 클래스에 대한 의존성 없이 사용 가능
- 의존성 주입을 사용해서 외부에서 Factory 클래스를 받아온다면 `NaverUserFactory` 에 대한 의존성도 제거 가능

## 팩토리 메서드의 장단점

### 장점
- 생성자(Creator)와 구현 객체(concrete product)의 강한 결합을 피할 수 있다.
- 팩토리 메서드를 통해 객체의 생성 후 공통으로 할 일을 수행하도록 지정해줄 수 있다.
- 캡슐화, 추상화를 통해 생성되는 객체의 구체적인 타입을 감출 수 있다.
- [[단일 책임의 원칙]] 준수 :객체 생성 코드를 한 곳 (패키지, 클래스 등)으로 이동하여 코드를 유지보수하기 쉽게 할수 있으므로 원칙을 만족
- [[개방 폐쇄의 원칙]] 준수 : 기존 코드를 수정하지 않고 새로운 유형의 제품 인스턴스를 프로그램에 도입할 수 있어 원칙을 만족 (확장성 있는 전체 프로젝트 구성이 가능)
- 생성에 대한 인터페이스 부분과 생성에 대한 구현 부분을 따로 나뉘었기 때문에 패키지 분리하여 개별로 여러 개발자가 협업을 통해 개발
### 단점
- 각 제품 구현체마다 팩토리 객체들을 모두 구현해주어야 하기 때문에, 구현체가 늘어날때 마다 팩토리 클래스가 증가하여 서브 클래스 수가 많아져 코드의 복잡성이 증가한다.

## 패턴 사용 시기
- 클래스 생성과 사용의 처리 로직을 분리하여 결합도를 낮추고자 할 때
- 코드가 동작해야 하는 객체의 유형과 종속성을 캡슐화를 통해 정보 은닉 처리 할 경우
- 라이브러리 혹은 프레임워크 사용자에게 구성 요소를 확장하는 방법을 제공하려는 경우 
- 기존 객체를 재구성하는 대신 기존 객체를 재사용하여 리소스를 절약하고자 하는 경우
    - 상황에 따라 적절한 객체를 생성하는 코드는 자주 중복될 수 있다. 그리고 객체 생성 방식의 변화는 해당되는 모든 코드 부분을 변경해야 하는 문제가 발생한다. 
    - 따라서 객체의 생성 코드를 별도의 클래스 / 메서드로 분리 함으로써 객체 생성의 변화에 대해 대비를 하기 위해 팩토리 메서드 패턴을 이용한다고 보면 된다. 
    - 특정 기능의 구현은 별개의 클래스로 제공되는 것이 바람직한 설계이기 때문이다.

## 구현 방법
단계 1) 
	• 모든 제품이 같은 인터페이스를 따르도록 변경 
	• 이 인터페이스는 모든 제품에서 의미가 있는 메서드들을 선언해야 함 
단계 2) 
	• 크리에이터 클래스 내부에 빈 팩토리 메서드를 추가 
	• 이 메서드의 반환 유형은 공통 제품 인터페이스와 일치해야 함
단계 3) 
	• 크리에이터의 코드에서 제품 생성자들에 대한 모든 참조를 찾음 
	• 이 참조들을 하나씩 팩토리 메소드에 대한 호출로 교체하면서 제품 생성 코드를 팩토리 메서드로 추출
단계 4) 
	• 이제 팩토리 메서드에 나열된 각 제품 유형에 대한 크리에이터 자식 클래스들의 집합을 생성한 후, 자식 클래스들에서 팩토리 메서드를 오버라이딩하고 기초 메서드에서 생성자 코드의 적절한 부분들을 추출 
단계 5) 
	• 제품 유형이 너무 많아 모든 제품에 대하여 자식 클래스들을 만드는 것이 합리적이지 않을 경우, 자식 클래스들의 기초 클래스의 제어 매개변수를 재사용할 수 있음 
단계 6)
	• 추출이 모두 끝난 후 기초 팩토리 메서드가 비어 있으면, 해당 팩토리 메서드를 추상화할 수 있음 
	• 팩토리 메서드가 비어 있지 않으면, 나머지를 그 메서드의 디폴트 행동으로 만들 수 있음

참고 : https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9CFactory-Method-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90