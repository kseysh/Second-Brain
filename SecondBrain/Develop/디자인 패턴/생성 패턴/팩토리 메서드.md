# 팩토리 메서드

![[Pasted image 20231101130745.png]]
객체를 생성할 때 어떤 클래스의 인스턴스를 만들 지 서브 클래스에서 결정하게 한다.

즉, 인스턴스 생성을 서브 클래스에게 위임한다.

부모 추상 클래스는 인터페이스에만 의존하고 실제로 어떤 구현 클래스를 호출할 지는 서브 클래스에서 구현한다.

이렇게 하면 새로운 구현 클래스가 추가되어도 기존 Factory 코드의 수정 없이 새로운 Factory 를 추가하면 된다.

# 3. Example
사용자 관리 프로그램이 있고 네이버 계정으로 가입할 수 있다고 가정합니다.

## 2.1. Product (User)
```java
public interface User {
    void signup();
}
```
- `User` 인터페이스 정의

```java
public class NaverUser implements User {
    @Override
    public void signup() {
        System.out.println("네이버 아이디로 가입");
    }
}
```
- `User` 인터페이스를 구현하는 `NaverUser` 클래스 정의
- 오버라이드한 메서드에는 네이버 유저 전용 로직 추가


## 2.2. Creator (UserFactory)

```java
public abstract class UserFactory {

    public User newInstance() {
        User user = createUser();
        user.signup();
        return user;
    }

    protected abstract User createUser();
}
```

- 추상 클래스로 `UserFactory` 를 정의
- 외부에서 `User` 객체를 생성할 때는 `newInstance()` 메서드를 호출하면 되고, 실제로 어떤 객체를 생성할 지는 추상 메서드로 정의해서 하위 클래스에서 정의
- Java 8 부터는 인터페이스에서 `default` 메서드를 사용할 수 있기 때문에 인터페이스로 정의할 수도 있지만 `protected` 키워드를 사용해 접근을 제한하고 싶어서 추상 클래스를 사용

  

```java
public class NaverUserFactory extends UserFactory {
    @Override
    protected User createUser() {
        return new NaverUser();
    }
}
```

- `UserFactory` 를 상속받는 `NaverUserFactory` 를 정의
- `NaverUser` 를 반환하도록 오버라이드

  

## 2.3. Client

```java
UserFactory userFactory = new NaverUserFactory();
User user = userFactory.newInstance();
```

- 클라이언트 코드에서 `NaverUser` 클래스에 대한 의존성 없이 사용 가능
- 의존성 주입을 사용해서 외부에서 Factory 클래스를 받아온다면 `NaverUserFactory` 에 대한 의존성도 제거 가능