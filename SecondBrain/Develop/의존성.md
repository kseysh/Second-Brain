# 설계란?
코드를 어떻게 배치할 것인지에 대한 의사소통

핵심 => 변경에 초점을 맞추는 것이 좋다
같이 변경되는 코드는 같이 넣어주고 같이 변경되지 않는 코드들은 따로 넣어주어야 한다.

## 의존성의 의미
![[Pasted image 20240206120119.png|400]]
B가 변경될 때 A도 함께 변경될 수 있다.
의존성 : 변경에 의해 영향을 받을 수 있는 가능성(받을 수도 안 받을 수도 있다.)

## 클래스 의존성의 종류
### 연관 관계
![[Pasted image 20240206120431.png|400]]
### 의존 관계
![[Pasted image 20240206120441.png|400]]
### 상속 관계
![[Pasted image 20240206120450.png|400]]
### 실체화 관계
![[Pasted image 20240206120506.png|400]]

## 패키지 의존성
![[Pasted image 20240206120718.png|400]]

## 양방향 의존성을 피하라
A가 변할 때 B도 변하고, B가 변할 때 A도 변한다면 그것은 원래 하나의 클래스를 어거지로 찢은 것이나 다름 없다.
![[Pasted image 20240206120915.png|400]]
위 사진 처럼 변경해주는 것이 좋다.
연관관계가 양방향이면 성능이슈도 많이 발생하고 싱크를 맞추는 것에 버그가 많이 발생하므로 가급적이면 양방향관계를 단방향 연관 관계로 변경해주는 것이 좋다.

![[Pasted image 20240206121057.png|400]]
다중성이 적은 의존성을 가지는 방향을 선택하는 것이 좋다.
리스트 컬렉션 set같은 것을 가지면 다양한 이슈가 발생하기 때문이다. (객체 유지가 힘듬)

## 의존성이 필요없다면 제거하라

## 패키지 사이의 의존성 사이클을 제거하라
![[Pasted image 20240206121355.png|400]]

# 의존성 관리의 법칙
- 양방향을 피해라
- 다중성이 적은 방향을 선택해라 가능하면 의존성을 제거해라
- 패키지 사이에는 무조건 의존성의 싸이클이 생기지 않도록 해야함

## 관계의 종류 결정하기
### 연관관계

![[Pasted image 20240206123702.png|450]]
두 객체 사이에 협력이 필요하고 두 객체의 관계가 영구적이라면 연관관계를 이용해 탐색 경로를 구현하는 것이 좋다.
연관관계란 **탐색 가능성**이다
어떤 객체가 있는데 이 객체를 알면 내가 원하는 다른 객체를 찾아갈 수 있는 것이 연관관계이다.
![[Pasted image 20240206124324.png|300]]

### 의존관계
![[Pasted image 20240206124138.png]]
연관관계와 의존관계는 넣는 것에 이유가 있어야 한다.

## 객체 참조로 인한 결합도 상승
## 패키지 의존성 사이클

## 의존성 살펴보기

아래 사진과 같이 의존성을 그려보면 리팩토링시에 편하다
![[Pasted image 20240206142744.png|400]]

![[Pasted image 20240206145117.png]]
shop패키지와 order패키지가 서로 양방향 연관관계를 맺고 있다는 문제가 있다. 

![[Pasted image 20240206143516.png|400]]
OptionGroup과 Option이라는 중간 객체를 생성하여 양방향 연관관계를 끊어줄 수 있다.
의존성 역전 원칙을 지킬 수 있음 (구체 클래스에 의존하지 않고 추상 클래스에 의존하라) => abstract 클래스만 추상 클래스인 것이 아닌, 잘 변하지 않는 객체를 추상화된 객체라고 할 수 있다.

트랜잭션 로직은 아래 사진과 같다.
하지만 각각의 객체의 이유로 인해 변경되는 빈도는 다를 수 있다.
이렇게 되면 트랜잭션 경합으로 인한 성능 저하가 이뤄질 수 있다.
![[Pasted image 20240206151829.png]]

## 객체 참조가 꼭 필요한가?
### 객체 참조의 문제점
객체 참조는 모든 것을 다 연결시킨다.
따라서 어떤 객체라도 접근가능하게 한다.
따라서 어떤 객체라도 함께 수정할 수 있다.
객체 참조는 결합도가 가장 높은 의존성이다.
따라서 필요한 경우에는 객체 참조를 끊어야 한다.

### Repository를 통한 탐색 (약한 결합도)
id를 저장하는 방식으로 탐색한다.
비즈니스 로직은 단방향으로 깔끔하게 만들 수 있지만
조회로직은 양방향으로 되어 복잡하게 됨

어떤 객체들을 묶고 어떤 객체들을 분리할 것인가?
=> 함께 생성되고 함께 삭제되는 객체들을 함께 묶는다
=> 도메인 제약사항을 공유하는 객체들을 함께 묶는다
=> 가능하면 분리하라

![[Pasted image 20240206154325.png]]
경계 안의 객체는 참조를 이용해 접근한다. 
경계 밖의 객체는 ID를 이용해 접근한다.

끊어줌으로써 트랜잭션 단위와 조회 경계를 관리할 수 있게 된다.

## 패키지 의존성 사이클을 제거하는 3가지 방법
![[Pasted image 20240206161639.png|400]]

![[Pasted image 20240206161656.png|400]]
![[Pasted image 20240206161742.png|400]]
![[Pasted image 20240206161803.png|400]]



https://javanitto.tistory.com/41