## 엔티티 내부 구현을 캡슐화할 수 있다.
- 엔티티가 getter와 setter를 갖게 된다면, controller와 같은 비즈니스 로직과 크게 상관없는 곳에서 자원의 속성이 실수로라도 변경될 수 있다.
- 엔티티를 UI계층에 노출하는 것은 테이블 설계를 화면에 공개하는 것이나 다름없기 때문에 보안상으로도 바람직하지 못한 구조이다.

## 화면에 필요한 데이터를 선별할 수 있다.
- 개발을 하며 엔티티가 점점 커지는 상황에서 요청과 응답으로 엔티티를 사용한다면, 요청하는 화면에 필요하지 않은 속성까지도 함께 보내지게 된다.
- 모든 API 요청과 응답에서 엔티티의 모든 속성이 함께 전송되기 때문에 당연히 속도도 느려진다.

## 순환참조를 예방할 수 있다.
- 양방향 참조된 엔티티를 컨트롤러에서 응답으로 return하게 되면, 엔티티가 참조하고 있는 객체는 지연 로딩되고, 로딩된 객체는 또 다시 본인이 참조하고 있는 객체를 호출하게 된다. 이렇게 서로 참조하는 객체를 계속 호출하면서 결국 무한 루프에 빠지게 되는 문제를 낳게된다.

## validation 코드와 모델링 코드를 분리할 수 있다.
- 엔티티 클래스는 DB의 테이블과 매칭되는 필드가 속성으로 선언되어 있고, 복잡한 비즈니스 로직이 작성되어있는 곳이다.
  
  그렇기 때문에, 속성에는 `@Column`, `@JoinColumn` , `@ManyToOne`, `@OneToOne` 등의 모델링을 위한 코드가 추가된다.
  
  여기에 만약 `@NotNull`, `@NotEmpty`, `@NotBlank` 등과 같은 요청에 대한 값의 validation코드가 들어간다면 엔티티 클래스는 더 복잡해지고 그만큼 가독성이 저하된다.
  
  이때, 각각의 요청에 필요한 validation을 DTO에서 정의한다면, 엔티티 클래스를 좀 더 모델링과, 비즈니스 로직에만 집중되도록 만들 수 있다.


\[[참고한 블로그](https://tecoble.techcourse.co.kr/post/2020-08-31-dto-vs-entity/)]