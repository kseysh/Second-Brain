# @Transactional을 서비스 계층에서 사용하는 이유
트랜잭션 시작 시점에 DB 커넥션을 할당받으므로 트랜잭션 범위가 길어지면 안된다.
물리 트랜잭션은 개수의 한계가 있고, 트랜잭션 범위가 짧아야 DB 커넥션을 빨리 반납한다. 그러므로 트랜잭션 범위를 짧게 설정하기 위해 서비스 단에서도 필요한 부분에만 설정하는 것이 좋다.

# 트랜잭션을 적용해야 할 때
### 여러 로직이 섞여있을 때
여러 로직들이 섞여 있을 때 발생하는 문제는 데이터를 영속함에 있다.
한 메서드에서 예외가 발생했을 때, 이전에 호출한 메서드에서 영속한 데이터를 되돌려야 한다.
그렇지 않으면, 예외가 발생한 잘못된 요청임에도 정합성이 맞지 않는 문제가 발생한다.
### DB에 관련된 메서드를 여러번 호출할 때
트랜잭션을 적용하는 이유는 데이터의 정합성을 보장하는 것도 있지만, 핵심은 일련의 작업을 하나의 논리적인 작업으로 묶음에 있다.
이로 인해 여러 작업을 하나의 작업으로 묶어 성능을 개선할 수 있다.
```java
@Service
class MyService() {

    public Response updateData(Request request) {
        Member member = memberDao.findById(request.memberId());
        member.setNickname(request.nickname());
        memberDao.update(member);
        memberHistoryDao.save(new MemberHistory(member));
    }
}
```
위에서 데이터베이스에 요청하는 개수는 3번이어서 커넥션 풀을 사용하지 않으면 데이터베이스 커넥션이 3번 맺어진다.
이 때, 트랜잭션을 적용한다면 트랜잭션 범위안에 있는 모든 데이터베이스의 요청들은 하나의 커넥션을 공유하여 사용한다.
## 트랜잭션을 적용하지 않아야 할 때
### 외부 API를 호출하는 로직
트랜잭션은 DB에 관련된 기능이며, DB에 관련되지 않은 로직을 수행한다면 트랜잭션을 적용할 필요가 없다.
외부 API를 호출하는 작업은 비용(네트워크를 오가며 드는 시간)이 크다
이 비용은 오로지 네트워크와 외부 API 서버가 얼마나 빠르게 반응하냐에 따라 달린 것이라 성능을 높이기 어렵다.

이로 인해 외부 API 서버를 기다리고, 외부 서비스에 요청이 많이 몰려 3~4초 혹은 그 이상 지연이 되거나 네트워크 문제가 발생하여 요청이 가고, 중간에 요청이 유실되어 서버가 응답이 기다리느라 잠깐 대기를 하게 된다면 트랜잭션을 통해 맺고 있던 커넥션이 쭉 유지된 채 있게 되기 때문에 외부 API에 관련된 작업은 최대한 트랜잭션 범위 밖에서 호출해야 한다.

이는 커넥션 풀을 사용하기 때문이다. 기본적으로 스프링은 10개의 커넥션을 가진 풀을 제공하는데 외부 API의 문제로 커넥션을 오래 점유하게 되면 그 시간 동안 커넥션을 사용할 수 없기 때문에 문제가 하나의 요청에서만 생기는 것이 아닌, 외부 API 서버가 마비된 시간에 오는 요청이 전부 지연된다. 즉, 외부 API 호출에서 발생한 지연이 다른 요청까지 영향을 끼치게 된다.

#### 주의해야 할 점
트랜잭션은 AOP로 구현되기 때문에, public 접근자로 공개된 메서드에만 프록시가 적용될 수 있다.

