### 1. 모든 연관관계는 가능한 지연로딩으로
@ManyToOne, @OneToOne은 별도 설정이 없으면 기본이 즉시로딩이니 주의
### 2. IDE에서 디버그 모드로 실행 시, 연관관계가 자동 지연로딩 될 수 있다.
### 3. 지연로딩 사용 시 Service 레이어에 '@Transactional' 어노테이션 사용
### 4. 일대일 관계는 주의 필요 :: optional=false 이거나, 외래키 컬럼을 가지고 있는 경우만 지연로딩
null은 프록시로 감쌀 수 없다.
따라서 null인지 확실히 알 수 있어야 지연로딩을 해준다.
null인지 알 수 없으면 지연로딩으로 설정해도 즉시로딩될 수 있다.
### 5. 엔티티 클래스를 final로 선언하지 않는다.
final 클래스는 프록시 생성이 불가능하기 때문
### 6. Not null 컬럼 매핑 시 optional=false 조건 추가
연관관계 fetch join시 기본으로 outer join을 하는데, optional=false인 경우 inner join을 한다.
### 7. 엔티티 직렬화 시, 자동으로 지연로딩 발생할 수 있다.
ex) 레디스 같은 캐시 시스템에 엔티티를 캐싱하는 경우
직렬화하기 전 연관된 모든 엔티티를 모두 fetch join 하거나, 연관 엔티티를 직렬화에서 제외한다.
가능하다면 엔티티를 직렬화하기보다, DTO를 직렬화하는 것이 좋다.
### 8. toString()에 연관관계 엔티티 제외 필요
toString() 사용시 연관된 엔티티를 포함하면 불필요한 즉시 로딩이 발생할 수 있다.
@ToString에서 연관관계가 있는 필드는 exclude 옵션을 사용하여 제외시켜야 한다.
toString을 쓸 일이 없더라도, 라이브러리에서 내부적으로 사용하고 있을 가능성이 있어 처리하는 것이 좋다.


https://velog.io/@wisepine/JPA-사용-시-19가지-Tip