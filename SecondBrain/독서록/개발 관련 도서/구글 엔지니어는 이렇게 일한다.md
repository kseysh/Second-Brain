- 0-2 | CHAPTER 16 버전 관리와 브랜치 관리
- 2-1 | CHAPTER 1 소프트웨어 엔지니어링이란?
- 2-3 | CHAPTER 8 스타일 가이드와 규칙
- 2-4 | CHAPTER 9 코드 리뷰
- 2-4 | CHAPTER 19 Critique: 구글의 코드 리뷰 도구

- Segment 0: 오픈소스SW 및 라이선스, Git
- Segment 1: Docker
- Segment 2: 소프트웨어 공학 관련 내용

읽기 과제
- **2-4 | CHAPTER 9 코드 리뷰 ( 234 - 254 )** 
- **0-2 | CHAPTER 16 버전 관리와 브랜치 관리 ( 429 - 456 )**

# CHAPER 9 코드 리뷰
구글은 모든 코드 변경을 커밋 전에 검토하도록 강제하고, 모든 엔지니어가 리뷰 프로세스를 시작함. 
구글이 사용하는 코드 리뷰 도구 : 크리틱
## 코드 리뷰 프로세스
변경 사항 발생 -> diff를 통해 코드가 어떻게 달라졌는지 평가
작성자는 한 명 이상의 리뷰어에게 메일을 보내 리뷰 요청
리뷰어들은 코드 리뷰 도구에서 diff에 댓글로 의견을 남김
작성자는 피드백을 기초로 변경을 수정
리뷰어들이 변경 내용에 모두 만족하면 LGTM(looks good to me)태그를 달아준다.
LGTM 태그가 달리고 변경이 승인되면 커밋 가능
> 코드 리뷰 과정에서 기존 결정을 다시 논의해서는 안된다.

## 구글에서 승인을 받기 위해 통과해야하는 리뷰
- 다른 엔지니어로부터 정확성과 이해 용이성을 평가받아야 한다.
- 변경되는 코드 영역을 관리하는 코드 소유자로부터 변경 코드가 적절하다는 승인을 받는다.
- 가독성 인증자에게 가독성 승인을 받는다.
- 승인을 받기 위한 사람이 자신이라면 그 승인은 암묵적으로 동의된다.

정확성 평가가 주관적으로 흘러가지 않도록 하기 위해 일반적으로 변경 작성자가 선택한 방식을 설계 측면에서든 기능 측명에서든  존중해준다. 대안 제시는 가능하지만, 이해하기 더 쉽거나 기능을 개선하는 대안일 경우에만 그렇게 해야한다.
구글은 새로운 코드가 완벽하다고 합의될 때까지 기다리지 않고 코드베이스를 개선한다고 인정되면 변경을 승인하도록 안내한다.
코드리뷰는 소프트웨어에 결함에 대처하는 여러 방어수단 중 하나이지만 정확성을 검사하는 유일한 수단도 아니므로 코드 리뷰가 완벽할 필요까지는 없다. => 코드리뷰에 대한 비용을 너무 크게 잡지 말자.

## 코드 리뷰를 하는 이유

### 코드 이해 용이성
작성자의 관점에 치우치지 않은 피드백을 제공할 수 있다.
### 코드 일관성
많은 사람들이 보고 유지보수 하며 일관성을 유지할 수 있다.
검증을 해주며, 비판을 좀 더 자연스럽게 받아들일 수 있다. 
### 심리적, 문화적 이점
코드리뷰를 통해 코드가 자신의 것이 아닌 협업을 통해 만들어지는 조직의 공동 소유물임을 인식해주는 효과가 있다.
### 지식 공유

## 코드 리뷰 모범 사례
### 공손하고 전문가답게

### 작게 변경하기
작은 변경 => 변경되는 코드가 200줄 이하

### 변경 설명 잘쓰기
### 리뷰어는 최소한으로
코드 리뷰에 대한 비용이 너무 증가하기 때문
여럿이 검토하는 것이 더 나을 것 같다면 서로 다른 관점에서 바라보도록 역할을 조율해야 함
### 가능한 한 자동화하기

## 코드 리뷰 유형
### 그린필드 코드 리뷰
완전히 새로운 코드를 대상으로 하는 드문 유형의 코드 리뷰
설계 리뷰를 강도 높게 진행한다.
### 동작 변경, 개선, 최적화
### 버그 수정과 롤백
버그를 수정하면서 다른 문제까지 묶어서 처리하지 말아야 한다.
여러 주제가 섞이면 리뷰할 것이 많아지며, 회귀 테스트나 롤백을 훨씬 어렵게 만든다.
버그 수정은 온전히 그 버그를 잡는 데만 집중하자.
버그 수정 시 테스트도 보강해야 한다. 테스트를 뚫고 버그가 나왔을 것이기 때문.
### 리팩터링과 대규모 변경

# CHAPTER 16 버전 관리와 브랜치 관리

단일 진실 공급원 (SSOT) : git main에서의 HEAD
원래는 파일 락킹을 통해 사용했었음 (한 사람이 수정하고 있으면 다른 사람은 수정 못함)

## 중앙 집중형 VCS vs 분산형 VCS (다시 알아보기)
### 중앙 집중형 VCS
단 하나의 중앙 레포지토리를 이용하는 모델
### 분산형 VCS
ex ) 깃, 머큐리얼
복제본 (clone, fork)을 가지고 있을 수 있음.

둘의 개념적으로 가장 큰 차이 : 어디에 커밋하는가 이 파일들의 어느 복사본이 리포지터리로 간주되는가?
중앙이라는 것은 개념적으로만 존재할 뿐, 기술이나 기반 프로토콜이 아닌 순전히 정책의 문제이다.
## 브랜치 관리
### 진행 중인 작업은 브랜치와 비슷하다.
### 개발 브랜치
브랜치 병합은 작은 단위로 하는 것이 좋다.
### 릴리스 브랜티
제품의 릴리스 간격이 몇 시간 이상이면 릴리스 브랜치를 따로 생성하는 것이 좋다.

## 버전 관리
구글의 자체 개발 중앙집중형 vcs : piper

### 원-버전
어느 리포지터리의 어느 브랜치가 진실 공급원인지를 개발자가 명확히 알도록 한다는 단일 진실 공급원 개념을 확장한 개념.
> 모든 의존성이 우리 리포지터리에 담겨 있고 각 의존성은 단 하나의 안정된 버전만 존재해야 한다.
### 장수 브랜치는 금지
개발 브랜치를 되도록 만들지 말고, 만들더라도 매우 짧게 쓰고 없애야 한다.
### 모노리포(단일 리포지터리)


### 핵심 정리
![[Pasted image 20231003155900.png]]