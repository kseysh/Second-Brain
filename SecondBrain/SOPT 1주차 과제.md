# 제네릭
> 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법

## 제네릭의 장점
- 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있다 => 런타임에 발생할 수 있는 타입에러를 컴파일전에 검출할 수 있기 때문이다.
- 클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없다. 즉, 관리하기가 편하다.
- 비슷한 기능을 지원하는 경우 코드의 재사용성이 높아진다.
## 제네릭의 단점
- 반환값에 대한 타입 변환 및 타입 검사에 들어가는 노력을 줄일 수 있다.

## 제네릭의 예시
```java
class MyArray<T> {

    T element;

    void setElement(T element) { this.element = element; }

    T getElement() { return element; }

}
```
예시에서 사용된 'T'를 타입 변수라고 하며, 임의의 참조형 타입을 의미한다.

## 제네릭의 특징 및 사용법
- 클래스 혹은 메소드에 선언할 수 있다.
- 동시에 여러 타입을 선언할 수 있다.
- 와일드 카드를 이용하여 타입에 대하여 유연한 처리를 가능케 한다.
- 제네릭 선언 및 정의시에 타입의 상속관계를 지정할 수 있다.

### 와일드 카드란?
제네릭 타입을 더 유연하게 다룰 수 있게 하는 기능으로 크게 세 가지 종류가 있다.

#### 물음표(`?`) 와일드카드:
`<?>`를 사용하여 "알 수 없는 타입"을 나타냅니다. 이것은 모든 제네릭 타입을 나타내며, 제네릭 타입 파라미터에 대한 정보를 요구하지 않습니다.
    
#### 상한 와일드카드(`? extends T`):
`? extends T` 형태로 사용되며, T 타입과 T의 하위 타입들만을 나타냽니다. 이것은 읽기 작업(read-only)에 사용됩니다. 리스트나 컬렉션을 읽기 전용으로 다룰 때 유용합니다.
    
#### 하한 와일드카드(`? super T`):
`? super T` 형태로 사용되며, T 타입과 T의 상위 타입들만을 나타냅니다. 이것은 쓰기 작업(write-only)에 사용됩니다. 리스트나 컬렉션에 요소를 추가할 때 유용합니다.
### 와일드 카드의 예시
```
// 물음표 와일드카드: 모든 제네릭 타입을 나타냄
public void printList(List<?> list) {
    for (Object item : list) {
        System.out.print(item + " ");
    }
}

// 상한 와일드카드: T와 T의 하위 타입만 허용 (읽기 전용)
public double sumList(List<? extends Number> numbers) {
    double sum = 0;
    for (Number number : numbers) {
        sum += number.doubleValue();
    }
    return sum;
}

// 하한 와일드카드: T와 T의 상위 타입만 허용 (쓰기 전용)
public void addNumbers(List<? super Integer> list) {
    list.add(42);
}
```

## 제네릭의 제거 시기
자바 코드에서 선언되고 사용된 제네릭 타입은 컴파일 시 컴파일러에 의해 자동으로 검사되어 타입 변환된다.

그리고서 코드 내의 모든 제네릭 타입은 제거되어, 컴파일된 class 파일에는 어떠한 제네릭 타입도 포함되지 않게 된다.

이런 식으로 동작하는 이유는 제네릭을 사용하지 않는 코드와의 호환성을 유지하기 위해서이다.
# 자바 제어자와 접근 제어자

# 제어자
## final

> final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수

| 대상     | 의미                                                                                |
| -------- | ----------------------------------------------------------------------------------- |
| 클래스   | 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.                                |
| 메서드   | 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다. |
| 멤버변수 & 지역변수 | 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.                          |

> final이 붙은 변수는 상수이므로 보통은 선언과 초기화를 동시에 하지만, 인스턴스마다 고정값을 갖는 인스턴스 변수의 경우 생성자에서 초기화한다.

ex)
```
class Card{
	final int NUMBER;
	final String KIND;
	Card(String kind, int num){
		KIND = kind;
		NUMBER = num;
	}
}


--------------------

public static void main(String args[]){
	Card c = new Card("HEART", 10);
	// c.NUMBER = 5 => 에러 발생
}
```


## abstract

> abstract가 사용될 수 있는 곳 - 클래스, 메서드

### 추상클래스 (abstract class)
- 클래스가 설계도라면 추상클래스는 '미완성 설계도'
- 추상메서드(미완성 메서드)를 포함하고 있는 클래스

ex)
```
abstract class Player{
	int currentPos;

	Player() {                   // 추상클래스도 생성자가 있어야 한다.
		currentPos = 0;
	}

	abstract void play(int pos); // 추상메서드
	abstract void stop();        // 추상메서드

	void play(){
		play(currentPos);        // 추상메서드를 사용할 수 있다.
	}
}
```
- 일반메서드가 추상메서드를 호출할 수 있다. (호출할 때 필요한건 선언부)
- 완성된 설계도가 아니므로 인스턴스를 생성할 수 없다.
- 다른 클래스를 작성하는 데 도움을 줄 목적으로 작성된다.

### 추상메서드 (abstract method)

- 선언부만 있고 구현부 (몸통, body)가 없는 메서드
- 꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우에 사용
- 추상클래스를 상속받는 자손클래스에서 추상메서드의 구현부를 완성해야한다.

### 추상클래스의 작성
- 여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나 기존클래스의 공통 부분을 뽑아서 추상클래스를 만든다.

ex) 
```
class Marine {
	int x, y;
	void move(int x, int y) { 이동하는 코드 }
	void stop() { 정지하는 코드 }
	void stimPack() { 스팀팩 사용 }
}

class Tank {
	int x, y;
	void move(int x, int y) { 이동하는 코드 }
	void stop() { 정지하는 코드 }
	void changeMode() { 공격모드 변환 }
}

------------ ↓ -------------

abstract class Unit{
	int x, y;
	abstract void move(int x, int y);
	void stop();
}

class Marine extends Unit {
	int x, y;
	void move(int x, int y) { 이동하는 코드 } // 추상메서드가 호출되는 것이 아니라 각 자손들에 실제로 구현된 move 함가 호출된다.
	void stimPack() { 스팀팩 사용 }
}

class Tank extends Unit {
	int x, y;
	void move(int x, int y) { 이동하는 코드 }
	void changeMode() { 공격모드 변환 }
}

```


| 대상   | 의미                                                            |
| ------ | --------------------------------------------------------------- |
| 클래스 | 클래스 내에 추상 메서드가 선언되어 있음을 의미한다              |
| 메서드 | 선언부만 작성하고 구현부는 작성하지 않은 추상메서드임을 알린다. |

ex)
```
abstract class AbstractTest{
	abstract void move();
}
```


# 접근 제어자

> 접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자

- private - 같은 클래스 내에서만 접근이 가능하다.
- default - 같은 패키지 내에서만 접근이 가능하다.
- protected - 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다.
- public - 접근 제한이 전혀 없다.

### 접근제어자를 사용하는 이유
- 외부로부터 데이터를 보호하기 위해서
- 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서

## 불가능한 제어자 조합

### 메서드에서의 static + abstract
static 메서드는 몸통(구현부)이 있는 메서드에만 사용할 수 있다.
### 클래스에서 abstract+ final
- 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고, abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문이다.
### 메서드에서의 abstract +private
- abstract메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손클래스에서 접근할 수 없기 때문이다.
### 메서드에서의 private + final (불가능하지는 않지만 권장 X)
- 접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다.

# 싱글톤

> 객체의 인스턴스가 오직 1개만 생성되는 패턴

디자인 패턴에서 생성 패턴의 종류 중 하나로 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다.

## 싱글톤을 사용하는 이유
### 메모리 측면에서의 이점
- 최초 한번의 new 연산자를 통해서 고정된 메모리 영역을 사용하기 때문에 추후 해당 객체에 접근할 때 메모리 낭비를 방지할 수 있다.
- 이미 생성된 인스턴스를 활용하여 속도 측면에서도 이점이 있다고 볼 수 있다
### 속도 측면의 이점
- 생성된 인스턴스를 사용할 때는 이미 생성된 인스턴스를 활용하여 속도 측면에 이점이 있다.
### 쉬운 데이터 공유
- 싱글톤 인스턴스가 전역으로 사용되는 인스턴스이기 때문에 다른 클래스의 인스턴스들이 접근하여 사용할 수 있다
- 여러 클래스의 인스턴스에서 싱글톤 인스턴스의 데이터에 동시에 접근하게 되면 동시성 문제가 발생할 수 있으니 이점을 유의해서 설계하는 것이 좋다
## 싱글톤을 사용하며 주의할 점
### 싱글톤 패턴을 구현하는 코드의 복잡성
- 정적 팩토리 메서드에서 객체 생성을 확인하고 생성자를 호출하는 경우에 멀티스레딩 환경에서 발생할 수 있는 동시성 문제 해결을 위해 syncronized 키워드를 사용해야 한다
### 테스트의 어려움
- 싱글톤 인스턴스는 자원을 공유하고 있기 때문에 테스트가 결정적으로 격리된 환경에서 수행되려면 매번 인스턴스의 상태를 초기화시켜주어야 한다. 그렇지 않으면 어플리케이션 전역에서 상태를 공유하기 때문에 테스트가 온전하게 수행되지 못한다
### 의존 관계상 클라이언트가 구체 클래스에 의존한다.
- new 키워드를 직접 사용하여 클래스 안에서 객체를 생성하고 있으므로, 이는 SOLID 원칙 중 [[의존성 역전의 원칙]]를 위반하게 되고 [[개방 폐쇄의 원칙]] 원칙 또한 위반할 가능성이 높다.
### 기타 문제점
- 자식 클래스를 만들 수 없다
- 내부 상태를 변경하기 어렵다
- 유연성이 떨어진다.


## 싱글톤의 예시

```java
public class Singleton {
    // 단 1개만 존재해야 하는 객체의 인스턴스로 static 으로 선언
    private static Singleton instance;

    // private 생성자로 외부에서 객체 생성을 막아야 한다.
    private Singleton() {
    }

    // 외부에서는 getInstance() 로 instance 를 반환
    public static Singleton getInstance() {
        // instance 가 null 일 때만 생성
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

# Spring의 각각의 의존성 주입 방법

# JAR, WAR의 차이점