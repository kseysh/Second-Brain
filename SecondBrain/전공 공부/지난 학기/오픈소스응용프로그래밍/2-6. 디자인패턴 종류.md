# 디자인 패턴 종류
## 구조 패턴
프로그램 구조 및 클래스나 객체의 합성에 관한 패턴
프로그램의 구조(자료구조 또는 인터페이스 구조 등)를 설계하는 데 활용 가능한 패턴들
## 생성 패턴
객체의 생성 과정이나 초기화에 관여하는 패턴
## 행동 패턴
객체 간의 효과적인 의사소통과 책임 할당을 처리
클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법에 대해 정의

# GoF 설계 패턴

## 구조 패턴
![[Pasted image 20231012105013.png]]
### 어댑터
**클래스의 인터페이스를 클라이언트가 기대하는 다른 인터페이스로 변환하는 방법** 제공
*호환되지 않는 인터페이스로 인해 사용할 수 없었던 클래스에 어댑터를 사용하면 함께 작동할 수 있도록 지원*함
### 적용 대상
• **기존 클래스를 사용해야 하나 인터페이스가 수정되어야 하는 경우** 
• 이미 만들어진 클래스를 재사용하고자 하나 재사용 가능한 라이브러리를 수정할 수 없는 경우
• 이미 존재하는 여러 개의 하위 클래스를 사용해야 하는데, 이 하위 클래스들의 상속을 통해서 이들의 인터페이스를 다 개조한다는 것이 현실성이 없는 경우
#### 객체 어댑터
아래는 Target에서 adaptee를 사용하고 싶은데, 호환이 되지 않아 adaptee를 사용하지 못하는 상황.
따라서 Target 인터페이스를 구현하고, adaptee를 wrapping하여 Target에서 adaptee를 사용할 수 있도록 Adapter class를 구현하여 client가 adapter를 사용하여 adaptee의 코드로 override를 사용하여 Target에서 adaptee의 코드를 사용할 수 있도록 한 것

객체 합성 원칙 사용
==어댑터는 한 객체의 인터페이스를 구현하고 다른 객체는 래핑==
![[Pasted image 20231208105954.png]]
#### 클래스 어댑터
아래는 Target에서 adaptee를 사용하고 싶은데, 호환이 되지 않아 adaptee를 사용하지 못하는 상황.
따라서 Adapter class가 Target과 adaptee를 모두 상속받아 Request를 override해 adaptee의 코드로 사용될 수 있도록 하는 것.

상속을 사용하며, ==어댑터는 동시에 두 객체의 인터페이스를 상속==
이 방식은 C++ 와 같이 다중 상속을 지원하는 프로그래밍 언어에서만 구현 가능
![[Pasted image 20231208110003.png]]
#### 어댑터 패턴 구현방법

- 호환되지 않는 인터페이스가 있는 클래스가 최소 두 개 이상인지 확인한다.
- 어댑터 클래스가 클라이언트 인터페이스를 따르도록 상속하거나 인터페이스를 구현한다.
- 어댑터 클래스의 생성자를 통해 어댑티 클래스를 초기화한다.
- 데이터를 변환해야 하는 메서드들을 어댑터 클래스에서 어댑티 메서드를 이용해 하나씩 구현한다.
- 클라이언트는 클라이언트 인터페이스를 통해 어댑터를 사용한다.

![[Pasted image 20231012111117.png]]
![[Pasted image 20231012111132.png]]

#### 어댑터 패턴 장단점
![[Pasted image 20231012111156.png]]
## 생성 패턴
### 팩토리 메소드
### 빌더
## 행위 패턴
### 옵저버
