![[Pasted image 20250114174355.png|300]]
## 하드웨어 스레드
- 프로세스가 메모리에 접근할 때 코어는 쉬게 된다.
	- 이 때 코어가 다른 프로세스를 수행하게 된다.
	- 그 때 수행하는 각각의 프로세스를 하드웨어 스레드라 한다.
- OS 관점에서 하드웨어 스레드는 가상의 코어이다
	- 만약 싱글코어 cpu에 하드웨어 스레드가 두 개라면 os는 이 CPU를 듀얼 코어로 인식하고 듀얼 코어에 맞춰서 OS 레벨의 스레드들을 스케쥴링한다.
## OS 스레드
- OS 커널 레벨에서 생성되고 관리되는 스레드
- CPU에서 실제로 실행되는 단위, CPU 스케쥴링의 단위
- OS 스레드의 컨텍스트 스위칭은 커널이 개입하여 비용이 발생한다.
- 사용자 코드와 커널 코드 모두 OS 스레드에서 실행된다
 
 OS 스레드는 아래와 같이 불리기도 한다
 - 네이티브 스레드
 - 커널 스레드
 - 커널 레벨 스레드
 - OS 레벨 스레드
## 유저 스레드
스레드 개념을 프로그래밍 레벨에서 추상화 한 것
ex) `Thread t = new Thread();`

유저 스레드가 CPU에서 실행되려면 OS 스레드와 반드시 연결되어야 한다.
실제로 CPU에서 실행되기 위해서는 유저 스레드가 OS 스레드 위에 있어야 하기 때문이다.
#### 조금 다른 의미의 유저 스레드
![[Pasted image 20250114175350.png|200]]
OS와는 독립적으로 유저 레벨에서 스케줄링되는 스레드

## 스레딩 모델
![[Pasted image 20250114175234.png|400]]
### One to One Model
ex) 자바
스레드 관리를 OS에 위임한다
스케쥴링도 커널이 수행한다.
한 스레드가 block되어도 다른 스레드는 잘 동작한다.
race condition이 발생할 수 있다,
### Many to One Model
여러 유저 스레드가 하나의 OS 스레드에 연결된 모델
컨텍스트 스위칭이 유저 레벨에서만 진행되고 커널이 개입하지 않기 때문에 유저 스레드 간의 컨텍스트 스위칭이 One to One 모델보다 빠르다.
OS 레벨에서 race condition이 발생하지 않는다. => 유저 레벨에서 race condition이 발생한다.
실제로 코어에서 사용되는 것은 OS 레벨의 스레드인데, OS 레벨의 스레드를 하나만 활용할 수 있기 때문에 멀티코어를 활용하지 못한다.
유저 스레드에서 block IO를 호출하면 곧 OS 레벨에서 block IO를 호출하는 것이기 때문에 OS 레벨의 스레드가 block되면 연결된 모든 유저 스레드가 block될 수 있다. => 따라서 nonblock IO를 사용하게 된다.
### Many to Many model
One to One 모델과 Many to One 모델의 장점을 합친 모델
ex) go lang
## 그린 스레드
![[Pasted image 20250114175549.png|300]]
유저 스레드라고도 부른다.
#### 다른 의미의 커널 스레드
OS 커널의 역할을 수행하는 스레드
