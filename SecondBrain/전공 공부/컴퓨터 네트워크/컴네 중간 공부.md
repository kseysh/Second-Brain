###### 7 Layer 이름과 패킷 이름, 사용하는 주소 정보
Application, presentation, Session - message
Transport - TCP-segment UDP-Datagram 전체-packet
Network - Datagram
Data link - frame
Physical - bit
###### Circuit Switching Network와 Packet Switching Network와의 차이
Packet Switching: 출발 IP와 목적지 IP만 가지며, 각 교차로마다 목적지 주소를 보고 어디로 갈 지 결정한다.
Circuit Switching: 중앙서버에서 출발지부터 목적지까지 어떻게 이동해야하는지 그 패킷만의 경로를 알려준다.
###### 리피터의 종류와 하는 역할
Repeater: 1:1로 리피터끼리 패킷을 통신하며 신호가 약해지거나 손상되기 전에 신호를 재생성하여 네트워크의 길이를 확장한다.
Hub: 1대n이 가능한 리피터
Bridge: 필터링 기능이 있는 리피터
Switch: 필터링 기능이 있는 허브
필터링 기능: 데이터 링크 계층에서 switch가 어디서 온 frame인지 저장해두고 이를 다시 보낼 때 이 저장된 정보를 이용해 frame을 보낸다.
###### Network Layer 보고 문제 풀 수 있도록 하기\
![[Pasted image 20240909153120.png]]
###### Stream delivary란?
application 계층에서 만든 message의 boundary를 상관하지 않고 필요한만큼 끊어서 transport layer끼리 통신하는 방식
###### Buffer의 세 가지 영역과 sent 영역이 필요한 이유
sent, not sent, empty
요청을 받는 쪽에서 데이터를 받지 못했을 때 다시 보내줘야 하므로 데이터를 보내도 이를 삭제하지 않고 카피본을 만들어두는 것을 sent 영역이라고 한다. (transport layer의 일로 application을 다시 호출하지 않기 위해)
###### Boundary delivary란?
UDP가 사용하는 방식으로 message에서 만들어진 boundary가 전달이 될 때 유지된다.
###### Selective ACK과 Cumulative ACK의 차이
Selective ACK: 101을 받았다면, 101을 받았다고 응답하는 방식
Cumulative ACK: 101-200을 받았다면, 201을 받고 싶다고 응답하는 방식
###### HLEN의 역할과 특징
역할: 헤더가 얼마만큼의 크기를 가지는지 알기위해 사용
특징: 비트 수를 아끼기 위해 비트를 4로 나눈 값을 사용한다.
따라서 4씩 증가한다.
###### Control field의 역할
ACK, SYN, FIN에 대한 번호를 보니니까 체크해야함을 알려주는 bit
###### Checksum의 역할
패킷들이 전송되다가 물리적으로 어떤 비트가 전송 중에 오류가 발생하는 것을 체크하기 위해서 필요한 것 TCP에서는 필수, UDP에서는 Optional이다.
###### Pseudoheader의 내용과 역할
보내는 쪽 IP주소와 받는 쪽 IP주소, protocal, TCP 전체 길이
IP주소를 더 확실하게 체크하기 위해 Pseudoheader를 붙여 checksum을 보낸다.
###### rwnd란?
receiver의 window size로 byte단위이다.
window size란 receiver가 받을 수 있는 data의 크기를 말한다. (receiver의 버퍼가 비워져 있는 크기)
###### 연결 three-way handshake시에 client와 server의 state
client
SYN과 SYN+ACK 사이의 상태를 이름을 지은 것 = SIN-SENT
SYN/ACK이 되면 ACK을 보내고 ESTABLISHED 상태

server
SYN을 받기 전 상태 = LISTEN
SYN을 받은 상태 SYN-SENT
ACK을 받은 상태 ESTABLISH
###### 종료 three-way handshake시에 client와 server의 state
client
FIN을 보낸 상태 FIN-WAIT-1
ACK을 받은 상태 FIN-WAIT-2
FIN을 받은 상태 TIME-WATE (바로 끝나지 않고 Maximum Segment Lifetime(msl) 만큼 기다렸다가 CLOSE로 변한다)
ACK을 보낸 상태 CLOSED

server
FIN을 받고 ACK을 보낸 상태: CLOSE-WAIT
FIN을 보낸 상태 LAST-ACK
ACK을 받은 상태: CLOSED (버퍼 및 소켓 삭제)
###### Half-Close가 발생하는 상황
종료 요청은 보통 클라이언트가 번저하는데, 서버가 더 보낼 내용이 있다면 데이터를 다 보낸 이후에 FIN을 보낸다.
client는 Half-close를 해서 FIN을 보내고, 서버에 데이터를 보낼 수는 없지만 서버가 보낸 데이터에 ACK으로 응답은 해줄 수 있다.
###### Time-Wait이 필요한 이유
서버는 이전 연결과 이후 연결을 IP와 포트 번호로 구분한다.
따라서 종료 이후 연결이 IP 주소와 port번호가 똑같이 오게 되면 새로운 것이 온건지 종료된 이전 것이 온건지 구분하기 어렵다.
따라서 port를 반납하지 않고 Time-wait을 걸어 요청이 들어왔을 때 무시한다.
패킷은 1-2분 후에 자동 소멸하므로 Time-wait만큼 기다린 후, 그 IP와 port로 들어오는 요청은 새로운 요청으로 간주한다.

또한 FIN/ACK을 보내고 ACK을 못 받았을 때, ACK을 다시 요청하면 ACK을 보내도록 대기시킨다.
###### Client가 FIN을 보냈을 때 서버 소켓이 알아듣는 방법
read시에 return값이 0이면 FIN으로 간주한다. (이외에는 항상 0보다 크다)
###### 문제
###### 문제
###### 문제
###### 문제
###### 문제
# 이전 문제
Cumulative ACK의 단점
Fast retransmission을 사용하는 이유와 방식
Nagle 알고리즘이 만들어진 이유와 방식
state 알기
time_wait이 필요한 이유
sylliy window가 어디서 어떤 상황에 발생하는지
stop&wait 방식의 단점
이를 해결하기 위한 방식
TCP 헤더는 옵션을 사용하기도 하고 안 하기도 하는데 옵션을 사용하는 60bytes 헤더랑 옵션을 사용하지 않는 헤더랑 어떻게 구분하는지 설명해라.
fast retransmission 상황에서 빈칸(seq, ACK 등) 주고 채우시오.


5. RTT가 다른 두 connection connection A(RTT=1) & connection B(RTT=2) 에 대해 cwnd 그래프 그리기. (cwnd최대20종료)
	1. 조건1 두 ssthreshold = 8
	2. 조건2 9초에 A가 Time-out
	3. 조건3 14초에 B가 3ACK
	4. 조건4 18초에 B가 3ACK
	5. 22초에 종료
![[Pasted image 20241011204437.png]]
![[Pasted image 20241011204631.png]]
RTT 100ms일 때 특정 구간까지 cwnd 값과 시간 나타내는 문제 2개
ex) E부터 F까지 나타내기
rwnd, SYN, ACK 등 연결 three-way handshake 주어지고 (cwnd는 고려 x) throughput 계산하기. Bps 단위로 작성할 것.
## 실습
fork를 사용하여 동시에 두 명 이상의 클라이언트에게 서비스를 제공할 수 있도록 하기
ip와 port 출력하는 방법
![[Pasted image 20241011205018.png]]