## Delivery
전달의 두 가지 방식
- 직접 전달
- 간접 전달
## 직접 전달
![[Pasted image 20241125145055.png|400]]
같은 네트워크에서 직접 전달하는 것을 Direct Delivery라 한다.
## 간접 전달
![[Pasted image 20241125145510.png|400]]
A가 B한테 데이터를 보낼 때 다른 네트워크를 거쳐 가는 것을 간접 전달이라 한다.
라우터가 라우터로 보내는 것도 간접전달이고, 라우터가 내부에 있는 B로 전달하는 것은 Direct delivery이다.

# Forwarding
라우팅 테이블을 보고 next hop으로 가게끔 interface에 패킷을 가져다 두는 것
forwarding -> 라우팅 테이블도 같이 일을 한다.
목적지 주소를 보고 전달하는 것이 기본이고, Label을 보고 전달하기도 한다.
## Next-hop method
![[Pasted image 20241125145904.png|400]]
a. 경로 중심의 라우팅 테이블
A에서 B로 가는 모든 경로를 라우팅 테이블에서 저장해둔다
b. next hope 기반의 라우팅 테이블
A에서 B로 갈 때 next hop의 경로만 라우팅 테이블에서 저장해둔다.

## Network-specific method
![[Pasted image 20241125150145.png|400]]
N2가 class A라면 라우팅 테이블은 N2에 대해서만 1600만개의 주소를 저장하고 있어야 한다.
그래서 사실 S 입장에서는 A,B,C,D가 어디있는지는 몰라도 된다.
S는 자신이 누구에게 패킷을 보내면 되는지에 대해서만 알면 된다.
그래서 N2를 대표하는 주소를 정해놓는 것이다.
=> 그래서 Network 주소를 mask하는 것
이렇게 되면 라우팅 테이블에서 class A의 1600만개의 주소를 단 한 개의 주소를 라우팅 테이블에 저장함으로써 절약할 수 있다.
![[Pasted image 20241125150554.png|400]]
라우팅 테이블에는 네트워크에 대한 정보를 저장할 때도 있지만, Host의 주소를 구체적으로 적을 때도 있다 => Host-specific routing
따라서 라우팅 테이블에는 네트워크 주소만 들어가는 것이 아닌 호스트 주소가 들어갈 수도 있다.
## Default routing
![[Pasted image 20241125150757.png|400]]
라우팅 테이블은 주변에 있는 정보만 가지고 있어도 된다.
그림에서 R1이 아니면 모두 R2를 거쳐서 데이터를 보내도록 한다 => Default routing
## Simplified forwarding module in *classful address without subneting*
![[Pasted image 20241125151006.png|500]]
주소를 받았을 때 라우터가 어떠한 일을 하는지?
1. 목적지 주소를 받는다.
2. class를 찾는다
3. class별로 mask를 적용한다. (class별로 라우팅 테이블을 따로 관리한다.)
4. table을 찾는다.
## example
### example 1
![[Pasted image 20241125151238.png|400]]
라우터 R1의 라우팅 테이블 만들기

해결 방법
그림 6.9는 라우터 R1이 사용하는 세 가지 테이블을 보여줍니다. 다음 홉 주소 열의 일부 항목이 비어 있는 것을 주목하세요. 이는 이러한 경우에 목적지가 라우터가 연결된 동일한 네트워크 내에 있기 때문입니다(직접 전달). 이러한 경우, ARP에서 사용하는 다음 홉 주소는 단순히 패킷의 목적지 주소입니다.

![[Pasted image 20241125151430.png|400]]
direct delivery는 next-hop  address가 비어있다.
class 별로 라우팅 테이블이 구성되어 있다.
indirect delivery는 라우터의 next-hop address가 저장되어 있다.
R3가 192.16.7.0에 direct하게 보내준다.
라우터는 연결되는 네트워크마다 주소를 할당받는다.
-> R1은 170.14.0.0 네트워크에서는 170.14.5.165라는 이름으로, 145.80.0.0 네트워크에서는 145.80.7.11이라는 이름으로, 11.0.0.0 네트워크에서는 111.25.19.20이라는 이름으로 할당받은 것
### example 2
그림 6.8에서 라우터 R1이 목적지 주소 192.16.7.14를 가진 패킷을 수신합니다. 패킷이 어떻게 전달되는지 보여주세요.

해결 방법
목적지 주소는 `11000000 00010000 000001110 0001110` 입니다. (class C이므로 3:1로 나뉨)
네트워크 주소는 목적지 주소의 가장 왼쪽 24비트를 마스킹하여 추출됩니다. 결과는 192.16.7.0입니다. 
클래스 C의 테이블을 검색합니다. 
네트워크 주소가 첫 번째 행에서 발견됩니다. 
다음 홉 주소 111.15.17.32와 인터페이스 m0가 ARP로 전달됩니다 (hop to hop은 ARP로 전달되어야 하기 때문)
### example 3
그림 6.8에서 라우터 R1이 목적지 주소 167.24.160.5를 가진 패킷을 수신합니다. 패킷이 어떻게 전달되는지 보여주세요.

해결 방법
목적지 주소의 이진수는
10100111 00011000 10100000 00000101 입니다.
클래스는 B입니다. 네트워크 주소는 목적지 주소의 16비트를 마스킹하여 찾을 수 있습니다. 결과는 167.24.0.0입니다.
클래스 B의 테이블을 검색합니다. 일치하는 네트워크 주소를 찾을 수 없습니다. 
패킷은 기본 라우터로 전달되어야 합니다(네트워크는 인터넷의 다른 곳에 있습니다). 
다음 홉 주소 111.30.31.18과 인터페이스 번호 m0가 ARP로 전달됩니다.
## Simplified forwarding module in *classful address* *with subnetting*
![[Pasted image 20241125153812.png|400]]
서브넷이 있는 경우에는 밖에서는 몰라도 되게끔 구성한다.
네트워크 내에서는 서브넷이 몇 개가 생겼고, mask는 어떻게 되는지 다 세팅해주어야 한다. 그래야 라우터가 라우팅 테이블을 보고 다 찾아놓을 수 있다.
1. 처음에는 패킷 주소를 본다
2. subnet mask를 통해 subnet address를 찾아낸다
3. 테이블을 찾는다.

![[Pasted image 20241125154349.png|400]]
네트워크가 어떻게 구축되어 있는지 라우터는 알아야 한다.
mask를 어떻게 해야하는지 라우터는 알아야 한다.
### example 4
그림 6.11에서 라우터가 목적지 주소 145.14.32.78인 패킷을 수신합니다. 이 패킷이 어떻게 전달되는지 보여주세요.

해결책
마스크는 /18입니다. 마스크를 적용한 후, 서브넷 주소는 145.14.0.0입니다. 패킷은 다음 홉 주소 145.14.32.78과 나가는 인터페이스 m0를 사용하여 ARP(8장을 참조)에 전달됩니다.
### example 5
그림 6.11에서 네트워크 145.14.0.0에 있는 호스트가 주소 7.22.67.91인 호스트에게 보낼 패킷을 가지고 있습니다. 이 패킷이 어떻게 라우팅되는지 보여주세요.

해결책
라우터는 패킷을 수신하고 마스크 (/18)를 적용합니다. 네트워크 주소는 7.22.64.0입니다. 테이블을 검색했으나 주소가 발견되지 않습니다. 라우터는 기본 라우터의 주소를 사용하여(그림에 표시되지 않음) 그 라우터로 패킷을 보냅니다.
## Simplified forwarding module in *classless address*
classful에서는 최소 3개의 컬럼만 있으면 된다 => destination, next hop, interface
하지만 classless에서는 mask라는 컬럼도 추가적으로 필요하다.

![[Pasted image 20241120153750.png|500]]
### example 6
![[Pasted image 20241120153833.png|600]]
![[Pasted image 20241120153839.png|600]]
네트워크 4개 연결, 최소한 4개의 정보는 direct하게 연결되어 저장되어 있고
다른 정보도 가질 수 있음

mask가 가장 큰 것이 맨 위로 온다.
![[Pasted image 20241120153946.png|600]]

### example 7
다음은 패킷이 목적지 주소 180.70.65.140로 R1에 도착했을 때의 포워딩 과정을 보여줍니다.

**해결 방법:**
라우터는 다음 단계를 수행합니다:
1. 첫 번째 마스크 (/26)를 목적지 주소에 적용합니다. 결과는 180.70.65.128로, 해당 네트워크 주소와 일치하지 않습니다.
2. 두 번째 마스크 (/25)를 목적지 주소에 적용합니다. 결과는 180.70.65.128로, 해당 네트워크 주소와 일치합니다. 다음 홉 주소(이 경우 패킷의 목적지 주소)와 인터페이스 번호 m0가 ARP(8장에서 다룸)로 전달되어 추가 처리를 진행합니다.
![[Pasted image 20241120154005.png]]


패킷이 목적지 주소 201.4.22.35로 R1에 도착했을 때의 포워딩 과정을 보여줍니다.
**해결 방법:**
라우터는 다음 단계를 수행합니다:
1. 첫 번째 마스크 (/26)를 목적지 주소에 적용합니다. 결과는 201.4.22.0으로, 해당 네트워크 주소(1행)와 일치하지 않습니다.
2. 두 번째 마스크 (/25)를 목적지 주소에 적용합니다. 결과는 201.4.22.0으로, 해당 네트워크 주소(2행)와 일치하지 않습니다.
3. 세 번째 마스크 (/24)를 목적지 주소에 적용합니다. 결과는 201.4.22.0으로, 해당 네트워크 주소와 일치합니다.
![[Pasted image 20241120154304.png|600]]



패킷이 목적지 주소 18.24.32.78로 R1에 도착했을 때의 포워딩 과정을 보여줍니다.
**해결 방법:**
이번에는 모든 마스크가 목적지 주소에 적용되지만 일치하는 네트워크 주소를 찾을 수 없습니다. 테이블 끝에 도달하면 모듈은 다음 홉 주소 180.70.65.200과 인터페이스 번호 m2를 ARP(8장에서 다룸)로 전달합니다. 이는 아마도 인터넷의 다른 곳으로 보내야 하는 패킷일 것입니다.
![[Pasted image 20241120154317.png|600]]
다 안되면 default로 보내서 다른 인터넷으로 간다.


이제 다른 유형의 예제를 살펴보겠습니다. 라우팅 테이블만 알고 있을 때 라우터의 구성을 찾을 수 있을까요? 라우터 R1의 라우팅 테이블이 표 6.2에 주어져 있습니다. 그 토폴로지를 그릴 수 있을까요?
**해결 방법:**
몇 가지 사실은 알고 있지만 명확한 토폴로지를 위해 모든 것을 알고 있는 것은 아닙니다. 라우터 R1에는 세 개의 인터페이스: m0, m1, m2가 있다는 것을 알고 있습니다. 라우터 R1에 직접 연결된 세 개의 네트워크가 있다는 것을 알고 있습니다. R1에 간접적으로 연결된 두 개의 네트워크가 있다는 것을 알고 있습니다. 적어도 세 개의 다른 라우터가 관련되어 있어야 합니다(다음 홉 열을 참조). 네트워크 140.6.12.64가 R3에 직접 연결되어 있는지 또는 포인트 투 포인트 네트워크(WAN)와 다른 라우터를 통해 연결되어 있는지 알 수 없습니다. 그림 6.14는 우리가 추측한 토폴로지를 보여줍니다.

![[Pasted image 20241120154317.png|500]]

![[Pasted image 20241120154949.png|500]]
![[Pasted image 20241120155000.png|500]]



인하 안경, 인하 칼국수, 인하 반점, 인하 짬뽕은 다 다른 네트워크지만, 비슷한 위치에 있다는 공통점이 있음 (용현동임)
그러면 부산에서 가려면 굳이 구별 안해도 됨 여러 주소를 사용하지 않고 한 주소로 합칠 수 있음
=> address aggregation 

근데 인하 짬뽕이 부산으로 옮긴다면 aggregation을 못쓰는가?
no 예외처리를 할 수 있다,
인하 짬뽕만 먼저 처리하면 된다.
이후 인하짬뽕이 아닌 인하를 처리한다
![[Pasted image 20241120160011.png]]
라우팅 테이블 ->  위에서 부터 하나씩 하고 맞으면 거기서 끝난다 따라서 예외 처리를 가장 위에 써놓는다.
Longest mask matching => 가장 긴 마스크부터 매칭해본다

## Multiprotocol label switching (MPLS)
![[Pasted image 20241120160832.png|500]]
왜 나왔는가? => ?
우리 동만 관리하는 택배아저씨는 ~시 ~로 ~동을 확인하지 않음 호수만 크게 작성해서 빠르게 작업할 수 있도록 함
따라서 택배 회사마다 label을 달아둔다.
MPLS가 되는 네트워크에는 label을 붙여 사용한다.
위치는 IP 헤더 앞에 

![[Pasted image 20241120161137.png|500]]
IP 주소 없고, 숫자가지고 일을 함
라우팅 테이블을 새로 만드는 것, 왜냐하면 라우팅 테이블은 탐색 시간이 n만큼 걸리기 때문

