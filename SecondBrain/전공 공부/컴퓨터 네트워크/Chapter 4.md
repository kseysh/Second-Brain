# TCP 서버의 기본적인 함수호출 순서
![[Pasted image 20241001142259.png|300]]
## 소켓의 종류
1. 일반 소켓
2. 서버 소켓
	1. 서버 소켓은 `listen`이라는 함수를 통해 SYN이 오면 SYN/ACK을 보내주는 역할을 한다. (일반 소켓은 SYN이 와도 별다른 대처를 하지 않음)

## 연결 요청 대기 상태로의 진입
![[Pasted image 20241001143237.png|400]]
SYN/ACK을 보내면 ACK이 올 때까지 연결 요청 대기 큐라는 곳에서 ACK을 기다린다. (한 순간에 한 명씩만 처리한다.)
## 클라이언트의 연결요청 수락
![[Pasted image 20241001143344.png|400]]
ACK이 오면 `accept`라는 함수에서 연결 요청 대기 큐에서 값을 빼온다.
서버 소켓은 연결 요청을 받아주는 역할만 한다. (서버 소켓 = 114, 클라이언트 소켓 = 상담 직원)
이후 서버 소켓은 accept 함수를 통해 client socket을 새로 생성해주고, 그 클라이언트 소켓끼리 서로 통신(write, read)을 한다.

# TCP 클라이언트의 기본적인 함수호출 순서
![[Pasted image 20241001152718.png|200]]
![[Pasted image 20241001152733.png|400]]
## TCP 기반 서버, 클라이언트의 함수 호출 관계
![[Pasted image 20241001152831.png|400]]
- `connect` 함수는 SYN을 보내고, SYN/ACK이 올 때까지 대기하다, SYN/ACK이 오면 return한다.
- read가 block 함수이기 때문에 둘 중 누가 write를 하고, read를 할지 정해둬야 한다. 안 그러면 아무 일도 안 일어난다.
- 확인할 사항은, 서버의 listen 함수호출 이후에야 클라이언트의 connect 함수호출이 유효하다는 점이다. 더불어 그 이유까지도 설명핛 수 있어야 한다.
# Iterative 서버의 구현
![[Pasted image 20241001153328.png|150]]
 - 이 그림에서는 반복적으로 accept 함수를 호출하면, 계속해서 클라이언트의 연결요청을 수락할 수 있지만, 동시에 둘 이상의 클라이언트에게 서비스를 제공할 수 있는 모델은 아니다.
 - 서버는 계속 살아있고, 클라이언트를 계속 serve해준다.
## Iterative 서버와 클라이언트의 일부
 ![[Pasted image 20241001154435.png|500]]
 상대방이 FIN을 보낼 때만 str_len이 0이된다.
 따라서, FIN을 보내야만 cln_sock이 close된다.
## 에코 클라이언트의 문제점
 ![[Pasted image 20241001154855.png|500]]