## Dotted-decimal notation
![[Pasted image 20241105204343.png|500]]
IP 주소는 32Bit의 Binary다. 
표기가 편하게 byte 단위로 끊어 십진법으로 사용한다.

## IPv4 Binary -> decimal
![[Pasted image 20241105204613.png|500]]
### 자주 사용하는 Binary
![[Pasted image 20241105204658.png|200]]

## IPv4 decimal -> Binary
![[Pasted image 20241105204740.png|500]]

![[Pasted image 20241105204817.png|500]]

![[Pasted image 20241105204920.png|500]]
IPv4는 16진수로는 잘 안 쓰고 MAC은 16진수로 사용한다.

![[Pasted image 20241105205004.png|500]]

![[Pasted image 20241105205114.png|500]]
32개의 주소가 필요하면 31을 더하는 것에만 유의하자

![[Pasted image 20241105205307.png|500]]\
\= 14.11.46.40

## NOT operation
![[Pasted image 20241105205700.png|500]]
십진법으로 할 때는 두 개 합쳐서 255가 나오도록 하면 된다.

## AND operation
![[Pasted image 20241105205736.png|500]]
## OR operation
![[Pasted image 20241105205845.png|500]]

2의 32승 = 약 40억
![[Pasted image 20241105232543.png|500]]

![[Pasted image 20241105232637.png|500]]
시작 주소가 0으로 시작하면 Class A => 0 - 127로 시작 => 20억
시작 주소가 10으로 시작하면 Class B => 128 - 191로 시작 => 10억
시작 주소가 110으로 시작하면 Class C => 192 - 223로 시작 => 5억
시작 주소가 1110으로 시작하면 Class D => 224 - 239로 시작 => 2.6억
시작 주소가 1111으로 시작하면 Class E =>  240 - 255로 시작 =>2.6억

![[Pasted image 20241105233212.png|500]]

![[Pasted image 20241105234239.png|500]]
![[Pasted image 20241105234256.png|500]]

![[Pasted image 20241105234412.png|500]]
클래스마다 끊어읽는 곳이 다르다.
 NetId: 각 네트워크마다 대표하는 번호가 있는데 그것을 Network Id 즉 NetId라고 한다.
 HostId: 네트워크 아이디 내에서 가질 수 있는 번호
## Class
![[Pasted image 20241105235029.png|400]]
Class A는 첫 번째 바이트만 NetId, 나머지는 HostId이다.
따라서 class A는 128개의 block이 있고 한 개의 블록은 2의 24승인 1600만개의 HostId를 표현할 수 있다.
class를 구매하면 hostId는 마음대로 부여할 수 있는 권한을 얻게 된다.
![[Pasted image 20241106153006.png|500]]
![[Pasted image 20241106153016.png|500]]
실제로 사용되는 것은 보통 ABC이다.

![[Pasted image 20241106153030.png|500]]
multicast용도로 사용
![[Pasted image 20241106153037.png|500]]
나중을 위해 잡아둔 것

IP는 이렇게 두 가지로 끊어읽을 수 있다.
![[Pasted image 20241106153139.png|500]]

![[Pasted image 20241106153224.png|500]]

![[Pasted image 20241106153251.png|500]]
73.22.17.25라는 IP주소를 보고 알 수 있는 내용
1. class A라는 점 (앞이 73이기에) 속한 네트워크 블록내 주소는 1600만개가 있다.
2. 첫 번째 주소를 찾기 위해, 가장 왼쪽 8비트를 유지하고, 오른쪽 24비트를 모두 0으로 설정합니다. 첫 번째 주소는 73.0.0.0/8이며, 여기서 8은 n의 값입니다.
3. 마지막 주소를 찾기 위해, 가장 왼쪽 8비트를 유지하고, 오른쪽 24비트를 모두 1로 설정합니다. 마지막 주소는 73.255.255.255입니다.
![[Pasted image 20241106153440.png|500]]
시작 주소는 대표 주소로, 마지막 주소는 directed broadcast address 용도로 사용된다.

![[Pasted image 20241106153535.png|500]]
1. 이 블록 내 주소 수는 N = 2<sup>32-n</sup> = 65,536 입니다.
2. 첫 번째 주소를 찾기 위해, 가장 왼쪽 16비트를 유지하고, 오른쪽 16비트를 모두 0으로 설정합니다. 첫 번째 주소는 180.8.0.0/16이며, 여기서 16은 n의 값입니다.
3. 마지막 주소를 찾기 위해, 가장 왼쪽 16비트를 유지하고, 오른쪽 16비트를 모두 1로 설정합니다. 마지막 주소는 180.8.255.255입니다.
![[Pasted image 20241106153642.png|500]]
일반적으로 라우터가 IP를 가지고 있고 Switch는 IP를 가지지 않는다.
Switch는 MAC주소를 사용한다.

![[Pasted image 20241106153909.png|500]]
1. 이 블록 내 주소 수는 N = 2<sup>32-n</sup> = 256입니다.
2. 첫 번째 주소를 찾기 위해, 가장 왼쪽 24비트를 유지하고, 오른쪽 8비트를 모두 0으로 설정합니다. 첫 번째 주소는 200.11.8.0/24이며, 여기서 24는 n의 값입니다.
3. 마지막 주소를 찾기 위해, 가장 왼쪽 24비트를 유지하고, 오른쪽 8비트를 모두 1로 설정합니다. 마지막 주소는 200.11.8.255/24입니다.

![[Pasted image 20241106153918.png|500]]

![[Pasted image 20241106154024.png|600]]
박스 = 하나의 Network
라우터는 IP주소를 가진다.

![[Pasted image 20241106154411.png|600]]

![[Pasted image 20241106154654.png|600]]
라우터는 NetId만 보고 라우팅을 한다.

### Network Mask
![[Pasted image 20241106155533.png|400]]
NetId만 보기 위해서

## Finding a network address using the default mask
![[Pasted image 20241106155637.png|500]]

![[Pasted image 20241106155714.png|500]]
라우터가 목적지 주소 201.24.67.32를 가진 패킷을 수신합니다. 라우터가 패킷의 네트워크 주소를 찾는 방법을 보여주세요.
해결 방법:
해당 주소의 클래스가 C이기 때문에, 라우터는 클래스 C의 기본 마스크인 255.255.255.0을 적용하여 네트워크 주소를 찾는다고 가정합니다.

![[Pasted image 20241106155836.png|500]]
이렇게 하면 너무 불편하다

![[Pasted image 20241106160219.png|500]]
라우팅할 때 grouping을 해서 네트워크의 네트워크를 두고, 이것을 서브넷이라고 한다.

![[Pasted image 20241106160529.png|500]]
예를 들어 860 -> 학교 번호 7 -> 단과대학을 나타내는 번호라고 가정하자.
7이 소프트웨어 융합학과라면, 각 단과대는 1000개의 전화번호를 쓸 수 있고, 단과대는 최대 10개가 가능하다.

만약 서브넷이 네 개 필요하다면 00,01,10,11로 서브넷을 나누어 각 네트워크의 시작 주소로 활용한다.
따라서 141.14.0.0, 141.14.64.0, 141.14.128.0, 141.14.192.0 는 각 서브넷의 시작 주소이다.

## Network mask and subnetwork mask
![[Pasted image 20241106161008.png|500]]

![[Pasted image 20241106161241.png|500]]
16bit가 원래 mask를 위해 필요한 mask 비트지만, 서브넷을 보기 위해서는 log<sub>2</sub>4를 더해 18bit여야 mask를 위해 쓸 수 있다
![[Pasted image 20241121110519.png|500]]
![[Pasted image 20241121110638.png|500]]
8개의 subnet을 만들기 위해 subnet id를 log<sub>2</sub>8인 3비트를 더 사용한다.
supernet -> 잘 안쓰임

# Classless addressing
classful address의 단점: 128은 너무 크고, 65200은 너무 크다.
그래서 근본적인 문제를 해결하기 위해 클래스 자체를 없앴다. => Classless addressing

![[Pasted image 20241121111207.png|500]]
classful address는 큰 block이 앞에 오지만, classless address는 그런 순서가 필요없다.
두 단계로 끊어 읽는 것은 동일하지만, 예전에는 byte 단위로 끊어 읽던 것을 이제는 bit 단위로 끊어 읽기 시작한다.
그래서 구분을 위해 prefix, suffix라는 단어를 사용하기 시작한다.
![[Pasted image 20241121111508.png|400]]


prefix의 길이는 1에서 32까지 간다.

### Example
인터넷 전체를 하나의 블록으로 간주하여 4,294,967,296개의 주소가 있을 때, 접두사 길이와 접미사 길이는 무엇인가?
해답:
이 경우 접두사 길이는 0이고 접미사 길이는 32입니다. 32비트 모두가 변하여 호스트를 이 단일 블록에서 정의합니다.

인터넷을 4,294,967,296개의 블록으로 나누고 각 블록이 하나의 주소를 갖는다면, 접두사 길이와 접미사 길이는 무엇인가?
해답:
이 경우 각 블록의 접두사 길이는 32이고 접미사 길이는 0입니다. 32비트 모두가 변하여 블록을 정의합니다. 각 블록에서 유일한 주소는 그 블록 자체에 의해 정의됩니다.

## Slash notation
![[Pasted image 20241121111912.png|300]]
class가 없기 때문에, slash를 하고 prefix 길이를 같이 써줘야 한다.

### Example
classful에서는 block의 주소만 알고도 block의 길이, block의 시작주소, 마지막 주소를 알 수 있었지만, classless에서는 prefix length를 알아야 알 수 있다.

클래스리스 주소 지정에서는 주소 자체만으로 그 주소가 속한 블록을 정의할 수 없습니다. 예를 들어, 주소 230.8.24.56은 여러 블록에 속할 수 있으며, 그 중 몇 가지는 다음과 같이 해당 블록과 연관된 접두사 값과 함께 나타낼 수 있습니다:
클래스리스 주소 지정에서는 항상 slash notation이 들어가야 한다.
![[Pasted image 20241121112243.png|500]]

#### ex 1
다음 주소들은 슬래시 표기법으로 정의됩니다.
a. 주소 12.23.24.78/8에서 네트워크 마스크는 255.0.0.0입니다. 마스크는 8개의 1과 24개의 0을 가집니다. 접두사 길이는 8이고, 접미사 길이는 24입니다. => network mask가 8bit까지 1인 것
b. 주소 130.11.232.156/16에서 네트워크 마스크는 255.255.0.0입니다. 마스크는 16개의 1과 16개의 0을 가집니다. 접두사 길이는 16이고, 접미사 길이는 16입니다.
c. 주소 167.199.170.82/27에서 네트워크 마스크는 255.255.255.224입니다. 마스크는 27개의 1과 5개의 0을 가집니다. 접두사 길이는 27이고, 접미사 길이는 5입니다.

#### ex 2
하나의 주소가 167.199.170.82/27인 블록이 있습니다. 네트워크 내 주소의 수, 첫 번째 주소, 마지막 주소를 찾아보세요.
총 주소 개수 = 2<sup>32-suffix</sup>

해답:
n의 값은 27입니다. 네트워크 마스크는 27개의 1과 5개의 0을 가집니다. 이는 255.255.255.224입니다.
a. 네트워크 내 주소의 수  2<sup>32-suffix</sup> = 32개
b. 첫 번째 주소(네트워크 주소)를 찾기 위해 AND 연산을 사용합니다. 첫 번째 주소는 167.199.170.64/27입니다.A
c. 마지막 주소를 찾기 위해 먼저 네트워크 마스크의 보수를 찾고, 주어진 주소와 OR 연산을 수행합니다. 마지막 주소는 167.199.170.95/27입니다.
![[Pasted image 20241121113209.png|500]]
![[Pasted image 20241121113610.png|500]]
#### ex 3
하나의 주소가 17.63.110.114/24인 블록이 있습니다. 블록 내 주소의 수, 첫 번째 주소, 마지막 주소를 찾아보세요.

해답:
네트워크 마스크는 255.255.255.0입니다.
a. 네트워크 내 주소의 수는 256개입니다.
b. 첫 번째 주소를 찾기 위해 이 장 초반에 논의한 간단한 방법을 사용합니다. 첫 번째 주소는 17.63.110.0/24입니다.
c. 마지막 주소를 찾기 위해 네트워크 마스크의 보수와 이전에 논의한 첫 번째 간단한 방법을 사용합니다. 마지막 주소는 17.63.110.255/24입니다.
![[Pasted image 20241121113623.png|500]]
![[Pasted image 20241121113632.png|500]]
#### ex 4
하나의 주소가 110.23.120.14/20인 블록이 있습니다. 블록 내 주소의 수, 첫 번째 주소, 마지막 주소를 찾아보세요.

해답:
네트워크 마스크는 255.255.240.0입니다.
a. 네트워크 내 주소의 수는 개입니다.
b. 첫 번째 주소를 찾기 위해 바이트 1, 2, 4에는 첫 번째 간단한 방법을, 바이트 3에는 두 번째 간단한 방법을 적용합니다. 첫 번째 주소는 110.23.112.0/20입니다.
c. 마지막 주소를 찾기 위해 바이트 1, 2, 4에는 첫 번째 간단한 방법을, 바이트 3에는 두 번째 간단한 방법을 적용합니다. 마스크의 보수에 OR 연산을 수행합니다. 마지막 주소는 110.23.127.255/20입니다.
![[Pasted image 20241121113707.png|500]]
십진법끼리의 and는 binary로 변경해서 한다.
![[Pasted image 20241121113714.png|500]]

#### ex 5
ISP(internet service provider)가 1000개의 주소 블록을 요청했습니다. 다음과 같은 블록이 할당되었습니다.

a. 1000은 2의 제곱수가 아니므로, 1024개의 주소가 할당됩니다. (1024 = 2<sup>10</sup>).
b. 블록의 접두사 길이는 32 - log<sub>2</sub>1024 = 22로 계산됩니다.
c. 시작 주소는 18.14.12.0으로 선택됩니다 (이는 1024로 나누어집니다).
할당된 블록은 18.14.12.0/22입니다. 첫 번째 주소는 18.14.12.0/22이고, 마지막 주소는 18.14.15.255/22입니다.

필요한 주소의 길이는 suffix를 이용해 구하므로, 32-prefix의 값을 이용해 구해야 한다.
###### 18.14.13.0은 선택될 수 없는 이유
18.14.12.0 -> 18.14.00001100.00000000
18.14.13.0 -> 18.14.00001101.00000000
18.14.12.0은 suffix가 0으로 채워진 값을 얻어 0 ~ 1024개의 주소를 사용할 수 있지만, 18.14.13.0은 suffix가 0으로 채워진 값이 10개가 되지 못하므로 18.14.13.0은 선택될 수 없다. (prefix가 다르면 하나의 network라고 할 수 없다.)

## classful을 slash notation으로 한다면?
![[Pasted image 20241121114848.png]]
### ex 1
한 조직이 과거에 클래스 A 블록인 73.0.0.0을 부여받았다고 가정해보자. 만약 해당 블록이 권위자에 의해 취소되지 않았다면, 클래스리스 아키텍처에서는 해당 조직이 클래스리스 주소 체계에서 73.0.0.0/8 블록을 가지고 있다고 가정한다.

### ex 2
한 조직이 130.34.12.64/26 블록을 부여받았습니다. 이 조직은 각기 동일한 수의 호스트를 가진 네 개의 서브네트워크가 필요합니다. 서브네트워크를 설계하고 각 네트워크에 대한 정보를 찾아보십시오.

해결책:
전체 네트워크의 주소 수는 N = 2<sup>(32 − 26)</sup> = 64입니다. 네트워크의 첫 번째 주소는 130.34.12.64/26이고, 마지막 주소는 130.34.12.127/26입니다. 이제 서브네트워크를 설계해봅시다:
1. 첫 번째 요구 사항을 충족하기 위해 각 서브네트워크에 16개의 주소를 부여합니다 (64/16은 2의 제곱수입니다).
2. 각 서브네트워크의 서브네트워크 마스크는 : ![[Pasted image 20241121115011.png|400]]
3. 첫 번째 사용 가능한 주소부터 시작하여 각 서브넷에 16개의 주소를 부여합니다. 그림 5.30은 각 서브넷의 서브블록을 보여줍니다. 각 서브네트워크의 시작 주소는 해당 서브네트워크의 주소 수로 나누어 떨어지는 수임을 유의하십시오.
4개로 나눠야 하므로 log<sub>2</sub>4만큼 더 prefix로 활용한다.
![[Pasted image 20241121151940.png|200]]  =>  ![[Pasted image 20241121152224.png|200]]

### ex 2 solution
![[Pasted image 20241121153423.png|500]]
### ex 3
156.34.13.35/25 주소가 속한 네트워크를 4개의 subnet으로 구성하기
156.34.13.0/25
156.34.13.32/25
156.34.13.64/25
156.34.13.96/25

### ex 4
87.105.43.95/23 주소가 속한 네트워크를 8개의 subnet으로 구성하기
128+64
95 => 64, 16,8,4,2,1, => 0101 1111 
43 => 32, 8,2,1

87.105.0010 101/1.01/01 1111 
87.105.43.0/26
87.105.43.64/26
87.105.43.128/26
87.105.43.192/26
87.105.42.0/26
87.105.42.64/26
87.105.42.128/26
87.105.42.192/26

### ex 5
조직은 14.24.74.0/24의 시작 주소로 주소 블록을 할당받았습니다. 조직은 아래와 같이 세 개의 서브넷에서 사용할 세 개의 서브 블록이 필요합니다:
❑ 120개의 주소를 가진 서브 블록 하나.
❑ 60개의 주소를 가진 서브 블록 하나.
❑ 10개의 주소를 가진 서브 블록 하나.

해결 방법:
1. 32-n개가 0으로 가득채운 것을 포함하는지 확인
2. 아니라면 0으로 가득채우도록 만들기
3. 0000 ~ 1111까지가 만드는 방법

이 블록에는 2<sup>32</sup> - 2<sup>24</sup> = 256개의 주소가 있습니다. 첫 번째 주소는 14.24.74.0/24이고 마지막 주소는 14.24.74.255/24입니다.
a. 첫 번째 서브 블록의 주소 개수는 2의 제곱수가 아닙니다.
- 첫 번째 주소는 14.24.74.0/25이고 마지막 주소는 14.24.74.127/25입니다.
b. 두 번째 서브 블록의 주소 개수도 2의 제곱수가 아닙니다. 
- 이 블록의 첫 번째 주소는 14.24.74.128/26이고 마지막 주소는 14.24.74.191/26입니다.
c. 세 번째 서브 블록의 주소 개수도 2의 제곱수가 아닙니다.
- 이 블록의 첫 번째 주소는 14.24.74.192/28이고 마지막 주소는 14.24.74.207/28입니다.
d. 이전 서브 블록의 모든 주소를 더하면 208개의 주소가 됩니다. 이는 48개의 주소가 예약되어 있음을 의미합니다. 이 범위의 첫 번째 주소는 14.24.74.208입니다. 마지막 주소는 14.24.74.255입니다.
e. 그림 5.31은 블록의 구성을 보여줍니다. 우리는 각 블록의 첫 번째 주소를 보여주었습니다.

![[Pasted image 20241121161601.png|500]]
![[Pasted image 20241121161630.png|500]]

14.24.74.0/24 16
14.24.74.00000000-00001111
14.24.74.0/28
14.24.74.0/28 64 = 2 8
14.24.74.16/
### ex 6
![[Pasted image 20241121162258.png|500]]
이렇게 작은 것부터 배정하게 되면 짜투리가 남아 사용하기 불편해진다.

### ex 7
(작은 것 부터 작업하지 않는 이상 default는 큰 것부터 만드는 것이 default이다.)
회사가 중앙, 동부, 서부에 세 개의 사무실을 가지고 있다고 가정합시다.
중앙 사무실은 동부 및 서부 사무실과 전용 WAN 라인으로 연결되어 있습니다.
회사는 70.12.100.128/26의 시작 주소를 포함한 64개의 주소 블록을 부여받았습니다.
관리진은 중앙 사무실에 32개의 주소를 할당하고 나머지 주소를 나머지 두 사무실에 나누기로 결정했습니다.

1. 각 사무실에 할당된 주소 수는 다음과 같습니다:
• 중앙 사무실: 32개의 주소
• 동부 사무실: 16개의 주소
• 서부 사무실: 16개의 주소

2. 각 서브네트워크의 프리픽스 길이는 다음과 같이 찾을 수 있습니다:
• 중앙 사무실: /27 (32개의 주소)
• 동부 사무실: /28 (16개의 주소)
• 서부 사무실: /28 (16개의 주소)

70.12.100.10/00 0000
- 70.12.100.128/27
- 70.12.100.160/28
- 70.12.100.176/28

3. 그림 5.32는 경영진에 의해 설계된 구성을 보여줍니다. 중앙 사무실은 주소 70.12.100.128/27에서 70.12.100.159/27을 사용합니다. 회사는 이 주소들 중 세 개를 라우터에 사용하고, 서브 블록의 마지막 주소를 예약해 두었습니다. 동부 사무실은 주소 70.12.100.160/28에서 70.12.100.175/28을 사용합니다. 이 주소들 중 하나는 라우터에 사용되며, 회사는 서브 블록의 마지막 주소를 예약해 두었습니다. 서부 사무실은 주소 70.12.100.176/28에서 70.12.100.191/28을 사용합니다. 이 주소들 중 하나는 라우터에 사용되며, 회사는 서브 블록의 마지막 주소를 예약해 두었습니다. 회사는 WAN의 포인트 투 포인트 연결에 주소를 사용하지 않습니다.
![[Pasted image 20241121163945.png|500]]

### ex 8
ISP는 190.100.0.0/16 (65,536개의 주소)로 시작하는 주소 블록을 부여받았습니다. ISP는 이 주소들을 다음과 같이 세 그룹의 고객에게 분배해야 합니다:

❑ 첫 번째 그룹에는 64명의 고객이 있으며, 각 고객은 약 256개의 주소가 필요합니다.
❑ 두 번째 그룹에는 128명의 고객이 있으며, 각 고객은 약 128개의 주소가 필요합니다.
❑ 세 번째 그룹에는 128명의 고객이 있으며, 각 고객은 약 64개의 주소가 필요합니다.

우리는 서브 블록을 설계하고 이러한 할당 후에 여전히 사용 가능한 주소가 얼마나 되는지 알아봅니다.

해결 방법
문제를 두 단계로 해결해 봅시다. 첫 번째 단계에서는 각 그룹에 서브 블록의 주소를 할당합니다. 각 그룹에 할당된 총 주소 수와 각 서브 블록의 접두사 길이는 다음과 같이 구할 수 있습니다.
 ![[Pasted image 20241121165435.png|500]]
그림 5.33은 첫 번째 계층 수준에 대한 설계를 보여줍니다. 그림 5.34는 계층의 두 번째 수준을 보여줍니다. 각 고객에 대해 첫 번째 주소를 서브넷 주소로 사용하고 마지막 주소를 특별 주소로 예약했음을 주목하세요.
![[Pasted image 20241121165929.png|400]]

![[Pasted image 20241121165445.png|500]]

![[Pasted image 20241121165453.png|600]]

# Special Addresses
## all-zero address
보통 컴퓨터는 고정 IP가 아닌 유동 IP를 사용하는데, 이 때 IP를 할당해주는 것이 DHCP 서버이다.
 DHCP에게 내가 어떤 주소를 쓰면 되는지 물어볼 때 할당해주는 것이 DHCP 서버이다. (공유기가 이 역할을 한다.)
 자신의 IP주소도 모르고 DHCP주소도 모르기 때문에, 묻는 IP를 0.0.0.0으로, 답하는 IP를 255.255.255.255로 보내서 IP를 할당 받는다.
![[Pasted image 20241121171148.png|300]]

## loopback address
서버에서 테스트를 하고 싶을 때, 한 컴퓨터 안에서 주고 받는 주소
![[Pasted image 20241121171014.png|300]]
## limited broadcast address
![[Pasted image 20241121171023.png|400]]
destination IP address를 255.255.255.255로 보낸 주소는 broadcast주소라고 한다.
보내게 되면 같은 network에 모든 IP에 전송한다.
라우터는 broadcast address를 block해야 한다. (block하지 않으면 계속 라우터를 통해 다른 곳으로 전송될 수 있기 때문에.)
따라서 limited broadcast address라 한다.
## directed broadcast address
![[Pasted image 20241121172321.png|400]]
suffix가 모두 1인 경우 directed broadcast address라 하며, 다른 라우터에게 보낼 데이터가 있을 때 directed broadcast address를 이용하여 보낸다.

## 사설망 주소
![[Pasted image 20241121172942.png|500]]
IP주소가 사설망 주소인지, 아닌지 구분하기 어렵기 때문에 사설망 주소를 따로 분리해두었다.

## NAT (network address translation)
사설망을 쓰기 위해 꼭 필요한 것
![[Pasted image 20241125142609.png|400]]
라우터도 network에 의해 IP 주소를 할당받는다.
밖에서 사용할 고유한 public IP (138.76.29.7)
![[Pasted image 20241125142650.png|400]]
1. 10.0.0.1이 128.119.40.186에 접속하고 싶은 상황
2. 그렇다면 10.0.0.1이라는 주소를 자신의 주소(라우터의 public IP 주소)로 변경한다.
	1. 사설망 내에 같은 목적지를 원하는 컴퓨터가 있을 수 있으므로 포트번호와 사설망 주소를 테이블로 관리한다.
	2. 10.0.0.1 3345라는 것을 저장하기 위해 사용하지 않는 port 번호를 저장해둔다.
	3. 그 후 패킷의 IP주소를 바꿔 보낸다.
3. 응답 패킷이 138.76.29.7 5001로 응답패킷이 온다면
4. 라우터는 NAT translation table을 찾아보고 원래 패킷이 가야할 10.0.0.1 3345로 보내준다.
NAT를 사용하면 IP주소 한 개로도 여러 네트워크를 꾸밀 수 있게 된다.
### port forwarding
admin이 공유기에 들어가서 8001 -> 192.168.0.1 3456으로 보내달라고 설정하는 것
(NAT 장비가 자동으로 하느냐 매뉴얼로 해주냐에 대한 차이)


