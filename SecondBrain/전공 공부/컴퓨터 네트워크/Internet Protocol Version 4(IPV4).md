## IP Diagram
![[Pasted image 20241125162536.png|400]]
### Service type
서비스 타입은 잘 쓰이지 않음(TCP 헤더의 Argent pointer처럼)
### Total length
![[Pasted image 20241125163428.png]]
 헤더와 데이터를 포함한 Datagram의 전체 길이
 만약 1byte의 데이터를 보낸다면, TCP 기본 헤더 20 IP 기본 헤더 20 총 41byte를 보내게 된다.
 그 후 frame도 헤더와 트레일러를 붙이게 되는데  처음 frame을 디자인할 때 frame의 payload가 최소 46byte가 되도록 디자인 하여 만약 41byte가 minimum이므로 이를 채우기 위해 Padding값이 들어가게 된다.
 상대방은 이 값을 받아 Padding만큼은 버려야하는데, 따라서 어느정도 길이까지가 표현해야 하는 값이다라는 것을 알려주기 위해서 Total Length가 필요하다.
16byte를 할당했으므로 IP datagram은 최대 65535byte까지 갈 수 있다.
### Time to live
만약 패킷이 roop로 인해 계속 돌게 되면 이는 시간이 지나면 사라지도록 해야한다.
이를 해결하기 위해 소멸되는 시간을 작성한다.
하지만 시간을 다루기가 복잡하여 maximum hop count를 작성해서 hop to hop을 할 때마다 1씩 감소시켜 반환한다.
만약 0이 되면 패킷을 전달하지 않고 버린다.
### Protocol
Transport layer에는 TCP와 UDP, Network layer에는 ICMP, IGMP, OSPF라는 protocol이 있는데, 
ICMP, IGMP, OSPF는 같은 network layer일지라도 IP헤더를 포함을 하고 전송되는 프로토콜이라 안에 표기를 한다.
상위 프로토콜을 표기함으로써 Multiplexing과 DeMultiplexing이 일어난다. 
TCP로 보낼지, UDP로 보낼지를 헤더에 적어놓는다.
![[Pasted image 20241125164146.png|400]]
## example
### example 1
IP 패킷이 첫 번째 8비트가 다음과 같이(010000010) 도착했습니다:
수신자는 패킷을 폐기합니다. 왜일까요?

해결책:
이 패킷에는 오류가 있습니다. 왼쪽에서부터 4비트(0100)는 버전을 나타내며, 이는 올바릅니다(IPv4이므로). 
다음 4비트(0010)는 잘못된 헤더 길이(2 × 4 = 8)를 나타냅니다. 
헤더의 최소 바이트 수는 20이어야 합니다. 
이 패킷은 전송 중 손상되었습니다.
### example 2
IP 패킷에서 HLEN 값이 이진수로 1000입니다. 이 패킷이 옵션으로 몇 바이트를 전송하고 있습니까?

해결책:
HLEN 값은 8입니다. 이는 헤더의 총 바이트 수가 8 × 4, 즉 32바이트임을 의미합니다. 첫 20바이트는 기본 헤더이고, 다음 12바이트는 옵션입니다.
### example 3
IP 패킷에서 HLEN 값이 5이고 total length 필드 값이 0028<sub>16</sub>입니다. 이 패킷이 전송하고 있는 데이터는 몇 바이트입니까?

해결책:
HLEN 값은 5입니다. 이는 헤더의 총 바이트 수가 5 × 4, 즉 20바이트(옵션 없음)임을 의미합니다. 
총 길이는 40바이트입니다. 
이는 패킷이 20바이트의 데이터를 전송하고 있음을 의미합니다(40 − 20).
### example 4
IP 패킷이 다음과 같은 16진수 숫자로 도착했습니다:
`45000028000100000102...`
이 패킷이 폐기되기 전까지 몇 홉을 이동할 수 있습니까?
이 데이터는 어떤 상위 레이어 프로토콜에 속합니까?

해결책:
4bit -> 1byte
TTL -> `01`(9번째 byte)
time-to-live 필드를 찾기 위해 우리는 8바이트(16진수 16자리)를 건너뜁니다. time-to-live 필드는 아홉 번째 바이트로, 이는 01입니다. 이는 패킷이 단 하나의 홉만 이동할 수 있음을 의미합니다. 프로토콜 필드는 다음 바이트(02)로, 이는 상위 레이어 프로토콜이 IGMP임을 의미합니다(표 7.2 참조). (프로토콜 번호는 몰라도 됨)
## Fragmentation
![[Pasted image 20241125170826.png|400]]
Frame의 payload부분에 minimum 값이 존재하고 그게 46byte이다. MTU라고 불리는 maximum값도 존재를 하는데, 이는 physical network마다 다르다.
따라서 physical network마다 허용하는 IP datagram의 최대값이 다르다.
## Flags field
![[Pasted image 20241125171129.png|300]]
physical network마다 허용하는 IP datagram의 최대값이 다르므로 datagram이 분할 될 수도 있다.
D는 이것은 분할하지 말라는 의미이고, 그에 따라 전송되지 못하면 패킷을 버린다.
M은 분할 후 재조합할 때 사용하는 field이다. (마지막 패킷이 뭔지를 찾아보기 위해 사용하는 field)
## Fragmentation example
![[Pasted image 20241125171634.png|400]]
Fragmentation offset으로 분할한 것의 번호를 붙이는데, Fragmentation offset이 최대 13bit이므로 최대 8000정도까지 분할이 가능하다.
하지만 IP datagram의 max length는 65535bit이므로 최대 65535라는 번호를 붙일텐데, 13bit만으로는 원하는 만큼 분할하지 못할 수도 있다. 그래서 HLEN처럼 없어진 3bit를 위해 곱하기 8을 해준다.
Fragmentation에는 처음부터 얼마나 떨어져 있는지에 대한 값을 저장해둔다.
#### MTU
MTU는 header와 data가 포함된 값이다.
패킷이 분할된 상황에서 MTU를 추측해볼 수 있는데, 헤더 20 byte, 0000부터 1399까지 1400 byte이므로 MTU가 1420byte임을 추측할 수 있다.
## Detailed fragmentation example
![[Pasted image 20241125204803.png|400]]
맨 마지막 패킷은 More fragments를 0으로 해준다.
상황에 따라서 패킷의 경로가 달라질 수도 있는데, 분할이 또 되는 case가 있다면 또 분할된다. (example 참고)
## example
### example 1
패킷이 M 비트 값이 0인 상태로 도착했습니다. 이것이 첫 번째 조각인가요, 마지막 조각인가요, 아니면 중간 조각인가요? 패킷이 조각화되었는지 알 수 있나요?

해결책
M 비트가 0이면 더 이상 조각이 없다는 의미이므로 이 조각은 마지막 조각입니다. 
그러나 원래 패킷이 fregmented되었는지는 알 수 없습니다. fregmented되지 않은 패킷도 마지막 조각으로 간주됩니다.
### example 2
패킷이 M 비트 값이 1인 상태로 도착했습니다. 이것이 첫 번째 조각인가요, 마지막 조각인가요, 아니면 중간 조각인가요? 패킷이 조각화되었는지 알 수 있나요?

해결책
M 비트가 1이면 적어도 하나 이상의 조각이 더 있다는 의미입니다. 
이 조각은 첫 번째 조각이거나 중간 조각일 수 있지만 마지막 조각은 아닙니다. 
이것이 첫 번째 조각인지 중간 조각인지는 알 수 없습니다. 더 많은 정보(fragmentation offset 값)가 필요합니다.
### example 3
M 비트 값이 1이고 조각화 오프셋 값이 0인 상태로 패킷이 도착했습니다. 이것이 첫 번째 조각인가요, 마지막 조각인가요, 아니면 중간 조각인가요?

해결책
M 비트가 1이므로 첫 번째 조각이거나 중간 조각입니다. 오프셋 값이 0이므로 이것은 첫 번째 조각입니다.
### example 4
오프셋 값이 100인 상태로 패킷이 도착했습니다. 첫 번째 바이트 번호는 무엇인가요? 마지막 바이트 번호를 알 수 있나요?

해결책
첫 번째 바이트 번호를 찾으려면 오프셋 값을 8로 곱합니다. 즉, 첫 번째 바이트 번호는 800입니다. 데이터의 길이를 알지 못하면 마지막 바이트 번호를 알 수 없습니다.
### example 5
오프셋 값이 100이고 HLEN 값이 5이며 총 길이 필드 값이 100인 상태로 패킷이 도착했습니다. 첫 번째 바이트 번호와 마지막 바이트 번호는 무엇인가요?

해결책
첫 번째 바이트 번호는 100 × 8 = 800입니다. 총 길이는 100바이트이고 헤더 길이는 20바이트(5 × 4)입니다. 즉, 이 데이터그램에는 80바이트가 포함되어 있습니다. 첫 번째 바이트 번호가 800이면 마지막 바이트 번호는 879여야 합니다.
![[Pasted image 20241125210054.png|200]]
## Option
![[Pasted image 20241125210251.png|500]]
Copy only in first fragment => 분리될 때 옵션을 첫 패킷에만 가지고 가고 나머지는 가져가지 않음

![[Pasted image 20241125210508.png|350]]
single-byte -> padding용 option (중요 x)
## Record-route option
![[Pasted image 20241125210714.png|400]]
## Record route concept
![[Pasted image 20241125211902.png|500]]
첫 번째에 있는 것은 첫 번째 라우터의 라우터 IP 주소, 두 번째에 있는 것은 두 번째 라우터의 라우터 IP 주소이다.
record route option을 이용해서 어느 라우터들을 거쳐왔는지 알 수 있다.
라우터는 최소 두개의 IP 주소를 갖는다. 왜냐하면 라우터는 왼쪽 네트워크의 멤버이기도 하고, 오른쪽 네트워크의 멤버이기도 하기 때문이다.
들어오는 쪽이 아닌 나가는 쪽의 라우터 주소를 갖는다. 그래야 돌아오면서 어떤 라우터를 지나왔는지 알 수 있다.
## Strict-source-route option
![[Pasted image 20241125212338.png|400]]

![[Pasted image 20241125212511.png|500]]
Sender가 패킷을 보내서 거쳐가야할 라우터의 순서를 미리 정해두는 것.
Destination과 IP address가 계속 바뀌면서 포인터 값이 4만큼 증가한다.
그 후 다음 번 라우터로 보내준다.
여기서는 라우터 이전의 라우터 주소를 사용한다. (어느 라우터로 가야하는지를 알아야하기 때문)
만약, 보내야 할 next가 연결되어 있지 않거나 유효하지 않으면 패킷을 버린다.
그래서 패킷이 잘 갔다면 반드시 경로대로 갔다는 것을 보장한다.
일반적인 사용자들보다는 네트워크 관리자가 사용한다 (어떤 경로로 보낼 수 있는지 테스트하기 위해 사용)
## Loose-source-route option - 개념만 알아도 됨
Strict-source-route-option에서는 보내야 할 next가 연결되어 있지 않거나 유효하지 않으면 패킷을 버리지만, Loose-source-route option에서는 순서가 약간 바뀌거나 중간에 다른 곳을 거쳐와도 패킷을 버리지 않는다.
## Time-stamp option - 크게 안 중요함
![[Pasted image 20241127151053.png|500]]
## Use of flags in timestamp
![[Pasted image 20241127151103.png|500]]
안 외워도 됨
## Timestamp concept
![[Pasted image 20241127151137.png|500]]
## example
### ex1
여섯 가지 옵션 중 어떤 것을 각 프래그먼트에 복사해야 하는가?

해결책:
각 옵션의 유형의 첫 번째 (가장 왼쪽) 비트를 봅니다.
a. 작업 없음: 유형은 00000001; 복사하지 않음.
b. 옵션 끝: 유형은 00000000; 복사하지 않음.
c. 경로 기록: 유형은 00000111; 복사하지 않음.
d. 엄격한 소스 경로: 유형은 10001001; 복사함.
e. 느슨한 소스 경로: 유형은 10000011; 복사함.
f. 타임스탬프: 유형은 01000100; 복사하지 않음.
### ex2
여섯 가지 옵션 중 어떤 것이 데이터그램 제어에 사용되고 어떤 것이 디버깅 및 관리에 사용되는가?

해결책:
각 옵션의 유형의 두 번째와 세 번째 (가장 왼쪽) 비트를 봅니다.
a. 작업 없음: 유형은 00000001; 데이터그램 제어.
b. 옵션 끝: 유형은 00000000; 데이터그램 제어.
c. 경로 기록: 유형은 00000111; 데이터그램 제어.
d. 엄격한 소스 경로: 유형은 10001001; 데이터그램 제어.
e. 느슨한 소스 경로: 유형은 10000011; 데이터그램 제어.
f. 타임스탬프: 유형은 01000100; 디버깅 및 관리 제어.
## IP components
![[Pasted image 20241127152828.png|500]]
읽어만 보자
```tex
Header_Adding_Module (data, destination_address)
1. 데이터와 목적지 주소를 인수로 받습니다.
2. 데이터를 IP 데이터그램에 캡슐화합니다.
3. 체크섬을 계산하고 체크섬 필드에 삽입합니다.
4. 데이터를 해당 큐로 보냅니다.
5. 반환합니다.
```

```tex
IP_Processing_Module (Datagram)
1. 입력 큐 중 하나에서 데이터그램을 제거합니다.
2. 목적지 주소가 로컬 주소와 일치하면:
	• 데이터그램을 reassembly 모듈로 보냅니다.
	• return
3. 만약 장치가 라우터라면:
	• TTL(Time To Live)을 감소시킵니다.
1. TTL이 0 이하가 되면:
	• 데이터그램을 폐기합니다.
	• ICMP 오류 메시지를 보냅니다.
	• return.
5. 데이터그램을 포워딩 모듈로 보냅니다.
6. return
```

```tex
IP_Fragmentation_Module (datagram) {
데이터그램의 크기를 추출합니다.
• If 데이터그램의 크기가 해당 네트워크의 MTU(Maximum Transmission Unit)보다 크다면:
	• If D 비트가 설정되어 있다면:
		• 데이터그램을 폐기합니다.
		• ICMP 오류 메시지를 보냅니다.
		• return.
	• else:
		• 최대 크기를 계산합니다.
		• 세그먼트를 여러 조각으로 나눕니다.
		• 각 조각에 헤더를 추가합니다.
		• 각 조각에 필요한 옵션을 추가합니다.
		• 조각을 보냅니다.
		• return.
else:
	• 데이터그램을 보냅니다.
return.
}
```

## Reassembly table
![[Pasted image 20241127154456.png|500]]
재조합은 목적지 컴퓨터에서만 하기로 한다.
IP layer에서는 어떤 것이 없어져도 재전송 요구하지 않는다 (재전송 요구는 TCP 쪽에서 하기 때문이다.)
IP layer에서는 datagram이 없어지면 통째로 날라간다.
fragmentation 중 하나만 없어져도 tcp입장에서는 하나가 통째로 날라간 것이므로 통째로 날라가버린다. 복구에 걸리는 오버헤드가 커진다.

segment를 크게 만들었을 때의 부작용 설명하기:
packet loss detact도 늦어지고 fragmentatioin 중 하나만 없어져도 tcp는 큰 하나가 통째로 날라간거라 tcp가 복구할 때 분리되지 않은 전체를 복구해야 한다. 따라서 복구에 걸리는 오버헤드가 커진다.

```
IP_Reassembly_Module (데이터그램)
{
    If (오프셋 값 = 0 && M = 0) // datagram의 분할이 일어나지 않았을 때
    {
        데이터그램을 적절한 큐로 보냄
        return
    }
    
    재조립 테이블에서 항목을 검색
    If (항목을 찾지 못한 경우)
    {
        새로운 항목을 만듦
    }
    
    데이터그램을 연결 리스트에 삽입
    If (모든 조각이 도착한 경우)
    {
        조각을 재조립
        조각을 상위 계층 프로토콜로 전달
        return
    }
    else
    {
        If (타임아웃이 만료된 경우)
        {
            모든 조각을 폐기
            ICMP 오류 메시지를 보냄
        }
    }
    
    return
}
```
