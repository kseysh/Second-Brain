### 디렉토리
- 디렉토리 항목을 포함하는 파일.
- 파일에 사용되는 많은 시스템 호출이 디렉토리를 조작하는 데 사용할 수 있습니다.
- 디렉토리와 일반 파일의 차이점:
  - 디렉토리는 open 시스템 호출을 사용하여 생성할 수 없습니다.
  - O_WRONLY 또는 O_RDWR 플래그가 설정된 상태에서 디렉토리를 열려고 하면 (errno=EISDIR) 오류가 발생합니다.
  - 디렉토리를 write를 사용하여 업데이트하는 것은 불가능합니다.
  - 오직 커널만이 디렉토리에 쓸 수 있습니다.
- 디렉토리는 포함된 각 파일이나 하위 디렉토리에 대해 하나의 디렉토리 항목으로 구성됩니다.
- 디렉토리 항목은 다음으로 구성됩니다:
  - i-노드 번호
  - 문자 필드
![[Pasted image 20241009165646.png|300]]
### 링크 및 언링크
- 각 링크는 원본과 동일한 i-노드 번호를 가진 새로운 디렉토리 슬롯과 새 이름을 생성합니다.
- unlink 시스템 호출을 사용하여 링크를 제거할 때:
  - 해당 파일명에 대한 마지막 링크를 나타내는 경우, 전체 i-노드 구조가 지워집니다.
### 닷과 더블닷
- `.` : 현재 작업 디렉토리
- `..` : 부모 디렉토리
![[Pasted image 20241009165226.png|400]]
### ex)
![[Pasted image 20241009165747.png|450]]
![[Pasted image 20241009170053.png|450]]
## 디렉토리 권한
- 디렉토리 권한은 일반 파일 권한과 정확히 동일한 방식으로 구성됩니다.
- 하지만, 해석 방식이 다릅니다.
  - **읽기 권한**: 파일이나 하위 디렉토리의 이름 목록을 볼 수 있습니다.
  - **쓰기 권한**: 새로운 파일을 생성하거나 기존 파일을 제거할 수 있습니다.
  - **실행 권한(검색 권한)**: 디렉토리로 이동하거나 프로그램 내에서 chdir 시스템 호출을 사용할 수 있습니다.
- 예를 들어, 파일 `/usr/include/stdio.h`를 열려면:
  - `/`, `/usr`, `/usr/include`에 대해 실행 권한이 필요합니다.
- 디렉토리에 대한 읽기 권한과 실행 권한은 다른 의미를 가집니다.
  - **읽기 권한**: 디렉토리 내의 모든 파일명을 얻습니다.
  - **실행 권한**: 디렉토리를 통과하여 특정 파일명을 검색할 수 있습니다. (search permission으로 생각하자)
- 따라서 디렉토리에 대한 실행 권한 비트는 종종 검색 비트라고도 합니다.
- 저장-텍스트-이미지(sticky bit) - S_ISVTX
  - 이 비트가 디렉토리에 설정된 경우: **owner여야 한다.**
    - 다음 중 하나를 만족해야만 디렉토리에 대한 쓰기 권한으로 파일을 제거하거나 이름을 변경할 수 있습니다:
      - 파일의 owner
      - 디렉토리의 owner
      - 슈퍼유저
  - 사용자들은 다른 사람들이 소유한 파일을 삭제하거나 이름을 변경할 수 없습니다.

#### sgt 표기 위치
![[Pasted image 20241009171348.png]]
# 4.4 디렉토리 프로그래밍
## dirent 구조체
```c
#include <dirent.h>
struct dirent {
	ino_t d_ino; /* i-node number */
	char d_name[NAME_MAX + 1]; /* null-terminated filename */
}
```
- d_inode의 값이 0인 것은 디렉토리에서 빈 슬롯을 나타냅니다.
## mkdir(2) 시스템 호출
```c
#include <sys/stat.h>
int mkdir(const char *pathname, mode_t mode);
// Returns: 0 if OK, -1 on error
```
- 권한은 프로세스의 umask 값에 의해 수정됩니다.
- mkdir은 새로 생성된 디렉토리에 두 개의 링크 `.`와 `..`를 추가한다는 점입니다.
- 일반 파일처럼 읽기 및 쓰기 권한만 지정하는 실수를 저지르는 경우가 많다 . 
	- 하지만 디렉토리의 경우, 디렉토리 내 파일명에 접근할 수 있도록 적어도 하나의 excute bit가 활성화되어야 한다.
![[Pasted image 20241009171718.png]]
excute permission이 없으면 cat을 통해 파일 안의 특정 파일명을 검색할 수 없다.
read permission이 없으면 ls를 통해 디렉토리 내의 모든 파일명을 얻을 수 없다
## rmdir(2) 시스템 호출
```c
#include <unistd.h>
int rmdir(const char *pathname);
// Returns: 0 if OK, -1 on error
```
- 빈 디렉토리는 rmdir 함수로 삭제됩니다. (비지 않으면 삭제 못함)
- 빈 디렉토리는 `.`와 `..` 항목만 포함하는 디렉토리입니다.
## opendir(3)
```c
#include <dirent.h>
DIR *opendir(const char *dirname);
// Returns: pointer if OK, NULL on error
```
- DIR은 표준 I/O 라이브러리에서 사용되는 FILE 타입과 유사한 방식으로 작동합니다.
- 항상 null 포인터를 테스트하는 적절한 오류 검사 코드를 작성해야 합니다.
- 프로그램이 디렉토리 접근을 마치면 닫아야 합니다. 이것은 closedir 함수로 달성할 수 있습니다.
## closedir(3)
```c
#include <dirent.h>
int closedir(DIR *dirptr);
// Returns: 0 if OK, -1 on error
```
- closedir 함수는 인수로 주어진 dirptr이 가리키는 디렉토리 스트림을 닫습니다.
![[Pasted image 20241009172204.png|450]]
## readdir(3)
```c 
#include <dirent.h>
struct dirent *readdir(DIR *dp);
// Returns: pointer if OK, NULL at end of directory or error
```
- 첫 번째 readdir에서 첫 번째 디렉토리 항목이 struct dirent로 읽힙니다. (directory entry)
- 완료 시 디렉토리 포인터는 디렉토리의 다음 항목으로 이동합니다.
## rewinddir(3)
```c
#include <dirent.h>
void rewinddir(DIR *dp);
// Returns: 0 if OK, -1 on error
```
- rewinddir 호출 후, 다음 readdir은 dp가 가리키는 디렉토리의 첫 번째 항목을 반환합니다.
![[Pasted image 20241009172812.png|500]]

dirname 아래 파일에서 주어진 접미사로 끝나는 첫 번째 파일을 찾는 함수
첫 번째 검색 find_entry(\_,suffix,0)
두 번째 이후 검색 find_entry(\_,suffix,1)
![[Pasted image 20241009173221.png|500]]
![[Pasted image 20241009173234.png|500]]

**현재 작업 디렉토리**
- 각 UNIX 프로세스는 고유한 현재 작업 디렉토리를 가집니다.
- 사용자와 관련된 현재 디렉토리는 실제로 그의 명령을 해석하는 셸 프로세스와 관련된 현재 작업 디렉토리입니다.
- 처음에는 프로세스의 현재 작업 디렉토리가 프로세스를 시작한 프로세스의 현재 작업 디렉토리로 설정됩니다. 이는 보통 셸입니다.

**chdir(2) 시스템 호출**
- 이 변경은 chdir을 호출하는 프로세스에만 적용됩니다.
- **오류**
  - 경로가 유효한 디렉토리를 정의하지 않습니다.
  - 모든 구성 요소 디렉토리에 실행 권한이 없습니다.
- 디렉토리를 변경하고 이 새 디렉토리에 상대적인 파일명을 사용하는 것이 절대 파일명을 사용하는 것보다 더 효율적입니다.

**getcwd(3)**
- 현재 디렉토리 경로명을 가리키는 포인터를 반환합니다.
- 현재 디렉토리 이름이 name이 가리키는 배열에 복사됩니다.
- **name 할당 문제**
  - 구현은 시스템에 따라 다릅니다.
  - POSIX.1은 PATH_MAX 값(<limits.h>)으로 도움을 주려고 합니다.
  - 할당된 공간이 너무 작으면 오류가 반환되고 errno는 ERANGE로 설정됩니다.

### ftw(3) (1/2)

- **기능**: 지정된 디렉토리에서 시작하여 디렉토리 트리를 순회하며, 발견된 각 디렉토리 항목에 대해 사용자 정의 루틴을 호출합니다.
- **종료 조건**:
  - 사용자 정의 함수가 0이 아닌 값을 반환할 때
  - 오류가 발생할 때
  - 트리의 끝에 도달할 때
- **인수**:
  - **path**: 디렉토리 경로명
  - **depth**: 사용되는 파일 디스크립터 수를 제어
  - **func**: 사용자 정의 함수
    - **name**: 객체 이름
    - **sptr**: 객체에 대한 stat 구조체
    - **type**: <ftw.h>
      - FTW_F: 파일
      - FTW_D: 디렉토리
      - FTW_DNR: 읽을 수 없는 디렉토리
      - FTW_SL: 심볼릭 링크
      - FTW_NS: 심볼릭 링크가 아니고 stat 실행 실패 (stat(2) 오류)

### 4.5 UNIX 파일 시스템

**캐싱, sync 및 fsync**
- 메모리에서 디스크로의 모든 전송(즉, 쓰기)은 즉시 디스크에 기록되지 않고 일반적으로 운영 체제의 데이터 공간에 캐시됩니다.
- 읽기도 캐시 내에서 버퍼링됩니다.
- UNIX는 버퍼의 데이터를 디스크에 쓰기 위한 두 가지 함수를 제공합니다.
  - **sync**: 파일 시스템에 대한 정보를 포함하는 메인 메모리 버퍼를 디스크에 플러시하는 데 사용됩니다.
  - **fsync**: 특정 파일과 관련된 모든 데이터와 속성을 플러시하는 데 호출됩니다.

**sync(2) & fsync(2) 시스템 호출**
- **중요한 차이점**:
  - fsync는 모든 파일 데이터가 디스크에 기록될 때까지 반환하지 않습니다.
  - sync 호출은 데이터 쓰기가 예약되었지만 완료되지 않았을 때 반환할 수 있습니다.
- UNIX 시스템은 sync를 반복적으로 호출하는 코드를 지속적으로 실행합니다.

### 4.6 UNIX 장치 파일

**UNIX 장치 (1/2)**
- UNIX에서 장치는 할당된 장치 번호로 접근됩니다.
  - 장치 번호는 **주 번호**와 **부 번호**로 구성됩니다.
  - **주 번호**: 장치 유형 (장치 드라이버)
  - **부 번호**: 특정 장치의 인스턴스
- 사용자는 특정 장치에 접근하기 위해 장치 번호를 사용하고 싶어하지 않습니다.
  - UNIX는 장치 번호를 장치 파일에 매핑합니다.
- **장치 파일**:
  - 따라서 장치 파일의 i-노드에는 장치 번호가 포함됩니다 (inode->i_rdev).
  - 주변 장치에 대한 간단한 인터페이스를 제공합니다.
  - 파일 시스템에 나타납니다.
  - 사용자는 표준 시스템 호출을 사용하여 장치에 접근하고 이를 일반 컴퓨터 파일처럼 취급합니다.
  - 슈퍼유저만이 장치 파일을 생성할 수 있습니다.

**UNIX 장치 파일**
- 주변 장치는 파일 시스템의 파일 이름을 통해 접근됩니다.
  - 디스크, 터미널, 프린터, 테이프 유닛 등
- 일반 디스크 파일과 달리, 이들 장치 파일에 대한 읽기와 쓰기는 시스템과 해당 주변 장치 간에 데이터를 직접 전송합니다.
- 이러한 특수 파일은 /dev 디렉토리에 저장됩니다.
- 장치 파일은 명령 레벨이나 프로그램 내에서 일반 파일처럼 사용할 수 있습니다.

**블록 및 문자 장치 파일 (1/3)**
- **블록 장치 파일**:
  - 디스크, 자기 테이프, 블록 단위로 전송, 랜덤 접근
  - 파일 시스템은 블록 장치에서만 존재할 수 있으며, 이러한 블록 장치에는 종종 raw 장치로 알려진 연관된 문자 장치가 있습니다 (mkfs, fsck).
- **문자 장치 파일**:
  - 터미널, 모뎀, 프린터, 랜덤 접근 (할 수도 있고 아닐 수도 있음)
- UNIX는 주변 장치와 상호작용하기 위해 두 개의 운영 체제 구성 테이블을 사용합니다 (I/O 함수).
  - **블록 장치 스위치 테이블**: bdevsw[]
  - **문자 장치 스위치 테이블**: cdevsw[]
- 두 테이블 모두 장치 파일의 i-노드에 저장된 주요 장치 번호를 사용하여 인덱싱됩니다.
- 주변 장치로 데이터 전송을 위한 순서는 다음과 같습니다:
  - 읽기 또는 쓰기 시스템 호출이 장치 파일의 i-노드에 정상적으로 접근합니다.
  - 시스템은 i-노드 구조 내의 플래그를 확인하여 장치가 블록 장치인지 문자 장치인지를 확인합니다. 주요 번호도 추출됩니다.
  - 주요 번호는 적절한 장치 구성 테이블을 인덱싱하는 데 사용되며, 장치 특정 드라이버 루틴이 호출되어 데이터 전송을 수행합니다.
  - 부 장치 번호도 i-노드에 저장되며, 장치 드라이버 루틴에 전달되어 여러 주변 포트를 지원하는 장치의 경우 정확히 어떤 포트가 접근되고 있는지를 식별합니다.
### stat 구조체 재방문 (1/3)

- **st_mode**: 해당 파일명을 포함하는 파일 시스템의 장치 번호 및 해당 i-node를 나타냅니다.
- **st_rdev**: 문자 특수 파일과 블록 특수 파일만 st_rdev 값을 가집니다.
  - 대부분의 구현에서는 major와 minor 매크로가 정의되어 있습니다. (<sys/types.h>)

### 파일 시스템 정보 (1/2)

- **statvfs와 fstatvfs**는 사용 가능한 전체 디스크 블록 수와 사용 가능한 i-node 수와 같은 기본 파일 시스템 정보를 얻기 위해 호출될 수 있습니다.

### 제한 (1/4)

- 두 가지 유형의 제한이 필요합니다.
  - 컴파일 타임 제한 (예: short 정수의 최대 값은 얼마인가?)
  - 런타임 제한 (예: 파일 이름에 몇 글자가 들어갈 수 있는가?)
- 이러한 문제를 해결하기 위해 세 가지 유형의 제한이 제공됩니다.
  - 컴파일 타임 제한 (헤더 파일)
  - 파일이나 디렉토리와 관련이 없는 런타임 제한 (sysconf 함수)
  - 파일이나 디렉토리와 관련된 런타임 제한 (pathconf 및 fpathconf 함수)
- **_SC_**로 시작하는 상수는 sysconf의 인수로 사용됩니다.
- **_PC_**로 시작하는 상수는 pathconf와 fpathconf의 인수로 사용됩니다.

### 제한 (3/4)

- **sysconf 시스템 호출**
  - 런타임 시 다음 두 가지를 확인합니다.
    - 시스템 전체 옵션 확인
    - 구현 의존적 제한 확인
  - 일반적으로 구현 시스템에 대한 정보를 얻기 위해 사용됩니다.
  - 반환 값 -1:
    - errno = EINVAL: 잘못된 심볼
    - errno는 변경되지 않음:
      - 옵션이 지원되지 않음 (옵션 확인)
      - 제한이 없음 (제한 확인)
  - errno가 변경된 경우에만 -1은 오류를 의미합니다. 따라서 호출하기 전에 errno를 0으로 설정해야 합니다.

- **fpathconf와 pathconf**
  - 파일에 대한 정보를 얻기 위해 사용됩니다.
  - **fpathconf**는 열린 파일이 있을 때 사용됩니다.
  - **pathconf**는 닫힌 파일이 있을 때 사용됩니다.
  - 반환 값의 해석은 sysconf와 동일합니다.