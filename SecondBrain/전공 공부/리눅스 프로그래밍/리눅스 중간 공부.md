# BASIC
##### 맨 앞 글자의 의미
![[Pasted image 20241013171311.png]]
d
l
b
c
p
-
###### 정답
- d: directory
- l: symbolic link
- b: block special file
- c: character special file
- p: FIFO
- -: regular file
###### 시스템 호출과 라이브러리 서브 루틴 중 뭐가 더 오래 걸릴까
시스템 호출은 사용자 공간에서 커널 공간으로의 두 번의 컨텍스트 스위칭이 필요하다. 이는 단순한 함수 호출보다 시간이 더 오래 걸린다
###### 시스템 호출을 사용하기 전에 올바른 헤더 파일을 포함해야 하는 이유
 모든 시스템 호출은 헤더 파일에 정의되어 있어서
###### unix는 어떤 방식으로 작동하는가
unbuffered I/O 방식으로 작동하여 데이터의 즉시 처리를 지원한다.
데이터가 중간 버퍼에 저장되지 않고 바로 읽거나 쓰는 작업을 수행한다.

# FILE
###### 파일 디스크립터 0,1,2 의미
0 stdin
1 stdout
2 stderr
###### ssize_t 헤더
(`<sys/types.h>`)를 가지는 (`<unistd.h>`)
###### fcntl.h 헤더에 들어있는 함수
open
creat
fcntl
###### open 매개변수와 return 값
pathname, flags, mode
return 값: 파일 디스크립터, error: -1
###### O_RDONLY
읽기 전용
###### O_WRONLY
쓰기 전용
###### O_RDWR
읽기 및 쓰기 전용 (read and write)
###### O_APPEND
파일의 마지막에 쓰기 (Append to the end of file on each write.)
###### O_CREAT
존재하지 않으면 파일 생성 (Create the file if it doesn't exist.)
###### O_EXCL
`O_CREAT`와 함께 사용되면, 새 파일을 만들려는 시도 중에 그 파일이 이미 존재하는 경우 오류를 발생시킨다.
###### O_TRUNC
파일이 이미 존재할 경우, 파일의 내용을 모두 지워서 길이를 0으로 만듭니다.
###### O_NONBLOCK
파일을 열 때 non-blocking mode로 열어, 자원이 사용 중이라도 기다리지 않고 바로 제어를 반환합니다
###### mode가 사용되는 곳
`O_CREAT` Flag에서만 사용된다.
ex) 0644
###### creat 매개변수와 return 값
pathname, mode
이미 존재하는 파일의 권한을 변경하지 않는다.
return: file descripter, error: -1
###### creat("path", 0644)를 open으로 바꾸면
`open("path", O_WRONLY|O_CREAT|OTRUNC,0644)`
###### unistd.h 헤더
close
read(size_t)
write(size_t)
lseek(off_t)
###### close 매개변수와 return 값
fd
return 0, error -1
###### read 매개변수와 return 값
fd, buffer, 읽을 size_t
return: 읽은 바이트 수, eof면 0, error:-1
###### write 매개변수와 return 값
fd, buffer, 읽을 size_t
return: 읽은 byte, error: -1
###### write로 이미 존재하는 파일을 쓰기 전용으로 열면
기존 파일에 있던 데이터는 새로운 데이터로 한 글자씩 덮어쓰게 된다. 즉, 파일의 이전 내용이 사라지고 새로운 내용이 저장된다.
O_APPEND 옵션을 사용했다면, 기존 파일의 내용이 지워지지 않고, 새로운 데이터가 파일 끝에 추가된다.
###### read, write가 효율이 가장 높은 buffer 크기
4096 (system call의 횟수를 줄일 수 있고, disk I/O가 4k만큼 일어나므로)
###### delayed writing이란?
system call을 하면 쓰기를 수행한 후 반환되는 것이 아닌, 커널에 버퍼 캐시로 데이터를 전송한 다음 4K씩 반환한다.
그러나, 디스크에 에러가 발생하거나 커널이 멈추면 write했다고 생각한 데이터가 write되지 않았을 수도 있다.
###### lseek 매개변수 반환 값
fd offset start_flag
return: new file offset, error: -1
###### start_flag 세가지
시작 부분
현재 위치
파일의 끝
###### 프로세스 테이블이 가지고 있는 정보
fd 값
file table pointer
###### file table이 가지고 있는 정보
file status flags
count(file table을 가리키는 fd의 개수)
offset
v-node pointer
###### v-node가 가지고 있는 정보
v-node 정보
i-node 정보
현재 file size
###### dup, dup2 매개변수, 반환 값
dup: fd
dup2: fd1, fd2
return: 새로운 fd, error: -1
###### dup, dup2 역할
기존 파일 디스크립터를 복제한다 (duplicate)
###### dup과 dup2의 차이
기존 파일 디스크립터 닫는 것까지 포함한다.
###### fcntl의 역할
이미 열려 있는 파일의 속성을 변경하는 함수 (file control)
######  fcntl 매개변수, 반환 값
fd, cmd
return: cmd, error: -1
###### F_DUPFD
기존 디스크립터 복제
###### F_GETFD, F_SETFD
파일 디스크립터 플래그 가져오기/설정하기
###### F_GETFL, F_SETFL
파일 상태 플래그 가져오기/설정하기
###### F_GETOWN, F_SETOWN
비동기 입출력 소유권 가져오기/설정하기
###### F_GETTLK, F_SETTLK, F_SETLKW
레코드 잠금 가져오기/설정하기
###### dup2를 fcntl로 표현하면?
![[Pasted image 20240910222029.png|500]]
###### O_ACCMODE란?
&연산을 통해 원하는 status flag를 뽑아내는 과정
read/write에 관한 정보만 알 수 있다.
###### fopen 매개변수와 반환값
pathname, type
return file pointer, error: NULL
![[Pasted image 20240925203113.png|300]]
###### getc 매개변수와 반환 값 하는 일
FILE 포인터
return: next character error: EOF(-1)
읽기 전용 open
###### putc 매개변수와 반환 값
int c, FILE 포인터
return c error EOF
쓰기 전용 open
###### fprintf 매개변수와 반환값 하는 일
file path, message
return 출력된 char 개수, error -1
메시지 출력?
![[Pasted image 20241008185534.png]]
###### restrict란?
restrict를 가진 것끼리 같은 메모리 공간을 사용하면 안된다는 의미
###### strerror 하는 일
errnum을 넘겨주면 에러메시지 반환
###### perror 매개변수와 하는 일
출력할 메시지를 매개변수로 갖는다.
메시지와 함께 errorno(전역변수)에 해당하는 에러메시지를 출력한다.
###### errno 특징
system call에서 -1이 발생하면 errno에 실패한 원인에 대한 정보를 저장해두게 된다.
errno는 전역변수이기 때문에 즉시 에러를 확인하지 않으면 overwrite되어 확인하기 어렵다.
errno는 새로운 시스템 콜이 만들어져도 리셋되지 않는다. (overwrite되지 않았다면)
\<errno.h>만 include하면 errno가 extern으로 지정된다.
###### /etc/shadow에 접근하려면?
euid가 0인 passswd 프로세스를 사용한다.
###### S_ISUID 역할과 설정 방법
file을 excute하면, 시스템은 생성된 프로세스에 `file owner로부터 가져온 eid를 부여`합니다.
`user $ chmod u+s a.out`
s는 x가 없는 경우에 의미가 없으므로 x를 s로 쓴다 (s가 있으면 x가 있는 것)
###### umask 매개변수와 반환값 하는 일
파일 생성 마스크 값인 mode_t
return: 이전 file mode error -1
파일 모드 생성 마스크 설정
###### mask값 &하는 법
가리고 싶은 값을 1로 두기 때문에 ~mask와 &한다
###### access 매개변수와 반환값 하는 일 access는 ruid? euid?
pathname, amode
return 0 error -1
ruid 및 guid를 기반으로 경로명의 접근 권한을 확인한다.
###### amode - F_OK
파일 존재 여부 테스트
###### chmod 매개변수와 하는 일
pathname newmode
return 0 error -1
기존 파일의 권한 변경
###### chown 매개변수와 하는 일
pathname owner_id group_id
return 0 error -1
파일의 사용자 id와 그룹 id 변경
-1 넣으면 변경안됨
###### chown 특징
• 다른 owner의 파일 소유권을 변경하려는 시도 시 항상 **EPERM** 오류가 반환됩니다.
• **파일의 소유권이 변경되면 해당 파일의 set-user-id 및 set-group-id 권한이 해제**됩니다.
###### Boot block이란?
UNIX가 처음 활성화 될 때 사용되는 코드
###### Super Block이란?
파일 시스템의 정보를 담음
###### i-node
디스크에 있는 파일과 연관된 모든 inode
• 파일을 고유하게 식별함(1:1로 매핑되어 있음)
- file에 대한 정보를 가지고 있음
###### 데이터 블록
• 파일 블록을 저장하기 위한 블록
###### i node 0, 1, 2
• 0: “no i-node”를 의미
• 1: 나쁜 디스크 블록(에러나는 애들)을 모으는 데 사용됨
• 2: 루트 디렉토리(/)에 예약되어 있습니다.
###### link 매개변수와 반환 값 하는 일
string original path, string new path,
return 0, error -1
새로운 디렉토리 항목을 생성하고 링크 수 증가(하드 링크)
###### 디렉토리에 하드 링크를 생성할 수 있는 권한
슈퍼유저에게 제한(파일 시스템 루프 방지)
두 경로 명이 동일한 파일 시스템에 있어야 함
###### unlink 매개변수와 반환 값 하는 일
pathname
return 0 error: -1
이름이 지정된 링크만 제거
###### unlink시 필요한 권한
unlink해야하니 write, directory에 대해 read
###### remove 매개변수와 반환 값 하는 일
pathname
return 0 error -1
파일 삭제(unlink와 동일)
###### rename 매개변수와 반환 값 하는 일
oldname, newname
return 0 error -1
이름 변경
###### symlink 매개변수와 반환 값 하는 일
realname, symname
return 0 error -1
symbolic link 생성
######  reallink 매개변수와 반환 값 하는 일
realname, symname
return 0 error -1
심볼릭 링크가 가리키는 타겟 경로를 출력하는 명령어
###### readlink에서 원본 파일이 제거된 경우
프로그램은 여전히 심볼릭 링크를 ‘볼’ 수 있지만, open 호출은 그 안에 포함된 경로를 따라갈 수 없으며 errno가 EEXIST로 설정된 상태로 반환됩니다.
원본 파일이 존재하지 않더라도 심볼릭 링크는 볼 수 있음
###### stat, fstat, lstat 매개변수 반환값 하는 일
pathname, struct stat buf
return 0 error -1
stat: 지정된 파일
fstat: 열린 파일
lstat: 심볼릭 링크
###### symbolic link에 stat을 쓰면?
심볼릭 링크가 참조하고 있는 파일의 i-node 정보가 나옴, 따라서 심볼릭 링크는 lstat을 써야함
# DIRECTORIES
###### 디렉토리와 일반 파일의 차이점
  - 디렉토리는 open 시스템 호출을 사용하여 생성할 수 없습니다.
  - O_WRONLY 또는 O_RDWR 플래그가 설정된 상태에서 디렉토리를 열려고 하면 (errno=EISDIR) 오류가 발생합니다.
  - 디렉토리를 write를 사용하여 업데이트하는 것은 불가능합니다.
  - 오직 커널만이 디렉토리에 쓸 수 있습니다.
###### directory block 구성
i-node 번호
문자 필드
###### 디렉토기 읽기, 쓰기, 실행 권한
- 읽기 권한: 파일이나 하위 디렉토리의 이름 목록을 볼 수 있습니다.
- 쓰기 권한: 새로운 파일을 생성하거나 기존 파일을 제거할 수 있습니다.
- 실행 권한(검색 권한): 디렉토리로 이동하거나 프로그램 내에서 chdir 시스템 호출을 사용할 수 있습니다.
###### `/usr/include/stdio.h`를 열려면 필요한 권한
`/`, `/usr`, `/usr/include`에 대해 실행 권한이 필요합니다.
###### directory sticky bit 의미
 - 다음 중 하나를 만족해야만 디렉토리에 대한 쓰기 권한으로 파일을 제거하거나 이름을 변경할 수 있습니다:
      - 파일의 owner
      - 디렉토리의 owner
      - 슈퍼유저
###### dirent 구조체에서 d_inode가 0인 것의 의미
```c
#include <dirent.h>
struct dirent {
	ino_t d_ino; /* i-node number */
	char d_name[NAME_MAX + 1]; /* null-terminated filename */
}
```
- d_inode의 값이 0인 것은 디렉토리에서 빈 슬롯을 나타냅니다.
###### mkdir 매개변수 반환 값
pathname, mode
return 0 error -1
###### rmdir 매개변수 반환 값 특징
pathname
return 0 error -1
비지 않으면 삭제 못함
###### opendir 매개변수 반환값 특징
dirname
return directory pointer error null
###### closedir 매개변수 반환값
dirptr
return 0 error -1
###### readdir 매개변수 반환값 특징
DIR pointer
return pointer error NULL
완료 시 디렉터리 포인터가 디렉토리의 다음 항목으로 이동함
###### rewinddir 매개변수 반환값 하는 일
```c
#include <dirent.h>
void rewinddir(DIR *dp);
// Returns: 0 if OK, -1 on error
```
디렉토리 정보 위치를 처음으로 변경
###### chdir 매개변수 반환값 하는 일
path
0 -1
open 메서드를 상대 경로로 부를 수 있게 한다.
###### getcwd 매개변수 반환값 하는 일
char namearr, size
현재 디렉토리 경로명을 가리키는 포인터 반환
현재 디렉토리 이름이 name이 가리키는 배열에 복사됩니다.
###### sync fsync 매개변수 반환값 하는 일
```c
#include <unistd.h>
int fsync(int filedes);
//Returns: 0 if OK, -1 on error
void sync(void);
```
  - fsync는 모든 파일 데이터가 디스크에 기록될 때까지 반환하지 않습니다.
  - sync 호출은 데이터 쓰기가 예약되었지만 완료되지 않았을 때 반환할 수 있습니다.
###### Device number의 major number와 minor number
- **주 번호**: 장치 유형 (장치 드라이버)
- **부 번호**: 특정 장치의 인스턴스
###### 장치 파일 특징
- 따라서 장치 파일의 i-노드에는 장치 번호가 포함됩니다 (inode->i_rdev).
- 주변 장치에 대한 간단한 인터페이스를 제공합니다.
- 파일 시스템에 나타납니다.
- 사용자는 표준 시스템 호출을 사용하여 장치에 접근하고 이를 일반 컴퓨터 파일처럼 취급합니다.
- 슈퍼유저만이 장치 파일을 생성할 수 있습니다.
###### S_ISREG란?
MACRO로 S_ISCHR(buf.st_mode) 로 사용해서 regular file인지 확인
# PROCESS
###### start up code란?
C 프로그램이 exec 함수 중 하나에 의해 커널에 의해 실행될 때, 메인 함수가 호출되기 전에 시작되는 특별한 시작 루틴
###### environ 변수에 대해서
특정 환경 변수를 접근하기 위해서는 보통 `environ` 변수를 통해서가 아닌 `getenv`와 `putenv` 함수를 통해서 합니다.
• 대부분의 UNIX 시스템은 메인 함수에 세 번째 인수를 제공합니다.
사실 main함수는 envp라는 세번째 인수를 가지고 있다.
![[Pasted image 20241007124947.png]]
###### c 프로그램의 구성
코드 세그먼트
초기화된 global 및 static 변수
초기화 되지 않은 global 및 static 변수
###### 프로세스가 포함하는 것
프로그램 코드
변수 내의 데이터 값
하드웨어 레지스터
프로그램 스택(stack, heap)
###### init이란?
프로세스 트리의 최상위에 있는 프로세스로 모든 프로세스의 궁극적인 조상
###### getpid getppid 매개변수 반환값 하는 일
void
return pid
프로세스 아이디 반환
###### fork 매개변수 반환 값 하는 일
void 
return 0(child) pid(parent) error -1
###### 자식 프로세스가 공유하는 것과 공유하지 않는 것
공유하는 것: 텍스트 세그먼트
공유하지 않는 것: 그외 모든 것(데이터 공간, 힙, 스택)
###### EAGAIN이란
시스템 전체에서 생성할 수 있는 프로세스의 수에 제한이 있을 때 발생하는 오류 (다시 시도하라)
###### exec 매개변수 반환값 하는 일
l - list 인자들을 리스트처럼 나열하고 마지막은 NULL로 끝남 (`arg0`, `arg1` ...)
v - vector - 인수들이 배열 형태(`argv[]`)로 전달됨
e - environment - 환경변수 배열(`envp[]`)을 함께 전달함
p - path를 뜻하고, 파일의 경로를 직접 명시하지 않고 시스템의 PATH 환경변수를 사용하여 실행파일을 찾는다. - 따라서 filename만 받음

no return error -1

새로운 프로그램 실행시에 사용
###### exec family 중 system call은?
execve
###### 부모 자식 offset 관계
•	부모에서 열려 있는 모든 파일은 자식에서도 열려 있습니다.
•	**부모와 자식이 동일한 파일 오프셋을 공유한다**
•	**자식이 표준 출력에 쓸 때 부모의 오프셋이 업데이트된다**
###### 부모와 자식 프로세스의 차이점
부모 프로세스 ID
자식의 tms_utime, tms_stime, tms_cutime, tms_cstime 값은 0으로 설정
•	부모에 의해 설정된 파일 잠금은 자식에게 상속되지 않습니다.
•	자식의 보류 중인 알람은 지워집니다.
•	자식의 보류 중인 신호 세트는 빈 세트로 설정됩니다.
###### exec와 파일 관계
•	**exec도 완전히 새로운 프로그램이 시작될 때 원래 프로그램에서 열려 있던 파일은 그대로 열려 있다**
•	**file offset은 exec 호출에 의해 변경되지 않는다**
•	close-on-exec 플래그(child가 exec을 하면 parent가 open한 file descripter가 자동으로 close됨)가 켜져 있으면(기본값은 꺼져 있음)
###### main에서 return exit `_exit` `_Exit` abort signal 마지막 스레드가 취소 요청에 응답 중 비정상 종료를 고르시오
 - abort 호출
  - signal 수신
  - 마지막 스레드가 취소 요청에 응답
###### atexit 매개변수 반환값 하는일
```c
#include <stdlib.h>
int atexit(void (*func)(void));
// Returns: 0 if OK, nonzero on error
```
exit 되면 특정 함수 호출
###### exit과 `_exit`, `_Exit` 차이
exit은 하나만 exit해주는 것이 아니라 여러가지를 exit해주고 돌아온다.
`_exit``_Exit`은 cleanup 작업을 안하고 바로 kernel에 exit 작업을 해준다.
###### wait 매개변수 반환값
```c
#include <sys/wait.h>
pid_t wait(int *statloc);
// Return: child process ID if OK, 0 (see later), or -1 on error
```
###### waitpid 매개변수 반환값 하는 일
```c
#include <sys/wait.h>
pid_t waitpid(pid_t pid, int *statloc, int options);
// Return: child process ID if OK, 0 (see later), or -1 on error
```
wait할 pid를 지정하는 system call
여러 자식이 있는 경우 자식 중 하나가 종료될 때 반환
###### waitpid 반환값 의미
pid == -1 모든 자식 프로세스를 기다립니다. 이 점에서 waitpid는 wait와 동일합니다.
pid > 0 프로세스 ID가 pid와 동일한 자식을 기다립니다.
pid == 0 호출 프로세스의 프로세스 그룹 ID와 동일한 프로세스 그룹 ID를 가진 모든 자식을 기다립니다.
pid < 0 프로세스 그룹 ID가 pid의 절대값과 동일한 모든 자식을 기다립니다.
###### WNOHANG 의미
pid로 지정된 자식이 즉시 사용 가능하지 않으면 waitpid 함수는 블록하지 않습니다. 이 경우 반환 값은 0입니다.
###### `WIFEXITED(status)` , `WIFSIGNALED(status)` `WIFSTOPPED(status)` `WIFCONTINUED(status)` 
`WIFEXITED(status)` : 자식 프로세스가 정상적으로 종료되었을 때 0이 아닌 값을 반환합니다.
`WIFSIGNALED(status)` :자식 프로세스가 캐치되지 않은 시그널로 인해 종료되었을 때 0이 아닌 값을 반환합니다. 
`WIFSTOPPED(status)`: 자식 프로세스가 현재 중지된 경우 0이 아닌 값을 반환합니다.
`WIFCONTINUED(status)`: 자식 프로세스가 현재 다시 실행 중인 경우 0이 아닌 값을 반환합니다.
###### WEXITSTATUS()의미
자식 프로세스가 정상적으로 종료되었을 때 자식 프로세스가 `_exit()`, `exit()` 또는 main 함수에서 반환한 하위 8비트 값을 반환합니다.
###### `WTERMSIG(status)`
WTERMSIG는 종료를 유발한 시그널 번호를 반환합니다.
###### `WSTOPSIG(status)` 
WSTOPSIG는 자식 프로세스가 중지된 시그널 번호를 반환합니다.
###### ls를 실행하는 step
shell에서 shell을 fork
자식 shell은 ls를 exec (기존 pid를 상속)
###### pid가 0인 것과 특징
0 - 스케쥴러 프로세스
커널의 일부이며, 시스템 프로세스이다.
###### pid가 1인 것과 특징
1 - init 프로세스
죽지 않는다.
superuser 권한으로 실행됨
시스템 프로세스가 아니다.
###### getpid getppid geteuid getgid getegid
![[Pasted image 20241014120812.png|500]]
###### 프로세스 group leader
(pid == pgid)인 경우
###### getpgrp getpgid 매개변수 반환값
```c
#include <unistd.h>
pid_t getpgrp(void);
// Returns: process group ID of calling process
pid_t getpgid(pid_t pid);  /* getpgid(0) == getpgrp() */
// Returns: process group ID if OK, -1 on error
```
###### setpgid 매개변수 반환 값
```c
#include <unistd.h>
int setpgid(pid_t pid, pid_t pgid);
// Returns: 0 if OK, -1 on error
```
프로세스의 프로세스 ID가 pid와 같은 프로세스의 프로세스 그룹 ID를 pgid로 설정
###### setpgid시 pid == 0, pgid == 0의 의미
- pid == 0: 호출자의 프로세스 ID가 사용됩니다.
- pgid == 0: 지정된 프로세스 ID(pid)가 프로세스 그룹 ID로 사용됩니다.
###### setpgid 제약
- **프로세스는 자신이나 자식의 프로세스 그룹 ID만 설정할 수 있다**
- 또한 자식이 exec 함수 중 하나를 호출한 후에는 자식의 프로세스 그룹 ID를 변경할 수 없습니다.
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
