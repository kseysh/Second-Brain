# CH01 BASIC
##### 맨 앞 글자의 의미
![[Pasted image 20241013171311.png]]
d
l
b
c
p
-
###### 정답
- d: directory
- l: symbolic link
- b: block special file
- c: character special file
- p: FIFO
- -: regular file
###### 시스템 호출과 라이브러리 서브 루틴 중 뭐가 더 오래 걸릴까
시스템 호출은 사용자 공간에서 커널 공간으로의 두 번의 컨텍스트 스위칭이 필요하다. 이는 단순한 함수 호출보다 시간이 더 오래 걸린다
###### 시스템 호출을 사용하기 전에 올바른 헤더 파일을 포함해야 하는 이유
 모든 시스템 호출은 헤더 파일에 정의되어 있어서
###### unix는 어떤 방식으로 작동하는가
unbuffered I/O 방식으로 작동하여 데이터의 즉시 처리를 지원한다.
데이터가 중간 버퍼에 저장되지 않고 바로 읽거나 쓰는 작업을 수행한다.

# FILE
###### 파일 디스크립터 0,1,2 의미
0 stdin
1 stdout
2 stderr
###### ssize_t 헤더
(`<sys/types.h>`)를 가지는 (`<unistd.h>`)
###### fcntl.h 헤더에 들어있는 함수
open
creat
fcntl
###### open 매개변수와 return 값
pathname, flags, mode
return 값: 파일 디스크립터, error: -1
###### O_RDONLY
읽기 전용
###### O_WRONLY
쓰기 전용
###### O_RDWR
읽기 및 쓰기 전용 (read and write)
###### O_APPEND
파일의 마지막에 쓰기 (Append to the end of file on each write.)
###### O_CREAT
존재하지 않으면 파일 생성 (Create the file if it doesn't exist.)
###### O_EXCL
`O_CREAT`와 함께 사용되면, 새 파일을 만들려는 시도 중에 그 파일이 이미 존재하는 경우 오류를 발생시킨다.
###### O_TRUNC
파일이 이미 존재할 경우, 파일의 내용을 모두 지워서 길이를 0으로 만듭니다.
###### O_NONBLOCK
파일을 열 때 non-blocking mode로 열어, 자원이 사용 중이라도 기다리지 않고 바로 제어를 반환합니다
###### mode가 사용되는 곳
`O_CREAT` Flag에서만 사용된다.
ex) 0644
###### creat 매개변수와 return 값
pathname, mode
이미 존재하는 파일의 권한을 변경하지 않는다.
return: file descripter, error: -1
###### creat("path", 0644)를 open으로 바꾸면
`open("path", O_WRONLY|O_CREAT|OTRUNC,0644)`
###### unistd.h 헤더
close
read(size_t)
write(size_t)
lseek(off_t)
###### close 매개변수와 return 값
fd
return 0, error -1
###### read 매개변수와 return 값
fd, buffer, 읽을 size_t
return: 읽은 바이트 수, eof면 0, error:-1
###### write 매개변수와 return 값
fd, buffer, 읽을 size_t
return: 읽은 byte, error: -1
###### write로 이미 존재하는 파일을 쓰기 전용으로 열면
기존 파일에 있던 데이터는 새로운 데이터로 한 글자씩 덮어쓰게 된다. 즉, 파일의 이전 내용이 사라지고 새로운 내용이 저장된다.
O_APPEND 옵션을 사용했다면, 기존 파일의 내용이 지워지지 않고, 새로운 데이터가 파일 끝에 추가된다.
###### read, write가 효율이 가장 높은 buffer 크기
4096 (system call의 횟수를 줄일 수 있고, disk I/O가 4k만큼 일어나므로)
###### delayed writing이란?
system call을 하면 쓰기를 수행한 후 반환되는 것이 아닌, 커널에 버퍼 캐시로 데이터를 전송한 다음 4K씩 반환한다.
그러나, 디스크에 에러가 발생하거나 커널이 멈추면 write했다고 생각한 데이터가 write되지 않았을 수도 있다.
###### lseek 매개변수 반환 값
fd offset start_flag
return: new file offset, error: -1
###### start_flag 세가지
시작 부분
현재 위치
파일의 끝
###### 프로세스 테이블이 가지고 있는 정보
fd 값
file table pointer
###### file table이 가지고 있는 정보
file status flags
count(file table을 가리키는 fd의 개수)
offset
v-node pointer
###### v-node가 가지고 있는 정보
v-node 정보
i-node 정보
현재 file size
###### dup, dup2 매개변수, 반환 값
dup: fd
dup2: fd1, fd2
return: 새로운 fd, error: -1
###### dup, dup2 역할
기존 파일 디스크립터를 복제한다 (duplicate)
###### dup과 dup2의 차이
기존 파일 디스크립터 닫는 것까지 포함한다.
###### fcntl의 역할
이미 열려 있는 파일의 속성을 변경하는 함수 (file control)
######  fcntl 매개변수, 반환 값
fd, cmd
return: cmd, error: -1
###### F_DUPFD
기존 디스크립터 복제
###### F_GETFD, F_SETFD
파일 디스크립터 플래그 가져오기/설정하기
###### F_GETFL, F_SETFL
파일 상태 플래그 가져오기/설정하기
###### F_GETOWN, F_SETOWN
비동기 입출력 소유권 가져오기/설정하기
###### F_GETTLK, F_SETTLK, F_SETLKW
레코드 잠금 가져오기/설정하기
###### dup2를 fcntl로 표현하면?
![[Pasted image 20240910222029.png|500]]
###### O_ACCMODE란?
&연산을 통해 원하는 status flag를 뽑아내는 과정
read/write에 관한 정보만 알 수 있다.
###### fopen 매개변수와 반환값
pathname, type
return file pointer, error: NULL
![[Pasted image 20240925203113.png|300]]
###### getc 매개변수와 반환 값 하는 일
FILE 포인터
return: next character error: EOF(-1)
읽기 전용 open
###### putc 매개변수와 반환 값
int c, FILE 포인터
return c error EOF
쓰기 전용 open
###### fprintf 매개변수와 반환값 하는 일
file path, message
return 출력된 char 개수, error -1
메시지 출력?
![[Pasted image 20241008185534.png]]
###### restrict란?
restrict를 가진 것끼리 같은 메모리 공간을 사용하면 안된다는 의미
###### strerror 하는 일
errnum을 넘겨주면 에러메시지 반환
###### perror 매개변수와 하는 일
출력할 메시지를 매개변수로 갖는다.
메시지와 함께 errorno(전역변수)에 해당하는 에러메시지를 출력한다.
###### errno 특징
system call에서 -1이 발생하면 errno에 실패한 원인에 대한 정보를 저장해두게 된다.
errno는 전역변수이기 때문에 즉시 에러를 확인하지 않으면 overwrite되어 확인하기 어렵다.
errno는 새로운 시스템 콜이 만들어져도 리셋되지 않는다. (overwrite되지 않았다면)
\<errno.h>만 include하면 errno가 extern으로 지정된다.
###### /etc/shadow에 접근하려면?
euid가 0인 passswd 프로세스를 사용한다.
###### S_ISUID 역할과 설정 방법
file을 excute하면, 시스템은 생성된 프로세스에 `file owner로부터 가져온 eid를 부여`합니다.
`user $ chmod u+s a.out`
s는 x가 없는 경우에 의미가 없으므로 x를 s로 쓴다 (s가 있으면 x가 있는 것)
###### umask 매개변수와 반환값 하는 일
파일 생성 마스크 값인 mode_t
return: 이전 file mode error -1
파일 모드 생성 마스크 설정
###### mask값 &하는 법
가리고 싶은 값을 1로 두기 때문에 ~mask와 &한다
###### access 매개변수와 반환값 하는 일 access는 ruid? euid?
pathname, amode
return 0 error -1
ruid 및 guid를 기반으로 경로명의 접근 권한을 확인한다.
###### amode - F_OK
파일 존재 여부 테스트
###### chmod 매개변수와 하는 일
pathname newmode
return 0 error -1
기존 파일의 권한 변경
###### chown 매개변수와 하는 일
pathname owner_id group_id
return 0 error -1
파일의 사용자 id와 그룹 id 변경
-1 넣으면 변경안됨
###### chown 특징
• 다른 owner의 파일 소유권을 변경하려는 시도 시 항상 **EPERM** 오류가 반환됩니다.
• **파일의 소유권이 변경되면 해당 파일의 set-user-id 및 set-group-id 권한이 해제**됩니다.
###### Boot block이란?
UNIX가 처음 활성화 될 때 사용되는 코드
###### Super Block이란?
파일 시스템의 정보를 담음
###### i-node
디스크에 있는 파일과 연관된 모든 inode
• 파일을 고유하게 식별함(1:1로 매핑되어 있음)
- file에 대한 정보를 가지고 있음
###### 데이터 블록
• 파일 블록을 저장하기 위한 블록
###### i node 0, 1, 2
• 0: “no i-node”를 의미
• 1: 나쁜 디스크 블록(에러나는 애들)을 모으는 데 사용됨
• 2: 루트 디렉토리(/)에 예약되어 있습니다.
###### link 매개변수와 반환 값 하는 일
string original path, string new path,
return 0, error -1
새로운 디렉토리 항목을 생성하고 링크 수 증가(하드 링크)
###### 디렉토리에 하드 링크를 생성할 수 있는 권한
슈퍼유저에게 제한(파일 시스템 루프 방지)
두 경로 명이 동일한 파일 시스템에 있어야 함
###### unlink 매개변수와 반환 값 하는 일
pathname
return 0 error: -1
이름이 지정된 링크만 제거
###### unlink시 필요한 권한
unlink해야하니 write, directory에 대해 read
###### remove 매개변수와 반환 값 하는 일
pathname
return 0 error -1
파일 삭제(unlink와 동일)
###### rename 매개변수와 반환 값 하는 일
oldname, newname
return 0 error -1
이름 변경
###### symlink 매개변수와 반환 값 하는 일
realname, symname
return 0 error -1
symbolic link 생성
######  reallink 매개변수와 반환 값 하는 일
realname, symname
return 0 error -1
심볼릭 링크가 가리키는 타겟 경로를 출력하는 명령어
###### readlink에서 원본 파일이 제거된 경우
프로그램은 여전히 심볼릭 링크를 ‘볼’ 수 있지만, open 호출은 그 안에 포함된 경로를 따라갈 수 없으며 errno가 EEXIST로 설정된 상태로 반환됩니다.
원본 파일이 존재하지 않더라도 심볼릭 링크는 볼 수 있음
###### stat, fstat, lstat 매개변수 반환값 하는 일
pathname, struct stat buf
return 0 error -1
stat: 지정된 파일
fstat: 열린 파일
lstat: 심볼릭 링크
###### symbolic link에 stat을 쓰면?
심볼릭 링크가 참조하고 있는 파일의 i-node 정보가 나옴, 따라서 심볼릭 링크는 lstat을 써야함
# DIRECTORIES
###### 디렉토리와 일반 파일의 차이점
  - 디렉토리는 open 시스템 호출을 사용하여 생성할 수 없습니다.
  - O_WRONLY 또는 O_RDWR 플래그가 설정된 상태에서 디렉토리를 열려고 하면 (errno=EISDIR) 오류가 발생합니다.
  - 디렉토리를 write를 사용하여 업데이트하는 것은 불가능합니다.
  - 오직 커널만이 디렉토리에 쓸 수 있습니다.
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
