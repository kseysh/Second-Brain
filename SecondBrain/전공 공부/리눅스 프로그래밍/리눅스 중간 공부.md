# CH01 BASIC
##### 맨 앞 글자의 의미
![[Pasted image 20241013171311.png]]
d
l
b
c
p
-
###### 정답
- d: directory
- l: symbolic link
- b: block special file
- c: character special file
- p: FIFO
- -: regular file
###### 시스템 호출과 라이브러리 서브 루틴 중 뭐가 더 오래 걸릴까
시스템 호출은 사용자 공간에서 커널 공간으로의 두 번의 컨텍스트 스위칭이 필요하다. 이는 단순한 함수 호출보다 시간이 더 오래 걸린다
###### 시스템 호출을 사용하기 전에 올바른 헤더 파일을 포함해야 하는 이유
 모든 시스템 호출은 헤더 파일에 정의되어 있어서
###### unix는 어떤 방식으로 작동하는가
unbuffered I/O 방식으로 작동하여 데이터의 즉시 처리를 지원한다.
데이터가 중간 버퍼에 저장되지 않고 바로 읽거나 쓰는 작업을 수행한다.

# FILE
###### 파일 디스크립터 0,1,2 의미
0 stdin
1 stdout
2 stderr
###### ssize_t 헤더
(`<sys/types.h>`)를 가지는 (`<unistd.h>`)
###### fcntl.h 헤더에 들어있는 함수
open
creat
fcntl
###### open 매개변수와 return 값
pathname, flags, mode
return 값: 파일 디스크립터, error: -1
###### O_RDONLY
읽기 전용
###### O_WRONLY
쓰기 전용
###### O_RDWR
읽기 및 쓰기 전용 (read and write)
###### O_APPEND
파일의 마지막에 쓰기 (Append to the end of file on each write.)
###### O_CREAT
존재하지 않으면 파일 생성 (Create the file if it doesn't exist.)
###### O_EXCL
`O_CREAT`와 함께 사용되면, 새 파일을 만들려는 시도 중에 그 파일이 이미 존재하는 경우 오류를 발생시킨다.
###### O_TRUNC
파일이 이미 존재할 경우, 파일의 내용을 모두 지워서 길이를 0으로 만듭니다.
###### O_NONBLOCK
파일을 열 때 non-blocking mode로 열어, 자원이 사용 중이라도 기다리지 않고 바로 제어를 반환합니다
###### mode가 사용되는 곳
`O_CREAT` Flag에서만 사용된다.
ex) 0644
###### creat 매개변수와 return 값
pathname, mode
이미 존재하는 파일의 권한을 변경하지 않는다.
return: file descripter, error: -1
###### creat("path", 0644)를 open으로 바꾸면
`open("path", O_WRONLY|O_CREAT|OTRUNC,0644)`
###### unistd.h 헤더
close
read(size_t)
write(size_t)
lseek(off_t)
###### close 매개변수와 return 값
fd
return 0, error -1
###### read 매개변수와 return 값
fd, buffer, 읽을 size_t
return: 읽은 바이트 수, eof면 0, error:-1
###### write 매개변수와 return 값
fd, buffer, 읽을 size_t
return: 읽은 byte, error: -1
###### write로 이미 존재하는 파일을 쓰기 전용으로 열면
기존 파일에 있던 데이터는 새로운 데이터로 한 글자씩 덮어쓰게 된다. 즉, 파일의 이전 내용이 사라지고 새로운 내용이 저장된다.
O_APPEND 옵션을 사용했다면, 기존 파일의 내용이 지워지지 않고, 새로운 데이터가 파일 끝에 추가된다.
###### read, write가 효율이 가장 높은 buffer 크기
4096 (system call의 횟수를 줄일 수 있고, disk I/O가 4k만큼 일어나므로)
###### delayed writing이란?
system call을 하면 쓰기를 수행한 후 반환되는 것이 아닌, 커널에 버퍼 캐시로 데이터를 전송한 다음 4K씩 반환한다.
그러나, 디스크에 에러가 발생하거나 커널이 멈추면 write했다고 생각한 데이터가 write되지 않았을 수도 있다.
###### lseek 매개변수 반환 값
fd offset start_flag
return: new file offset, error: -1
###### start_flag 세가지
시작 부분
현재 위치
파일의 끝
###### 프로세스 테이블이 가지고 있는 정보
fd 값
file table pointer
###### file table이 가지고 있는 정보
file status flags
count(file table을 가리키는 fd의 개수)
offset
v-node pointer
###### v-node가 가지고 있는 정보
v-node 정보
i-node 정보
현재 file size
###### dup, dup2 매개변수, 반환 값
dup: fd
dup2: fd1, fd2
return: 새로운 fd, error: -1
###### dup, dup2 역할
기존 파일 디스크립터를 복제한다 (duplicate)
###### dup과 dup2의 차이
기존 파일 디스크립터 닫는 것까지 포함한다.
###### fcntl의 역할
이미 열려 있는 파일의 속성을 변경하는 함수 (file control)
######  fcntl 매개변수, 반환 값
fd, cmd
return: cmd, error: -1
###### F_DUPFD
기존 디스크립터 복제
###### F_GETFD, F_SETFD
파일 디스크립터 플래그 가져오기/설정하기
###### F_GETFL, F_SETFL
파일 상태 플래그 가져오기/설정하기
###### F_GETOWN, F_SETOWN
비동기 입출력 소유권 가져오기/설정하기
###### F_GETTLK, F_SETTLK, F_SETLKW
레코드 잠금 가져오기/설정하기
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
###### 정답
