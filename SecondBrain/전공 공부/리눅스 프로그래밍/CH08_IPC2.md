# POSIX:XSI Message Queue
## IPC (프로세스 간 통신)
메시지 큐는 프로세스가 다른 프로세스로부터 메시지를 보내고 받을 수 있게 해주는 POSIX:XSI 인터프로세스 통신 메커니즘입니다.
• 메시지 큐는 커널 내에 저장된 메시지의 linked list이며, 메시지 큐 식별자에 의해 식별됩니다.
```c
struct msqid_ds { /* <sys/msg.h> */
	struct ipc_perm msg_perm; /* see ch08_ipc1-_p.29_ */
	struct msg *msg_first; /* 큐에서 첫 번째 포인터 */
	struct msg *msg_last; /* 큐에서 마지막 포인터 */
	msglen_t msg_cbytes; /* 메시지 큐의 전체 사이즈 */
	msgqnum_t msg_qnum; /* # 큐에 있는 메시지 개수 */
	msglen_t msg_qbytes; /* 큐 안에 있는 전체 byte의 최대 사이즈 */
	pid_t msg_lspid; /* 가장 최근에 메시지를 send한 pid */
	pid_t msg_lrpid; /* 가장 최근에 메시지를 receive한 pid */
	time_t msg_stime; /* 가장 최근에 메시지를 send한 시간 */
	time_t msg_rtime; /* 가장 최근에 메시지를 receive한 시간 */
	time_t msg_ctime; /* 메시지가 가장 최근에 변경된 시간 */
};
```
![[Pasted image 20241126234814.png|500]]
## `msgget(2)` 시스템 호출
```c
int msgget(key_t key, int flag);
```
- `msgget` 함수는 키 매개변수에 연관된 MQ identifier를 반환합니다.
###### errno
- `EACCES`
	- 키에 해당하는 메시지 큐가 존재하지만, 권한이 거부됨
- `EEXIST`
	- 키에 해당하는 메시지 큐가 존재한다. `((flag & IPC_CREAT) && (flag & IPC_EXCL)) == -1`(key가 있어서 `IPC_EXCL`로 오류 발생)
- `ENOENT`
	- 키에 해당하는 메시지 큐가 존재하지 않다. `(msgflg & IPC_CREAT) == 0`
- `ENOSPC`
	- 시스템 전체의 메시지 큐 제한을 초과함
## `msgsnd(2)` 시스템 호출
```c
int msgsnd(int msqid, const void *ptr, size_t nbytes, int flag);
```
- `msgsnd`를 사용하여 메시지를 큐에 삽입합니다.
- 메시지는 항상 큐의 끝에 추가됩니다.
- 매개변수:
  - `ptr`: 사용자 정의 버퍼를 가리킨다. (보낼 메시지 버퍼)
  - `nbytes`: 메시지 크기
  - `flag`: `IPC_NOWAIT`가 지정되지 않은 경우, 메시지를 위한 공간이 생길 때까지 대기합니다.
### `msgrcv(2)` 시스템 호출

- 매개변수:
  - `ptr`: 사용자 정의 버퍼를 가리킵니다.
  - `nbytes`: 메시지 크기
  - `type` 행동:
    - `== 0`: 큐의 첫 번째 메시지 제거
    - `> 0`: 큐에서 특정 `type`의 첫 번째 메시지 제거
    - `< 0`: 절대값 이하의 가장 낮은 `type`의 첫 번째 메시지 제거
  - `flag`: `IPC_NOWAIT`, `MSG_NOERROR`
- 반환된 메시지가 `nbytes`보다 크고 `MSG_NOERROR`가 설정되어 있으면, 메시지가 잘립니다. 이 플래그가 없으면 E2BIG 오류가 반환됩니다.

### `msgctl(2)` 시스템 호출

- `msgctl`은 메시지 큐를 제거하거나 권한을 변경할 때 사용됩니다.

### 우선순위가 있는 메시지 큐 예제 (1)

---

### POSIX:XSI 세마포어

- 세마포어는 여러 프로세스가 공유 데이터 객체에 접근할 수 있도록 하기 위한 카운터입니다.
- 1965년 E. W. Dijkstra가 상호 배제와 동기화를 관리하기 위해 제안한 추상 개념입니다.
- wait (down, P, lock)와 signal (up, V, unlock, post) 두 가지 원자적 작업을 포함하는 정수 변수입니다.

### POSIX:XSI 세마포어 (1/3)

- POSIX:XSI 세마포어는 세마포어 요소 배열로 구성됩니다.
- 프로세스는 단일 호출로 전체 세트를 조작할 수 있습니다.
- 각 세마포어 요소는 다음 정보를 포함합니다(`struct sem`):
  - `semval`: 세마포어 값 (0 이상)
  - `sempid`: 마지막으로 세마포어를 조작한 프로세스 ID
  - `semncnt`: 세마포어 값이 증가하기를 기다리는 프로세스 수
  - `semzcnt`: 세마포어 값이 0이 되기를 기다리는 프로세스 수
- 세마포어 값이 0이 되면 큐에 있는 프로세스가 깨워집니다.
- 각 세마포어 요소는 두 가지 큐를 가집니다:
  - 값 증가 대기 프로세스 큐
  - 값이 0이 되기를 기다리는 프로세스 큐

### `semget(2)` 시스템 호출 (1/2)

- 키에 연관된 세마포어 식별자를 반환합니다.
- 매개변수:
  - `nsems`: 세트 내 세마포어 요소 수 (`nsems == 0`일 경우 기존 세트를 참조)

### `semctl(2)` 시스템 호출 (1/2)

- 세마포어 세트의 각 요소는 사용 전에 `semctl`로 초기화되어야 합니다.
- 매개변수:
  - `arg`: `cmd`의 값에 따라 달라집니다.

### `semop(2)` 시스템 호출 (1/2)

- `semop`는 사용자 정의 세마포어 작업을 세마포어 세트에 대해 원자적으로 수행합니다.

### `semop(2): SEM_UNDO` (1/4)

- XSI IPC 객체는 어떤 프로세스도 사용하지 않을 때도 존재하기 때문에, 프로그램이 할당받은 세마포어를 해제하지 않고 종료하는 경우에 대비해야 합니다.
- `SEM_UNDO` 플래그를 사용하여 프로세스가 종료될 때 세마포어 조정을 자동으로 수행할 수 있습니다.

### POSIX:XSI 공유 메모리

- 공유 메모리는 여러 프로세스가 같은 메모리 세그먼트를 읽고 쓸 수 있도록 합니다.
- 데이터가 클라이언트와 서버 사이에서 복사될 필요가 없기 때문에 가장 빠른 IPC 방식입니다.
- 서버가 공유 메모리 영역에 데이터를 기록할 때 클라이언트는 서버가 완료될 때까지 접근을 지양해야 합니다.
  - 종종 세마포어를 사용하여 공유 메모리 접근을 동기화합니다.

### `shmget(2)` 시스템 호출

- 매개변수:
  - `size`: 메모리 세그먼트의 최소 크기(바이트)

### `shmat(2)` 시스템 호출

- `shmat`은 호출 프로세스의 주소 공간에 지정된 공유 메모리 세그먼트를 부착하고 `shmid`의 `shm_nattch` 값을 증가시킵니다.
- 매개변수:
  - `addr`:
    - `addr`가 0이면 커널이 선택한 첫 번째 사용 가능한 주소에 세그먼트를 부착합니다(권장 방법).
    - `addr`이 0이 아니고 `SHM_RND`가 지정되지 않은 경우 `addr`에 지정된 주소에 세그먼트를 부착합니다.
    - `addr`이 0이 아니고 `SHM_RND`가 지정된 경우 `(addr - (addr % SHMLBA))`에 세그먼트를 부착합니다.

### `shmdt(2)` 시스템 호출

- `addr` 매개변수는 이전에 `shmat` 호출로 반환된 값입니다. 호출이 성공하면, `shmdt`는 해당 `shmid_ds` 구조체의 `shm_nattch` 카운터를 감소시킵니다.

### `shmctl(2)` 시스템 호출

- `cmd` 매개변수는 `shmid`로 지정된 세그먼트에 대해 수행할 다섯 가지 명령 중 하나를 지정합니다.