## SIGNAL 1
######  신호가 전달되는 시기
프로세스가 해당 신호에 기반하여 작업을 취할 때
######  신호의 수명
생성과 전달 사이의 간격
######  default action만 가능한 signal
SIGKILL, SIGSTOP
######  signal handler 내에서 signal이 catch되었을 때 프로세스가 어디에서 실행 중이었는지 알 수 있는가?
no
######  signal handling & fork, exec
- *프로세스가 `exec`를 호출하면, 기존의 signal handling이 없어진다*. 
	- (exec는 부모와 실행하는 프로그램이 달라 부모의 signal handling function을 찾지 못하기 때문)
- *프로세스가 `fork`를 호출하면, 자식 프로세스는 부모의 신호 처리를 상속*받습니다. 
	- (fork는 부모와 실행하는 프로그램이 같아 부모의 signal handling function을 찾을 수 있기 때문)
######  SA_SIGINFO 사용시 sigaction에서 사용되는 필드
sa_sigaction 필드를 사용해 signal handler를 `void handler(int signo, siginfo_t *info, void *context);` 처럼 호출함
######  signal을 받았을 때 시스템 호출이 중단되는 경우
slow system call 시에는 시스템 호출이 중단되며, 아래와 같은 경우
- *"느린" 시스템 호출*: 무기한 대기할 수 있는 호출 (시험 무조건)
  - 파이프, 터미널 장치 I/O, 네트워크 장치 I/O
  - pause(), wait()
  - Certain `ioctl` operations
  - ipc function중 일부
예외: disk I/O 호출은 slow system call에 포함되지 않는다.
######  자동으로 중단된 system call을 재시작하는 경우
  - *자동 재시작 시스템 호출: `ioctl`, `read`, `write`, `wait`, `waitpid` 등이 있으며, signal이 catch되면 재시작*됩니다.
  - *`sigaction`의 `sa_flags` 변수에 `SA_RESTART` 플래그를 설정하면, errno가 설정되지 않고 시스템 호출이 자동으로 재시작*됩니다.
	  - setting해준 signal만 재시작이 된다.
######  siginfo_t 내용
- si_signo -> signal number
- si_pid -> signal을 보낸 pid
- si_uid -> signal을 보낸 real user id
######  sigsetjump
goto문의 label 역할을 하며, 직접 호출시 0을 반환, siglongjmp를 이용해 호출시 0이 아닌 값 반환
######  siglongjmp
sigsetjmp로 저장된 신호 마스크 복원
다른 함수로 goto를 가능하게 만든다.
######  kill에서 pid 값에 따른 동작
`pid` 값에 따른 동작
- `pid > 0`: 프로세스 ID가 `pid`인 프로세스에 신호가 전송됩니다. (특정 pid 전송)
- `pid == 0`: 신호가 송신자의 프로세스 그룹 ID와 같은 프로세스 그룹 ID를 가진 모든 프로세스에 전송됩니다. (송신자의 그룹에 다 전송)
- `pid < -1`: 절대값이 `pid`인 프로세스 그룹 ID를 가진 모든 프로세스에 신호가 전송됩니다. (그룹에 전송)
- `pid == -1`: 송신자가 신호를 보낼 권한이 있는 시스템의 모든 프로세스에 신호가 전송됩니다. (다 전송)
######  신호를 보낼 권한
송신자의 실제 또는 유효 사용자 id가 수신자의 실제 또는 유효 사용자 ID와 같아야 한다.
###### kill(pid, 0)의 정의
signo 인자가 0이면 특정 프로세스가 여전히 존재하는지 확인하는 데 사용됨
프로세스가 존재하지 않으면 -1을 반환하고 errno는 ESRCH로 설정됨
프로세스 존재 여부 테스트는 원자적이지 않으므로 `kill`이 호출자에게 응답을 반환할 때쯤 해당 프로세스가 이미 종료되었을 가능성이 있습니다. 따라서 이 정보의 유효성은 제한적입니다.
######  `alarm` 호출 시 이전에 등록된 알람 클럭이 만료되지 않은 경우:
해당 알람 클럭에 남은 시간이 반환되고, 이전 알람 클럭이 새로운 값으로 대체됩니다.
## PIPE
######  pipe에서 read 호출 시 데이터가 있을 때 없을 때 동작
  - 파이프에 데이터가 있을 때: 즉시 반환됩니다.
  - 파이프가 비어 있을 때: 파이프에 데이터가 쓰여질 때까지 block한다.
######  pipe에서 write 호출 시 데이터가 가득 찼을 때 안 찼을 때 동작
  - 파이프가 가득 차지 않았을 때: 즉시 반환됩니다.
  - 파이프가 가득 찬 경우: 공간이 생길 때까지 block 한다.
######  pipe의 한쪽 끝이 닫힌 경우
- 쓰기 끝이 닫힘: 모든 데이터를 읽은 후 `read`는 파일 끝(EOF)을 나타내기 위해 0을 반환합니다.
- 읽기 끝이 닫힘: SIGPIPE 신호가 생성됩니다.
  - 이 신호를 무시하거나 잡아서 신호 처리기로부터 반환하면, `write()`는 -1을 반환하고 `errno`는 `EPIPE`로 설정됩니다.
  - pipe에 대한 write는 slow system call로 간주하기 때문에 SIGPIPE를 받으면 write()는 실패한다.
######  파이프가 가득찬 경우
`write`가 차단되어 다른 프로세스가 파이프에서 읽을 때까지 대기합니다.
######  `PIPE_BUF` 바이트를 초과하여 쓰는 경우
데이터가 다른 프로세스의 쓰기 데이터와 섞일 수 있다.
######  Non-Blocking I/O를 지정하는 두 가지 방법
1. 파일 디스크립터를 열 때: `O_NONBLOCK` 옵션을 지정합니다.
2. 이미 열린 디스크립터의 경우: `fcntl`을 호출하여 `O_NONBLOCK` 파일 상태 플래그를 켭니다.
###### Non-blocking 설정을 하고, 파이프가 가득 찰 때 write, 파이프가 비어 있을 때 read
- 파이프가 가득 찬 경우: `fcntl(p[1], F_SETFL, O_NONBLOCK)`
	- 반환 값은 -1이 되고, errno는 EAGAIN으로 설정됩니다.
- 파이프가 비어 있는 경우: `fcntl(p[0], F_SETFL, O_NONBLOCK)`
	- 반환 값은 -1이 되고, errno는 EAGAIN으로 설정됩니다.
######  fifo와  pipe의 차이점
- 파이프는 관련된 프로세스 간에만 사용할 수 있으며, 공통 조상 프로세스가 파이프를 생성한 경우에만 사용할 수 있습니다.
- 그러나 FIFO를 사용하면 관계없는 프로세스도 데이터 교환이 가능합니다. (fd를 공유하지 않아도 사용할 수 있다. FIFO라는 파일에서 open만 하면 되도록 구현했기 때문)
######  fifo는 half-duplex인가 full-duplex인가?
half-duplex
######  fifo는 어디에 저장되는가
disk에 파일로 저장된다.
######  pipe나 fifo에서 lseek를 호출하면
ESPIPE 오류 반환
######  사진에서 fd 값은?
![[Pasted image 20241201223220.png]]

위 fd -1
아래 fd 3
만약 O_NONBLOCK 플래그를 설정하고 read용 fd가 열리지 않았는데 write를 하면 SIGPIPE가 날아오기 때문에 file open을 항상 실패시켜야 한다.
그러나 O_NONBLOCK 플래그를 설정하고 0_RDONLY플래그를 이용해 파일을 열면, write용 fd없이 read를 하더라도 0을 리턴하는 것이지 에러가 발생하는 것은 아니므로 file open을 허용한다.
######  select의 nfds 번호 지정 방법
두 개의 파일 디스크립터 3과 4가 열려 있으면 `nfds`를 5로 설정해야 합니다.
######  select의 timeout값 null 0 양수
- `timeout == NULL`: 무기한 대기하며, 지정된 디스크립터 중 하나가 준비되거나 신호가 잡힐 때 반환합니다.
- `timeout->tv_sec == 0 && timeout->tv_usec == 0`: 대기하지 않고 즉시 반환하며, 모든 디스크립터를 테스트합니다.
- `timeout->tv_sec != 0 || timeout->tv_usec != 0`: 지정된 시간 동안 대기하고, 지정된 디스크립터 중 하나가 준비되거나 시간이 만료되면 반환합니다. 디스크립터가 준비되지 않고 시간이 만료되면 반환 값은 0입니다.
######  select의 반환값
- 반환 값이 -1인 경우: 오류 발생 시, 예: 신호가 잡힐 때. 
	- 디스크립터 세트가 수정되지 않습니다.
- 반환 값이 0인 경우: 디스크립터가 준비되지 않았을 때, 예: 타임아웃 만료 시. 
	- 모든 디스크립터 세트는 0으로 설정됩니다.
- 반환 값이 양수인 경우: 준비된 디스크립터 수를 나타내며, 세 세트에 준비된 디스크립터의 총합을 반환합니다.
  - 같은 디스크립터가 읽기 및 쓰기 준비가 되어 있으면 두 번 계산됩니다.
  - 세 개의 디스크립터 세트에서 켜진 비트는 준비된 디스크립터에 해당합니다.
######  select set 순서
read write except
## IPC
######  ipc_perm의 `uid`, `gid`, `mode` 필드를 수정할 수 있는 권한
creator
######  ftok의 단점
잘못하면 unique하지 않은 키를 생성할 수 있다.
######  IPC는 실행 권한에 해당하는 것이 없다
O
######  msqid_ds 들어있는 것
```c
struct msqid_ds { /* <sys/msg.h> */
	struct ipc_perm msg_perm; /* see ch08_ipc1-_p.29_ */
	struct msg *msg_first; /* 큐에서 첫 번째 포인터 */
	struct msg *msg_last; /* 큐에서 마지막 포인터 */
	msglen_t msg_cbytes; /* 메시지 큐의 전체 사이즈 */
	msgqnum_t msg_qnum; /* # 큐에 있는 메시지 개수 */
	msglen_t msg_qbytes; /* 큐 안에 있는 전체 byte의 최대 사이즈 */
	pid_t msg_lspid; /* 가장 최근에 메시지를 send한 pid */
	pid_t msg_lrpid; /* 가장 최근에 메시지를 receive한 pid */
	time_t msg_stime; /* 가장 최근에 메시지를 send한 시간 */
	time_t msg_rtime; /* 가장 최근에 메시지를 receive한 시간 */
	time_t msg_ctime; /* 메시지가 가장 최근에 변경된 시간 */
};
```
######  msgget 에러
- `EACCES`
	- 키에 해당하는 메시지 큐가 존재하지만, 권한이 거부됨
- `EEXIST`
	- 키에 해당하는 메시지 큐가 존재한다. `((flag & IPC_CREAT) && (flag & IPC_EXCL)) == -1`(key가 있어서 `IPC_EXCL`로 오류 발생)
- `ENOENT`
	- 키에 해당하는 메시지 큐가 존재하지 않다. `(msgflg & IPC_CREAT) == 0`
- `ENOSPC`
	- 시스템 전체의 메시지 큐 제한을 초과함
######  msgrcv에서 type에 따른 행동
- `type` 행동: (type 번호와 일치하는 mymesg만 가져올 수 있다.)
	- `== 0`: 큐의 첫 번째 메시지 제거
	- `> 0`: 큐에서 특정 `type`의 첫 번째 메시지 제거
	- `< 0`: 절대값 이하의 가장 낮은 `type`의 첫 번째 메시지 제거
######  msgrcv에서 MSG_NOERROR 설정
반환된 메시지가 nbytes보다 크면 메시지가 잘린다.
플래그가 없으면 E2BIG 오류가 반환된다.
######  IPC ctl cmd 종류
- `IPC_STAT` 
	- `msqid_ds` 데이터 구조체의 멤버를 buf에 복사합니다.
- `IPC_SET` 
	- buf로부터 `msqid_ds` 데이터 구조체의 멤버를 설정합니다.
- `IPC_RMID` 
	- 메시지 큐 `msqid`를 제거하고 해당 `msqid_ds`를 삭제합니다.
######  semid_ds 구조
```c
struct semid_ds {
	struct ipc_perm sem_perm; // 세마포어 permission
	struct sem *sem_base; // 세마포어 set에 대한 포인터 array
	ushort_t sem_nsems; // 세마포어 개수
	time_t sem_otime; /* last-semop()time */
	time_t sem_ctime; /* last-change time */
};

struct sem {
	ushort_t semval; /* semaphore value, nonegative*/
	short sempid; /* PIDof last successful semop(), SETVAL, SETALL*/
	ushort_t semncnt; /* # awaiting semval > current value */
	ushort_t semzcnt; /* # awaiting semval = 0 */
};
```
######  semget의 nsems
세트 내 세마포어 요소 수 (`nsems == 0`일 경우 기존 세트를 참조)
######  semop에서 sem_op에 따른 동작
`sem_op > 0`: V() -> signal operation, 세마포어를 증가시켜 자원의 해제를 기록합니다. sem_op를 semval에 더합니다.
`sem_op < 0`: P() -> wait operation, 세마포어를 감소시켜 자원의 획득을 기록합니다. semval이 abs(sem_op) 이상이 될 때까지 블록됩니다. semval은 abs(sem_op)만큼 감소합니다.
`sem_op` == 0: 세마포어가 0인지 테스트합니다. semval이 0이 될 때까지 블록됩니다. (실제 사용 x)
######  SEM_UNDO란?
세마포어를 wait하여 리소스를 확보해놓고, 비정상적으로 종료되면 커널이 확보한 리소스에 대한 정보를 알아두고 있다가 자동적으로 반환시켜주는 작업을 SEM_UNDO가 한다.
######  semaphore element
- 각 세마포어 요소는 다음 정보를 포함합니다(`struct sem`):
  - `semval`: 세마포어 값 (0 이상)
  - `sempid`: 마지막으로 세마포어를 조작한 프로세스 ID
  - `semncnt`: 세마포어 값이 증가하기를 기다리는 프로세스 수 (중요 x)
  - `semzcnt`: 세마포어 값이 0이 되기를 기다리는 프로세스 수 (중요 x)
- 세마포어 값이 0이 되면 큐에 있는 프로세스가 깨워집니다.
######  semctl 사용법
• IPC_STAT: 세마포어 집합 semid의 구성원을 semid_dso에서 `arg.buf`로 복사합니다.
• IPC_SET: `arg.buf`에서 세마포어 집합의 권한을 설정합니다.
• GETVAL: 특정 세마포어 요소의 값을 반환합니다.
• SETVAL: 특정 세마포어 요소의 값을 `arg.val`로 설정합니다.
• GETALL: `arg.array`에 있는 세마포어 집합의 값을 반환합니다.
• SETALL: `arg.array`에서 세마포어 집합의 값을 설정합니다.
######  semun 구조
```c
union semun { // (semaphore union)
	int val; /* for SETVAL */ // 세마포어의 값
	struct semid_ds *buf; /* for IPC_STAT and IPC_SET */
	unsigned short *array; /* for GETALL and SETALL */
};
```
######  sembuf 어디에 쓰는지, 구조
semop의 두 번째 인자
```c
struct sembuf {
	unsigned short sem_num; /* member # in set (0, 1, ..., nsems-1) */
	short sem_op; /* operation (negative, 0, or positive) */
	short sem_flg; /* IPC_NOWAIT, SEM_UNDO */
};
```
######  shmid_ds 구조
```c
struct shmid_ds {
	struct ipc_perm shm_perm; /* see Section 15.6.2 */
	size_t shm_segsz; // 공유 메모리 크기
	pid_t shm_lpid; // shmop를 사용한 시간
	pid_t shm_cpid; // 공유 메모리를 만든 pid
	shmatt_t shm_nattch; // 공유 메모리와 연결되어 있는 프로세스 개수
	time_t shm_atime; // 마지막에 프로세스를 attach한 시간
	time_t shm_dtime; // 마지막에 프로세스를 detach한 시간
	time_t shm_ctime; // 마지막 프로세스를 변경한 시간 
	. . .
};
```
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답

## IPC 2
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답

## SOCKET
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
######  문
답
