### 손실 업데이트 문제

- UNIX 파일이 여러 프로세스에서 동시에 접근될 수 있기 때문에 이 문제가 발생합니다. `lseek`, `read`, `write`로 구성된 논리적 작업이 두 개 이상의 프로세스에 의해 동시에 수행될 수 있습니다.
- 이 문제를 해결하는 한 가지 방법은 **프로세스가 작업 중인 파일의 일부를 잠그는 것**입니다.

### 레코드 잠금

- **두 사용자가 동시에 같은 파일을 편집할 때** 무슨 일이 발생할까요?
  - 최종 파일 상태는 마지막으로 파일을 작성한 프로세스의 결과와 일치합니다.
  - 하지만, 데이터베이스 시스템처럼 **단일 프로세스가 파일에 쓰고 있다는 확신이 필요한 경우**가 있습니다.
  - 이를 위해 상용 UNIX 시스템에서는 **레코드 잠금(바이트 범위 잠금)** 기능을 제공합니다.
- 레코드 잠금은 **데이터베이스에서 데이터에 동시에 접근하는 것을 방지**하여 일관성 없는 결과를 피하는 기법입니다.
- POSIX.1은 `fcntl` 접근 방식을 표준화하기로 했으며, **POSIX 레코드 잠금**은 **조언적 잠금(advisory locking)**이라고 합니다.

### 두 가지 레코드 잠금 유형 (1/2)

- **조언적 잠금**:
  - 라이브러리의 모든 접근 함수는 레코드 잠금을 일관되게 처리합니다.
  - 그러나 조언적 잠금은 파일에 쓰기 권한이 있는 다른 프로세스의 접근을 완전히 막지는 않습니다.
  - 조언적 잠금은 **협력하는 프로세스 간**에는 유용합니다.

- **강제 잠금**:
  - 커널이 모든 읽기 및 쓰기 요청을 확인하여 잠금을 소유한 프로세스와 충돌하지 않는지 확인합니다.
  - 일반 차단 디스크립터에서 강제 잠금과 충돌하는 읽기나 쓰기는 **해제될 때까지 프로세스를 대기 상태**로 만듭니다.
  - 강제 파일 잠금을 허용하려면 파일 시스템을 마운트해야 합니다.

### `fcntl(2)` 레코드 잠금 (1/2)

- `F_GETLK`:
  - `flockptr`로 지정된 잠금을 확인합니다.
  - 잠금이 존재하면 `*flockptr`가 기존 잠금으로 덮어씌워집니다.
  - 잠금이 없으면 `flockptr->l_type = F_UNLCK`로 설정됩니다.

- `F_SETLK`:
  - `flockptr`로 지정된 잠금을 설정합니다.
  - **읽기 잠금**: `flockptr->l_type = F_RDLCK`
  - **쓰기 잠금**: `flockptr->l_type = F_WRLCK`
  - **잠금 해제**: `flockptr->l_type = F_UNLCK`
  - 불법적인 레코드 잠금을 시도하면 `fcntl()`이 `errno = EAGAIN`을 반환합니다.

- `F_SETLKW`:
  - `F_SETLK`의 **차단 버전**입니다.
  
### 잠금 규칙 (1/2)

- 잠금은 파일의 현재 끝을 넘어 확장할 수 있지만, 파일 시작보다 이전에서 시작하거나 확장할 수 없습니다.
- `l_len`이 0이면, 잠금이 파일의 최대 오프셋까지 확장됨을 의미합니다. 이로써 파일의 어느 위치에서든 잠금을 설정할 수 있으며, 파일에 추가된 데이터까지 포함합니다.
- 파일 전체를 잠그기 위해 `l_start` 및 `l_whence`를 파일 시작으로 설정하고 `l_len`을 0으로 지정합니다.
  - `l_start`: 0
  - `l_whence`: `SEEK_SET`
- 잠금의 두 가지 유형:
  - **공유 읽기 잠금 (F_RDLCK)**
  - **독점 쓰기 잠금 (F_WRLCK)**

- **호환성 규칙**: **다른 프로세스**가 요청한 잠금에만 적용되며, 동일 프로세스의 여러 잠금 요청에는 적용되지 않습니다.
  - 기본 규칙은 **여러 프로세스가 동일한 바이트에 대해 공유 읽기 잠금을 가질 수 있지만, 한 프로세스만 독점 쓰기 잠금을 가질 수 있습니다**.
  - 또한, 하나 이상의 읽기 잠금이 설정된 경우 해당 바이트에 쓰기 잠금을 설정할 수 없습니다.

### 잠금의 암시적 상속 및 해제

- **잠금은 프로세스와 파일에 연결**됩니다.
  - 프로세스가 종료되면 모든 잠금이 해제됩니다.
  - 프로세스에서 디스크립터를 닫을 때 해당 파일의 잠금이 해제됩니다.
  - **자식 프로세스는 잠금을 상속받지 않습니다** (`fork`를 통해).
  - **새 프로그램은 잠금을 상속받습니다** (`exec`를 통해).
    - 그러나 `close-on-exec` 플래그가 설정된 파일 디스크립터는, `exec` 과정에서 닫히면서 모든 잠금이 해제됩니다.

### 시스템은 인접한 영역을 결합하거나 분할합니다

- 파일의 잠금을 설정하거나 해제할 때 시스템은 필요에 따라 인접한 영역을 결합하거나 분할합니다.
- 예를 들어, **바이트 100부터 199까지 잠금**하고, **바이트 150의 잠금을 해제**하면, 커널은 여전히 바이트 100-149와 151-199의 잠금을 유지합니다.

### ACME 항공 문제 다시 보기

- **데이터베이스 무결성**을 보장하려면 ACME의 중요한 코드 구간을 다음과 같이 처리하면 됩니다.
  1. 관련 데이터베이스 구간에 **쓰기 잠금을 설정**
  2. **데이터베이스 구간 업데이트**
  3. **데이터베이스 구간 잠금 해제**
- 이 상황은 **교착 상태**로 설명될 수 있습니다.
  - 다행히 UNIX는 이 문제 발생을 방지합니다.
    - `F_SETLKW` 요청이 교착 상태를 유발할 경우 호출이 실패하고 -1을 반환하며 `errno`가 `EDEADLK`로 설정됩니다.
    - `fcntl`은 **두 프로세스 간 교착 상태**만 감지할 수 있으며, 세 개의 프로세스가 교착 상태를 유발할 수도 있습니다.
### IPC (프로세스 간 통신)

- POSIX의 XSI 확장에 포함된 IPC 함수들은 **System V IPC** 함수에 기초하여 개발되었습니다.
- **같은 시스템 내에서 프로세스 간 정보를 공유할 수 있는 메커니즘**을 제공합니다.

### 권한 구조

- IPC 객체가 생성될 때, 시스템은 IPC 시설 상태 구조도 함께 생성합니다.
- 접근 권한은 **유효 사용자 ID와 그룹 ID**에 의해 결정됩니다.
- IPC 시설이 생성될 때 `umask` 값은 적용되지 않습니다.
- `msgctl`, `semctl`, 또는 `shmctl` 호출을 통해 `uid`, `gid`, `mode` 필드를 수정할 수 있습니다. 단, **생성자**나 **슈퍼유저**만 가능합니다.

### 식별자와 키

- **키 (Key)**:
  - IPC 객체의 외부 이름 역할을 합니다.
  - IPC 구조가 생성될 때마다(`msgget`, `semget`, `shmget` 호출) 키가 지정되어야 합니다.
  - 데이터 타입은 `key_t`이며, `<sys/types.h>`에 정의된 **long integer** 타입입니다.

- **식별자 (Identifier)**:
  - IPC 객체의 내부 이름이며, **음수가 아닌 정수**입니다.
  - `get` 작업의 결과로 반환됩니다.
  - **파일 디스크립터와 비슷하게 작동**하지만, IPC 식별자는 고유합니다. 즉, 다른 프로세스가 동일 IPC 객체를 참조할 때도 동일한 값을 사용합니다.

### `ftok(2)` 시스템 호출

- **경로**와 **ID**를 **IPC 키(key_t)** 값으로 변환하는 함수입니다.
- 매개변수:
  - `path`: 기존 파일이어야 합니다.
  - `id`: **하위 8비트**만 사용됩니다.
- `path`와 `id`의 조합으로 **IPC 객체를 고유하게 식별**할 수 있습니다.
- `path`가 존재하지 않거나 호출 프로세스에서 접근할 수 없으면 `ftok`는 **-1을 반환**합니다.

### 세 가지 XXXget 함수

- **IPC 객체를 생성하거나 여는 함수**이며 모두 IPC 키를 사용합니다.

- **키 선택 방법**:
  1. 시스템이 키를 선택하게 함 (`IPC_PRIVATE` 사용).
  2. 직접 키를 지정함.
  3. `ftok`를 호출하여 지정된 경로로부터 키를 생성함.

- **권한 플래그**:
  - `IPC_CREAT`는 `O_CREAT`와 유사합니다.
  - `IPC_EXCL`는 `O_EXCL`와 유사합니다.

### IPC get 연산 (2/2)

- IPC 구조에 대해 **실행 권한에 해당하는 것이 없습니다**.
- 메시지 큐와 공유 메모리는 **읽기(read)와 쓰기(write)**라는 용어를 사용하지만, **세마포어는 읽기(read)와 변경(alter)**이라는 용어를 사용합니다.

### IPC 제어 연산

- IPC 리소스를 처리하기 위해 사용할 수 있는 함수들입니다.

### IPC 키에서 IPC 식별자 생성하기

- **IPC 키로부터 IPC 식별자를 생성**하여 사용합니다.

### 셸에서 IPC 리소스 접근하기

- IPC 리소스는 **셸을 통해서도 접근할 수 있습니다**.