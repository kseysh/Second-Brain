# Signal Concepts
-  커널에서 일어나는 일
	- 키보드 입력을 담당하는 커널이 인터럽트 문자를 감지한다.
	- SIGINT라는 신호를 모든 프로세스(포어그라운드 그룹)에 보낸다.
	- cc가 이 신호를 받으면, SIGINT와 관련된 기본 동작을 수행하고 종료한다.
- 신호는 소프트웨어 인터럽트이다.
- 신호는 비동기 이벤트를 처리하는 방법을 제공한다.
- 프로세스는 단순히 변수를 테스트하여(예: errno) 신호가 발생했는지 확인할 수 없다.
	-  대신 프로세스는 커널에 “이 신호가 발생하면 다음 작업을 수행하라”고 알려야 한다.

- 모든 신호에는 이름이 있다. 이 이름들은 모두 SIG(예: SIGABRT)로 시작한다.
	- 이 이름들은 모두 <signal.h> 헤더에 정의된 양의 정수 상수(신호 번호)로 정의된다.
- 다양한 조건이 신호를 생성할 수 있다.
- 터미널에서 생성된 신호(Control-C -> SIGINT)
- 하드웨어 예외가 신호를 생성한다(0으로 나누기 등).
- kill(2) 함수
- kill(1) 명령어(kill -9 \#pid)
- 소프트웨어 조건(SIGURG, SIGPIPE, SIGALRM 등)

![[Pasted image 20241014130910.png|600]]
• SIGABRT : abort 함수 호출에 의해 생성됨.
• SIGALRM : 설정된 타이머가 만료되면 생성됨.
• SIGCHLD : 프로세스가 종료되거나 멈출 때마다 부모 프로세스에 신호가 보내짐.
• SIGCONT : 멈춘 프로세스가 계속될 때 보내지는 신호.
• SIGFPE : 0으로 나누기, 부동 소수점 오버플로 등 산술 예외를 알림.
• SIGILL : 프로세스가 불법 하드웨어 명령어를 실행했음을 알림.
• SIGINT : 인터럽트 키를 입력할 때 터미널 드라이버에 의해 생성되어 포어그라운드 프로세스 그룹의 모든 프로세스에 보내짐.
• SIGKILL : 잡을 수 없고 무시할 수 없다. 어떤 프로세스든 확실히 종료시킬 수 있는 방법.
• SIGPIPE : 파이프라인에 쓰기 시도 시 리더가 종료된 경우 생성됨.
• SIGSEGV : 프로세스가 유효하지 않은 메모리 참조를 했음을 알림. (코어 덤프)
• SIGTERM : 기본적으로 kill(1) 명령어에 의해 보내지는 종료 신호.
• SIGTSTP : 터미널 드라이버에서 Cntl-Z가 입력되어 포어그라운드 프로세스 그룹의 모든 프로세스에 보내짐.
• SIGUSR1 : 사용자 정의 신호 1
• SIGUSR2 : 사용자 정의 신호 2
• SIGSTOP : 잡 제어 신호로, 잡을 수 없고 무시할 수 없다.

• 신호는 이벤트의 소프트웨어 알림이다.
• 신호는 해당 신호를 발생시키는 이벤트가 발생하면 생성된다.
• 신호는 프로세스가 해당 신호에 기반하여 작업을 취할 때 전달된다.
• 신호의 수명은 생성과 전달 사이의 간격이다.
• 생성되었지만 아직 전달되지 않은 신호는 보류 중이라고 한다.
• 프로세스가 신호 핸들러를 실행할 때 신호를 수신했다고 한다.
• 프로그램은 sigaction을 호출하여 사용자 정의 함수 이름으로 신호 핸들러를 설치한다.
## 정상 비정상 종료
![[Pasted image 20241014131012.png|600]]
# 신호 처리
- 신호가 발생하면 세 가지 작업 중 하나를 수행한다.
	- 무시 동작
		-  하지만 SIGKILL과 SIGSTOP 두 신호는 무시할 수 없다.
- 사용자 정의 동작
	- 이를 위해 신호가 발생할 때마다 커널이 우리의 함수를 호출하도록 지시한다(신호 핸들러).
	- SIGKILL과 SIGSTOP 두 신호는 잡을 수 없음을 유의한다.
- 기본 동작
	- 모든 신호에는 기본 동작이 있다.
	- 기본 동작은 일반적으로 프로세스를 종료시키는 것이다.
## 신호 처리: 사용자 정의 동작
• 잡힌 신호가 프로세스에 의해 처리될 때, 프로세스가 실행 중인 정상적인 명령어 시퀀스는 신호 핸들러에 의해 일시 중단된다.
• 그런 다음 프로세스는 계속 실행되지만 신호 핸들러의 명령어를 실행한다.

신호 핸들러가 반환되면(예를 들어 exit 또는 longjmp를 호출하지 않는 한), 신호가 잡혔을 때 프로세스가 실행 중이던 정상적인 명령어 시퀀스가 계속 실행된다.
• 그러나 신호 핸들러 내에서는 신호가 잡혔을 때 프로세스가 어디에서 실행 중이었는지 알 수 없다.
## 프로세스 신호 마스크 – 프로세스 속성
• 신호가 생성될 때 취해지는 동작은 현재 신호 핸들러와 프로세스 신호 마스크에 따라 다르다.
• 신호 마스크는 차단될 신호 목록을 포함한다.
• 프로그램은 sigprocmask를 사용하여 프로세스 신호 마스크를 변경하여 신호를 차단한다.
• 프로세스는 fork와 exec 이후에도 신호 마스크를 상속한다.
## signal(2) 시스템 호출(1/2)
```c
#include <signal.h>
void (*signal(int signo, void (*func)(int)))(int);
// Returns: previous disposition of signal (see following) if OK, SIG_ERR on error
```

• signal 함수는 ISO C에 정의되어 있으며, 이는 다중 프로세스, 프로세스 그룹, 터미널 I/O 등을 포함하지 않는다.
• signal의 의미가 구현마다 다르기 때문에, sigaction 함수를 사용하는 것이 좋다.
• 이 함수는 구형 의미를 필요로 하는 응용 프로그램에 대한 하위 호환성을 제공한다.
• 새로운 응용 프로그램은 이러한 신뢰할 수 없는 신호를 사용해서는 안 된다.
signal()의 프로토타입은 두 개의 인수를 필요로 하며 아무것도 반환하지 않는 함수( void)를 가리키는 포인터를 반환한다고 명시하고 있다.