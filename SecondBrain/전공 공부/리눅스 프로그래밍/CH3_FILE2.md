## 3.1 멀티유저 환경에서의 파일들 사용자 및 소유권 (1/3)
### 소유자
• UNIX 시스템의 모든 파일은 시스템 사용자가 소유합니다.
• 소유자는 일반적으로 파일을 생성한 사용자입니다.
• 소유자의 실제 신원
	• 사용자 ID (종종 uid로 약칭됨)
	• 특정 사용자 이름과 연결된 uid
![[Pasted image 20241008152311.png|350]]
• 각 UNIX 프로세스는 **일반적으로 해당 프로세스를 시작한 사용자의 uid와 연결**됩니다.
• 파일이 생성될 때, 시스템은 생성 프로세스의 uid를 참조하여 소유권을 설정합니다.
• 소유권 변경
	• 슈퍼유저 또는 파일의 소유자
	• 슈퍼유저(username=root, uid=0)
### 그룹
• 각 사용자는 적어도 하나 이상의 그룹에 속해 있습니다.
```shell
$ usermod -G group1,group2 user1
$ id
uid=509(user1) gid=509(group1) groups=509(group1),510(group2)
```
• `/etc/group`에 정의됨
• 그룹의 실제 신원
	• 그룹 ID (종종 gid로 약칭됨)
	• 특정 그룹 이름과 연결된 gid
• gid와 uid는 사용자가 시작한 프로세스에 의해 상속됩니다.

## 실제 사용자 및 그룹 ID
• 실제 사용자 ID (ruid) - 프로세스를 시작한 사용자의 uid
• 유효 사용자 ID (euid) - 특정 작업을 수행할 프로세스의 권한을 평가하는 데 사용됨
• 대부분의 경우, 유효 사용자 ID와 실제 사용자 ID는 일치합니다
• 유효 사용자 및 그룹 ID는 파일 접근 권한을 결정합니다.

## 권한 및 파일 모드 (1/3)
### 소유권
• 파일에 연결된 권한을 선택할 수 있음
### 권한
• 다른 사용자가 파일에 접근할 수 있는 방법을 결정함
• 슈퍼유저는 읽기, 쓰기 또는 실행 권한과 상관없이 모든 파일을 조작할 수 있음
![[Pasted image 20241008153427.png|300]]
![[Pasted image 20241008153504.png|300]]  
ls시에 owner/group/other로 permission이 나옴
![[Pasted image 20241008153612.png|400]]
```shell
S_IRUSER | S_IRGRP | S_IROTH = 0444 = r--r--r--
S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IXGRP | S_IXOTH | S_IXOTH = 0755 = rwx-r-xr-x
```
앞은 무조건 S_I /W/R/X USR/GRP/OTH
### open(2)와 파일 권한
• open을 사용하여 기존 파일을 열면
• 시스템은 파일의 권한을 확인하여 프로세스에서 요청한 접근 모드가 허용되는지 확인합니다.
• 프로세스에 요청된 접근 권한이 없으면 open은 -1(errno=EACCESS)을 반환합니다.
• **파일을 열 때 커널은 유효 사용자 및 그룹 ID를 기반으로 접근 테스트를 수행**합니다.

![[Pasted image 20241008154325.png]]
알아보기
### 파일 접근 테스트
• 커널이 수행하는 테스트는 다음과 같습니다.
	• 프로세스의 유효 사용자 ID가 0 (슈퍼유저)인 경우 접근이 허용됩니다.
	• 프로세스의 유효 사용자 ID가 파일의 소유자 ID와 같은 경우, 적절한 사용자 접근 권한 비트가 설정되어 있으면 접근이 허용됩니다. 그렇지 않으면 접근이 거부됩니다.
	• 프로세스의 유효 그룹 ID가 파일의 그룹 ID와 같은 경우, 적절한 그룹 접근 권한 비트가 설정되어 있으면 접근이 허용됩니다. 그렇지 않으면 접근이 거부됩니다
	• 적절한 다른 접근 권한 비트가 설정되어 있으면 접근이 허용됩니다. 그렇지 않으면 접근이 거부됩니다.

### 실행 파일에 대한 추가 권한 (1/3)
• 파일에 실행 가능한 프로그램이 포함된 경우에만 관련이 있습니다.
![[Pasted image 20241008154918.png|300]]
• `S_ISUID` 권한이 설정된 경우, 실행 파일이 시작되면 시스템은 생성된 프로세스에 사용자 ID 대신 파일 소유자로부터 가져온 유효 사용자 ID를 부여합니다.
• 스티키 비트 (save-text-image)
• S_ISVTX 비트는 실행 파일에 설정할 수 있습니다.
• 초기 시스템에서는 save-text-image 비트가 파일에 설정된 경우, 실행 시 프로그램 텍스트 부분이 시스템이 중단될 때까지 시스템의 스왑 영역에 남아 있었습니다.
• 현대 UNIX 시스템에서는 이 비트가 이제 불필요합니다.
• 현대 시스템에서는 디렉토리에 대해 S_ISVTX 비트를 정의합니다.

**파일 생성 마스크**

• 각 프로세스와 연결된 값은 파일 생성 마스크입니다.
• 파일 생성 마스크 (보호)
• 파일이 생성될 때 특정 권한 비트를 자동으로 해제합니다.
• 지정된 권한이 실수로 켜지는 것을 방지합니다.
  
**umask(2) 시스템 호출**
• umask 함수는 프로세스의 파일 모드 생성 마스크를 설정합니다.

**access(2) 시스템 호출**
• **access**는 실제 사용자 및 그룹 ID를 기반으로 경로명의 접근 권한을 확인합니다.
• **인수**
**chmod(2) 시스템 호출**
• 기존 파일의 권한을 변경합니다.
• **파일의 소유자 또는 슈퍼유저만** 가능합니다.

**chown(2) 시스템 호출**
• 파일의 사용자 ID와 그룹 ID를 변경할 수 있습니다.
• **인수**
• **owner_id**: 새로운 소유자 ID
• **group_id**: 새로운 그룹 ID
• owner_id 또는 group_id 중 하나라도 -1인 경우, 해당 ID는 변경되지 않습니다.
• 파일 소유권을 변경하려는 불법 시도 시 항상 **EPERM** 오류가 반환됩니다.
• 파일의 소유권이 변경되면 해당 파일의 set-user-id 및 set-group-id 권한이 해제됩니다.

**3.2 여러 이름을 가진 파일**
**파일 시스템**
• 파일 시스템은 하드 디스크 등의 저장 장치에 파일을 저장하기 위한 논리적 구조를 구성하는 소프트웨어 구성 요소입니다.
• 파일 및 폴더를 저장할 수 있는 계층적 구조로 나타납니다. 각 파일 시스템의 계층 구조의 맨 위는 일반적으로 “루트”입니다.
• 파일 시스템은 파일 및 폴더의 명명 규칙을 지정합니다.

**Mount-on**
• 디렉토리는 마운트된 파일 시스템에 의해 덮여집니다.
• 마운트 테이블 및 vfs 목록

**UNIX 파일 시스템(1/2)**
• 파일에 대한 링크 개념을 이해하려면 UNIX 파일 시스템의 구조에 대한 개념적 이해가 필요합니다.
• 오늘날 여러 UNIX 파일 시스템 구현이 사용되고 있습니다. (UFS, PCFS, HSFS 등)

• **부트 블록**
• UNIX가 처음 활성화될 때 사용되는 부트 코드

• **슈퍼 블록**
• 파일 시스템의 총 블록 수
• inode 자유 목록에 있는 inode 수
• 자유 블록의 비트 맵
• 블록 크기(바이트 단위)
• 자유 블록 수
• 사용된 블록 수

• **i-노드**
• 디스크에 있는 파일과 연관된 모든 inode
• 파일을 고유하게 식별함

• **데이터 블록**
• 파일 블록을 저장하기 위한 블록

**i-노드**
• 각 파일(일반 파일, 디렉토리, 특수 파일 등)은 하나의 i-노드를 사용하며 적어도 하나의 디렉토리에서 링크되어야 합니다.
• 디스크에 데이터를 가진 파일(일반 파일, 디렉토리, 심볼릭 링크)도 i-노드에서 가리키는 데이터 블록을 가집니다
• i-노드 0과 1은 사용되지 않습니다.
• 0: “no i-node”를 의
• 1: 나쁜 디스크 블록을 모으는 데 사용됨
• i-노드 2는 루트 디렉토리(/)에 예약되어 있습니다.

**하드 링크 & 심볼 링크(1/2)**
• **하드 링크**
• 하드 링크는 파일에 대한 직접 포인터입니다.
• 링크 수는 i-노드를 가리키는 디렉토리 항목 수입니다.
• 링크 수가 0이 되어야 파일이 삭제될 수 있습니다.
• 이러한 유형의 링크를 하드 링크라고 합니다.
• 파일 시스템을 넘나들 수 없습니다.
• 디렉토리에 하드 링크를 생성할 수 있는 유일한 사용자는 슈퍼유저입니다.

• **심볼 링크**
• 심볼릭 링크는 파일에 대한 간접 포인터입니다.
• 심볼 링크의 실제 내용은 링크된 파일입니다.
• 파일 시스템 제한이 없습니다.
• 하드 링크와 심볼 링크에서 하드 링크가 생성됩니다.
• 하지만, 심볼 링크에 의해 생성된 하드 링크는 경로 문자열을 포함하는 파일에 대한 링크입니다.

**link(2) 시스템 호출**
• 새로운 디렉토리 항목을 생성하고 링크 수를 증가시킵니다.
• 디렉토리에 하드 링크 생성은 슈퍼유저에게만 제한됩니다. (파일 시스템 루프 방지)

• **인수**
• 두 경로명이 동일한 파일 시스템에 있어야 합니다.

**unlink(2) 시스템 호출**
```c
#include <unistd.h>
int unlink(const char *pathname);
```
• 반환 값: 성공 시 0, 오류 시 -1
• 기존 디렉토리 항목을 제거합니다.
• 이름이 지정된 링크만 제거하고 파일의 링크 수를 하나 줄입니다.
• 파일에 다른 링크가 있는 경우, 다른 링크를 통해 파일의 데이터에 여전히 접근할 수 있습니다.
• 링크 수가 0으로 줄어들면 디스크 블록이 자유 블록 목록에 추가됩니다.
• **unlink 권한?**

**remove(2) 시스템 호출**

• 파일의 경우, remove는 unlink와 동일합니다.
• ISO C는 파일을 삭제하기 위해 remove 함수를 지정합니다.
• 대부분의 비 UNIX 시스템이 파일에 대한 링크 개념을 지원하지 않았기 때문에, 이름은 역사적인 UNIX 이름인 unlink에서 remove로 변경되었습니다.
• 파일이나 디렉토리는 rename 함수를 사용하여 이름이 변경됩니다.
• 이 함수는 ISO C에서 파일을 위해 정의되었습니다. (C 표준은 디렉토리를 다루지 않습니다.)
• POSIX.1은 정의를 확장하여 디렉토리와 심볼릭 링크를 포함하도록 했습니다.

• **인수**
• oldname과 newname이 동일한 파일을 참조하는 경우, 함수는 아무 것도 변경하지 않고 성공적으로 반환됩니다.

**symlink(2) 시스템 호출**
• 심볼릭 링크 파일이 open으로 열리면, open 시스템 호출은 경로를 따라 realname을 정확하게 찾습니다.
• 프로그래머가 symname 자체에 저장된 데이터를 보려면 readlink 시스템 호출을 사용해야 합니다.

• **readlink 시스템 호출**
1. sympath를 엽니다.
2. 파일의 내용을 버퍼로 읽어들입니다.
3. sympath를 닫습니다.

• 원본 파일이 제거된 경우,
• 프로그램은 여전히 심볼릭 링크를 ‘볼’ 수 있지만, open 호출은 그 안에 포함된 경로를 따라갈 수 없으며 errno가 EEXIST로 설정된 상태로 반환됩니다.

# 3.3 파일 정보 얻기: stat과 fstat
**stat(2) 시스템 호출(1/2)**
• 이 함수들은 파일에 대한 정보를 얻습니다.
• **stat**: 지정된 파일
• **fstat**: 열린 파일
• **lstat**: 심볼릭 링크