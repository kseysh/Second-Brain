# CH01 BASIC


# CH02 FILE1
## File
파일은 운영 체제가 형식을 강제하지 않는다.
파일이 텍스트, 이미지등 어떤 형식이든 될 수 있다.
각 바이트는 개별적으로 주소를 지정 가능하다.
외부 장치와 일관되게 상호작용할 수 있는 인터페이스를 제공한다.
## File System
파일 시스템은 컴퓨터에서 파일을 저장하고, 조직화하며, 쉽게 찾고 접근할 수 있도록 도와주는 방법
파일 시스템은 사용자가 파일을 쉽게 찾고 사용할 수 있도록 구조화된 방식을 제공
파일 시스템은 데이터를 저장 장치(하드 디스크나 CD-ROM)에 저장
![[Pasted image 20240909171933.png]]

# UNIX primitives
UNIX 시스템에서 파일을 다루는 기본적인 함수들은 파일 디스크립터라는 정수를 통해 파일을 식별하고 관리하며, 이러한 함수들은 unbuffered I/O 방식으로 작동하여 데이터의 즉시 처리를 지원한다.
- **open**: 파일을 읽거나 쓰기 위해 열거나, 새 파일을 생성합니다.
- **create**: 빈 파일을 새로 만듭니다.
- **close**: 이전에 열었던 파일을 닫습니다.
- **read**: 파일에서 정보를 읽어옵니다.
- **write**: 파일에 정보를 씁니다.
- **lseek**: 파일 내에서 특정 바이트 위치로 이동합니다. 예를 들어, 파일의 특정 부분으로 커서를 옮기고 싶을 때 사용
- **unlink** / **remove**: 파일을 삭제합니다.
- **fcntl**: 파일과 관련된 속성을 제어합니다. 예를 들어, 파일 잠금을 설정하거나 파일 모드를 변경할 때 사용됩니다.
#### 특징
POSIX으로 국제 표준이다 (ANSI C로 미국 표준 X)
unix primitives는 unbuffered I/O로 데이터가 중간 버퍼에 저장되지 않고 바로 읽거나 쓰는 작업을 수행한다.
**open, read, write, lseek, close** 함수들이 unbuffered I/O를 제공하며, 이 함수들은 파일 디스크립터(file descriptors)와 함께 동작한다.
# File Descriptor
커널에서 열려 있는 파일을 식별하기 위해 사용됨.
파일을 다루는 데 필요한 고유한 식별자.
#### 특징
- 항상 양수인 값이며 사용되지 않는 가장 작은 정수 값이 할당된다.
- 파일을 열거나 새 파일을 생성하면, 커널은 프로세스에 파일 디스크립터를 반환한다.
- file descriptor는 read 또는 write 함수에 대한 인자로 사용된다.
- Unix Shell에서 프로세스가 생성될 때 기본적으로 세 개의 열린 파일(예: 표준 입력, 표준 출력, 표준 오류)이 터미널과 연결된 상태로 시작된다.
![[Pasted image 20240909173143.png]]
ex) 
read(0, \_, \_) => 키보드에서 읽음
write(1, \_, \_) => 화면에 출력

### File Descriptor example
![[Pasted image 20240909173806.png|350]]
![[Pasted image 20240909174310.png|100]]
int fd => 파일 디스크립터를 저장하는 변수로, 파일을 열 때 반환되는 고유한 정수 값이 저장됨
ssize_t nread => 읽어들인 바이트 수를 저장하는 변수, ssize_t는 시스템에 따라 크기가 달라질 수 있는 데이터 타입 (`<sys/types.h>`)
buf => 파일에서 읽은 데이터를 저장할 버퍼

##### `fd = open("data", O_RDONLY);` 
"data"라는 파일을 읽기 전용으로 연다. 이 함수는 파일이 성공적으로 열리면 파일 디스크립터를 반환한다.
##### `nread = read(fd, buf, 1024);`
파일에서 최대 1024 바이트를 읽어서 버퍼(`buf`)에 저장합니다. `read` 함수는 실제로 읽은 바이트 수를 반환하며, 이는 `nread`에 저장된다.
#### 기본 시스템 데이터 타입
- `_t`로 끝나는 데이터 타입: 예제에 등장한 `ssize_t`처럼 `_t`로 끝나는 데이터 타입들은 시스템이 제공하는 기본적인 데이터 타입을 의미. 이 타입들은 시스템의 특성에 따라 필요한 대로 정의되며, 프로그래머가 직접 정수(`int`)나 실수(`float`)와 같은 구체적인 데이터 타입을 사용하는 것을 피하게 한다.
- 헤더 파일 `sys/types.h`: 이러한 기본 시스템 데이터 타입들은 `sys/types.h`라는 헤더 파일에 정의되어 있으며, 이 헤더 파일은 `unistd.h`와 같은 파일에 포함되어 있어야 합니다.
# `open(2)` system call
번호의 의미 1: command 2: system call 3: library
파일을 열거나 생성한다.
```c
#include <fcntl.h>
int open(const char *pathname, int flags, [mode_t mode]);
// Returns: file descriptor if OK, -1 on error
```
\[mode_t mode]는 옵션이라는 뜻이다.
### flag options
• `O_RDONLY` #0 읽기 전용 (Read Only)
• `O_WRONLY` #1 쓰기 전용 (writing only)
• `O_RDWR` #2 읽기 및 쓰기 전용 (read and write)
• `O_APPEND` 파일의 마지막에 쓰기 (Append to the end of file on each write.)
• `O_CREAT` 존재하지 않으면 파일 생성 (Create the file if it doesn't exist.)
	• `O_EXCL` : `O_CREAT`와 함께 사용되면, 새 파일을 만들려는 시도 중에 그 파일이 이미 존재하는 경우 오류를 발생시킨다.
• `O_TRUNC` 파일이 이미 존재할 경우, 파일의 내용을 모두 지워서 길이를 0으로 만듭니다.
• `O_NONBLOCK` 파일을 열 때 non-blocking mode로 열어, 자원이 사용 중이라도 기다리지 않고 바로 제어를 반환합니다
![[Pasted image 20241008171608.png]]
### mode
`O_CREAT` Flag에서만 사용된다.
File security permission을 위해 사용된다.
![[Pasted image 20240909174947.png]]
### `O_RDWR` flag가 필요한 이유
![[Pasted image 20240909175506.png]]
`O_RDONLY`와 `O_WRONLY`를 단순히 조합해서는 `O_RDWR`를 대체할 수 없다. 
이는 `O_RDONLY`가 0으로 정의되어 있기 때문에 비트 연산을 하면 `O_RDONLY | O_WRONLY`은 `O_WRONLY`와 동일한 값이 된다.

따라서 `O_RDWR`는 읽기/쓰기 모드를 지정하는 고유한 플래그로서 중요한 역할을 한다.
### `open` example
![[Pasted image 20240909180037.png|400]]

# File permissions
![[Pasted image 20240909180143.png]]
# `creat` system call
![[Pasted image 20240910152131.png]]
- 파일을 생성할 때는 주로 `open` 함수를 사용하지만 대체 방법으로서 `creat`함수를 사용할 수도 있다.
- 만약 지정된 경로에 파일이 이미 존재한다면, mode(파일의 권한을 설정)는 무시된다. (이미 존재하는 파일의 권한을 변경하지 않는다.)
### open과 creat의 차이점
- 파일을 항상 쓰기 전용으로 연다. 읽기 전용으로 열 수 없다. (`O_WRONLY`)
- 파일이 이미 존재하는 경우 파일 내용을 모두 지우고 파일 디스크립터를 반환한다. (`O_TRUNC`)
- 존재하지 않으면 파일을 생성한다. (`O_CREAT`)
![[Pasted image 20240910152654.png]]
위 두개는 같다
## `close` system call
```C
#include <unistd.h>
int close(int filedes);
// Returns: 0 if OK, -1 on error
```
열린 파일은 `close`를 통해서만 닫을 수 있음
모든 열린 파일은 프로그램 실행이 끝나면 자동적으로 닫혀야 한다.
![[Pasted image 20240910153114.png]]
## `read` system call
```c
#include <unistd.h>
ssize_t read(int filedes, void *buffer, size_t n);
// Returns: number of bytes read, 0 if end of file, -1 on error
```
**end of file에서 0을 반환하는 것** 주의
filedes에서 n만큼 buffer에 넣고, 읽은 바이트 수를 리턴한다.
파일은 읽으면 f_offset이 알아서 증가한다. (이후 읽을 때 f_offset부터 읽는다.)
![[Pasted image 20240910153224.png]]

## `write(2)` system call
```c
#include <unistd.h>
ssize_t write(int filedes, const void *buffer, size_t n);
// Returns: number of bytes written if OK, -1 on error
```
`buffer`에 있는 값을 n만큼 `filedes`에 쓰고, 쓴 메모리만큼을 리턴한다.
- `write` 함수는 메모리에서 현재 파일 위치로 바이트를 복사하고, 데이터를 쓴 후 파일의 현재 위치를 업데이트한다.
- "현재 파일 위치"는 파일 내에서 다음에 데이터를 쓸 위치를 의미하며, 쓰기 작업이 완료되면 이 위치가 자동으로 이동합니다.
### `write`로 이미 존재하는 파일을 쓰기 전용으로 열면
- 기존 파일에 있던 데이터는 새로운 데이터로 한 글자씩 덮어쓰게 된다. 즉, **파일의 이전 내용이 사라지고 새로운 내용이 저장**된다.

만약 파일을 열 때 `O_APPEND` 옵션을 사용했다면, 쓰기 작업이 시작되는 위치가 파일의 끝으로 자동 설정됩니다.
- 이 옵션을 사용하면 기존 파일의 내용이 지워지지 않고, 새로운 데이터가 파일 끝에 추가된다.

![[Pasted image 20240910153913.png]]

## `read`, `write` 효율성
buffer size를 늘리면 효율이 올라간다 -> system call의 횟수를 줄여 컨텍스트 스위칭을 줄일 수 있기 때문에. (하지만, 디스크에서 4K만큼 I/O가 일어남으로 무조건 커진다고 효율이 올라가지는 않는다.
(4096에서 가장 빠름))
`delayed writing`: `write` system call을 하면 쓰기를 수행한 후 반환되는 것이 아닌, 커널에 버퍼 캐시로 데이터를 전송한 다음 4K씩 반환한다.
그러나, 디스크에 에러가 발생하거나 커널이 멈추면 write했다고 생각한 데이터가 write되지 않았을 수도 있다.
## `lseek` system call
![[Pasted image 20240910155252.png]]
파일을 열 때 해당 파일의 offset (쓰기를 시작할 위치)을 명시적으로 설정할 수 있다.

offset: start_flag로부터의 바이트 수
• start_flag: 시작 위치
	• SEEK_SET #0: 파일의 시작 부분
	• SEEK_CUR #1: 현재 위치
	• SEEK_END #2: 파일의 끝
![[Pasted image 20240910155429.png|200]]

![[Pasted image 20240910155453.png]]
# File Share
### 프로세스 테이블
- 각 프로세스는 프로세스 테이블에 엔트리를 가지고 있다.
- 각 프로세스 테이블 엔트리 내에는 열린 파일 디스크립터의 테이블이 있다.
	- 파일 디스크립터 플래그
	- 파일 테이블 엔트리로의 포인터
### 파일 테이블
- 커널은 모든 열린 파일에 대한 파일 테이블을 유지 관리한다.
- 각 파일 테이블 엔트리는 다음을 포함한다.
	- 파일 상태 플래그 (읽기, 쓰기 등)
	- 현재 파일 offset
	- 파일의 v-node 테이블 엔트리로의 포인터
### v-node 구조체
- 각 열린 파일에는 파일의 타입과 파일에 대해 작동하는 함수에 대한 포인터를 포함하는 v-node 구조체가 있다. (v-node와 i-node와 file은 1대1로 대응됨)

![[Pasted image 20240910160131.png]]
프로그램을 하나 실행하면, Process Table이 생기고 process table은 file descripter를 가지는 process table entry를 가진다. 이 file pointer는 file table을 가져 file status flags, current file offset, v-node pointer를 사지고 v-nodepointer는 v-node와 i-node의 정보를 가진다
![[Pasted image 20240910160145.png]]
각각의 다른 프로세스에서 v-node를 공유할 수 있다. (같은 파일을 열면 파일과 v-node는 1대1대응이므로)
![[Pasted image 20240910160153.png]]
count: file table을 가리키는 fd의 개수
fd 하나당 file table은 하나 만들어짐
v-node는 파일이 디스크 안에 존재하면 계속 있음
## `dup(2)`, `dup2(2)` system call
![[Pasted image 20240910172346.png]]
`dup`, `dup2`는 기존 파일 디스크립터를 복제한다. (duplicate)
성공 시 새로운 파일 디스크립터(사용되지 않는 파일 디스크립터 중 가장 작은 값)를 반환하고, 실패 시 -1을 반환한다.
#### ex) dup
![[Pasted image 20240910222619.png]]
- dup(1)이 표준 출력 파일 디스크립터를 복제하는 예제
- 동일한 작업을 수행하기 위해 `fcntl`함수를 `F_DUPFD`와 함께 사용하는 예제 

![[Pasted image 20240910222632.png]]
file table의 count 값이 2가 된다.
프로세스 테이블에는 파일 테이블 항목을 가리키는 파일 디스크립터가 있고, 파일 테이블 항목은 v-노드 테이블 항목을 가리킨다.

#### ex) dup2
![[Pasted image 20240910222029.png]]
- “test”라는 파일을 읽기 전용 모드로 열고, 파일 디스크립터 4를 fd4에 할당. 
- dup2를 사용하여 파일 디스크립터 3을 fd4에 복제합니다. 
- **dup2는 fd4를 복제했던 파일 디스크립터를 닫는 것까지 포함한다**. 
- 동등한 함수 호출인 close(fd4)와 fcntl도 비교를 위해 나와 있다.

![[Pasted image 20240910222934.png]]
그림은 dup2 호출 전후의 프로세스 테이블 항목을 묘사한다:

• dup2 호출 전: fd4는 “test” 파일에 대한 파일 테이블 항목을 가리킵니다.
• dup2 호출 후: 원래 fd4 항목이 닫히고, fd4는 이제 fd3의 파일 테이블 항목을 복제합니다.

## `fcntl(2)` system call
이미 열려 있는 파일의 속성을 변경하는 함수 (file control)
![[Pasted image 20240910223732.png]]

• `cmd`: 프로그래머가 특정 기능을 선택하기 위해 정수 cmd 인자에 값을 설정함
• `F_DUPFD`: 기존 디스크립터 복제
• `F_GETFD`. `F_SETFD`: 파일 디스크립터 플래그 가져오기/설정하기
• `F_GETFL` , `F_SETFL`: 파일 상태 플래그 가져오기/설정하기
• `F_GETOWN` , `F_SETOWN`: 비동기 입출력 소유권 가져오기/설정하기
• `F_GETLK`, `F_SETLK` , `F_SETLKW`: 레코드 잠금 가져오기/설정하기

![[Pasted image 20240910223852.png]]
![[Pasted image 20240910223902.png|300]]
`O_ACCMODE`와 &연산을 해야 원하는 status flags를 뽑아낼 수 있는 뒤 부분을 알 수 있다.
O_ACCMODE는 read/write에 관한 정보만 알 수 있다.
## Standard input, Standard output, Standard error
![[Pasted image 20240925200123.png|400]]
자연스럽게 standard input과 standard output으로 read write를 해준다.

![[Pasted image 20240925200139.png|400]]
keyboard input을 infile로 redirection 해주는 것
여기서 오른쪽 infile은 fd다
이 때 dup2덕분에 자연스럽게 `read(0,buffer,n)`을 사용해도 infile로 read된다.

![[Pasted image 20240925200149.png|400]]
자연스럽게 standard output으로 read를 해준다.

![[Pasted image 20240925200205.png|400]]
standard output을 outfile로 redirection 해주는 것
여기서 오른쪽 outfile은 fd다
이 때 dup2덕분에 자연스럽게 `write(1,buffer,n)`을 사용해도 outfile로 write된다.

![[Pasted image 20241008184607.png]]
이렇게 하면 in과 out을 동시에 할 수 있다.
## `io`
![[Pasted image 20240925200955.png|450]]
Ctrl-D: EOF 역할을 한다.

# 표준 I/O Library
system call인 UNIX I/O는 직접 사용하기에 좋지 않기에 Standard I/O를 사용한다.
- 자동 버퍼
- 개발자 친화적 인터페이스
- 효율성에 대한 걱정을 해결함 
## `fopen(3)`
![[Pasted image 20240925202958.png|450]]
![[Pasted image 20240925203113.png|300]]
리턴 값이 파일의 포인터, pathname과 type이 문자로 들어간다.
실패시 null이 리턴된다.
## getc(3), putc(3)
![[Pasted image 20241008185516.png|500]]
## Buffering
![[Pasted image 20240925203408.png|300]]
system call을 되도록 적게 사용하기 위해서 buffering mechanism을 사용한다.

## Writing error message with `fprintf(3)`
![[Pasted image 20241008185534.png]]
restrict: fp와 format이 서로 같은 메모리 공간을 사용하면 안된다는 의미
## Error Handling
system call에서 -1이 발생하면 어떤 이유로 실패했는지를 모르게 된다.
그래서 errno에 실패한 원인에 대한 정보를 저장해두게 된다.
근데 errno는 전역변수이기 때문에 즉시 에러를 확인하지 않으면 overwrite되어 확인하기 어렵다.
errno는 새로운 시스템 콜이 만들어져도 리셋되지 않는다. (overwrite되지 않았다면)
![[Pasted image 20240925204638.png|400]]
`strerror`: errnum 값을 주면, 에러 메시지를 문자열로 말해주는 함수
`perror`: 자신의 실행 값 이름과 에러 명을 출력한다.
a.out arg1 arg2 이렇게 실행하면 main 함수에는 a.out이 argv\[0], arg1이 argv\[1], arg2가 argv\[2]가 된다.
![[Pasted image 20240925210045.png|450]]






# CH03 FILE2
## 3.1 멀티유저 환경에서의 파일들 사용자 및 소유권
### 소유자
• UNIX 시스템의 모든 파일은 시스템 사용자가 소유합니다.
• 소유자는 일반적으로 파일을 생성한 사용자입니다.
• 소유자의 실제 신원
	• 사용자 ID (종종 uid로 약칭됨)
	• 특정 사용자 이름과 연결된 uid
![[Pasted image 20241008152311.png|450]]
password는 다른 파일로 옮겨서 x로만 표기됨
• 각 UNIX 프로세스는 **일반적으로 해당 프로세스를 시작한 사용자의 uid와 연결**됩니다.
• 파일이 생성될 때, 시스템은 생성 프로세스의 uid를 참조하여 소유권을 설정합니다.
• 소유권 변경
	• 슈퍼유저 또는 파일의 소유자
	• 슈퍼유저(username=root, uid=0)
![[Pasted image 20241008191519.png]]
process를 실행한 사람의 uid가 프로세스에 기록됨 (프로세스가 shell의 uid를 상속함.)
### 그룹
• 각 사용자는 **적어도 하나 이상의 그룹**에 속해 있습니다.
```shell
$ usermod -G group1,group2 user1 // user modify user1의 그룹을 변경하는 중
$ id // 자신의 정보 출력
uid=509(user1) gid=509(group1) groups=509(group1),510(group2)
```
• `/etc/group`에 정의됨
• 그룹의 실제 신원
	• 그룹 ID (종종 gid로 약칭됨)
	• 특정 그룹 이름과 연결된 gid
• gid와 uid는 사용자가 시작한 프로세스에 의해 상속됩니다.

## 실제 사용자 및 그룹 ID
• 실제 사용자 ID (ruid) - 프로세스를 시작한 사용자의 uid
• 유효 사용자 ID (euid) - 특정 작업을 수행할 프로세스의 권한을 부여하는 데 사용됨
• 대부분의 경우, 유효 사용자 ID와 실제 사용자 ID는 일치합니다
• 유효 사용자 및 그룹 ID는 파일 접근 권한을 결정합니다.
![[Pasted image 20241008194513.png]]
euid를 이용해 /shadow파일을 변경하는 예제
## 권한 및 파일 모드
### 소유권
• 파일에 연결된 권한을 선택할 수 있음
### 권한
• 다른 사용자가 파일에 접근할 수 있는 방법을 결정함
• 슈퍼유저는 읽기, 쓰기 또는 실행 권한과 상관없이 모든 파일을 조작할 수 있음
![[Pasted image 20241008153427.png|300]]
![[Pasted image 20241008153504.png|300]]  
ls시에 owner/group/other로 permission이 나옴
![[Pasted image 20241008153612.png|400]]
이거보다 숫자가 더 편해서 쓸 일은 별로 없을거라 하심..
```shell
S_IRUSER | S_IRGRP | S_IROTH = 0444 = r--r--r--
S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IXGRP | S_IXOTH | S_IXOTH = 0755 = rwx-r-xr-x
```
앞은 무조건 S_I /W/R/X USR/GRP/OTH
## open(2)와 파일 권한
• open을 사용하여 기존 파일을 열면
• 시스템은 파일의 권한을 확인하여 프로세스에서 요청한 접근 모드가 허용되는지 확인합니다.
• 프로세스에 요청된 접근 권한이 없으면 open은 -1(errno=EACCESS)을 반환합니다.
• **파일을 열 때 커널은 유효 사용자 및 그룹 ID를 기반으로 접근 테스트를 수행**합니다.

![[Pasted image 20241008154325.png]]
ruid = usr1
euid = usr1
rgid = grp1
egid = grp1

fd1 성공
fd2 성공
fd3 EACESS (owner의 permission이 없음(뒤를 확인하지 않음))
fd4 성공 
fd4 EACESS
## 파일 접근 테스트
• 커널이 수행하는 테스트는 다음과 같습니다.
	• 프로세스의 유효 사용자 ID가 0 (슈퍼유저)인 경우 접근이 허용됩니다.
	• 프로세스의 유효 사용자 ID가 파일의 소유자 ID와 같은 경우, 적절한 사용자 접근 권한 비트가 설정되어 있으면 접근이 허용됩니다. 그렇지 않으면 접근이 거부됩니다.
	• 프로세스의 유효 그룹 ID가 파일의 그룹 ID와 같은 경우, 적절한 그룹 접근 권한 비트가 설정되어 있으면 접근이 허용됩니다. 그렇지 않으면 접근이 거부됩니다
	• 적절한 다른 접근 권한 비트가 설정되어 있으면 접근이 허용됩니다. 그렇지 않으면 접근이 거부됩니다.

## 실행 파일에 대한 추가 권한
• 파일에 실행 가능한 프로그램이 포함된 경우에만 관련이 있습니다.
![[Pasted image 20241008154918.png|300]]
원래: shell의 uid를 eid로 설정함
• `S_ISUID` 권한이 설정된 경우 file excute하면, 시스템은 생성된 프로세스에 `file owner로부터 가져온 eid를 부여`합니다.
![[Pasted image 20241008155403.png|500]]
`user $ chmod u+s a.out`
a.out에 user에다가 set user id execution을 해준다는 의미이다.
s는 x가 없는 경우에 의미가 없으므로 x를 s로 쓴다 (s가 있으면 x가 있는 것)
그래서 a.out의 euid가 file의 owner인 user2의 euid로 실행된 것.
따라서 a.out의 ruid: 실행한 사람, euid: 권한을 가진 사람

- 스티키 비트 (save-text-image)
잘 사용하지 않아 참고만 하자
• `S_ISVTX` 비트는 실행 파일에 설정할 수 있습니다.
• 초기 시스템에서는 save-text-image 비트가 파일에 설정된 경우, 실행 시 프로그램 텍스트 부분이 시스템이 중단될 때까지 시스템의 스왑 영역에 남아 있었습니다.
• 현대 UNIX 시스템에서는 이 비트가 이제 불필요합니다.
• 현대 시스템에서는 디렉토리에 대해 S_ISVTX 비트를 정의합니다.
## Password 변경 (다른 사람의 권한으로 못여는 파일을 여는 예제)
`/etc/shadow`는 owner의 read만 가능해서 직접 변경이 불가능하다.
![[Pasted image 20241008161806.png|400]]
그러나, usr/bin/passwd는 /etc/shadow를 변경할 수 있다.
![[Pasted image 20241008161801.png|400]]
euid가 0인 이유는 set user id excution이 있으므로 passwd의 euid로 shadow파일을 열었기 때문
![[Pasted image 20241008161922.png|400]]

## 파일 생성 마스크
• 파일 생성 마스크 (보호)
	• 파일이 생성될 때 특정 권한 비트를 자동으로 해제합니다.
	• 지정된 권한이 실수로 켜지는 것을 방지합니다.
![[Pasted image 20241008162002.png|350]]
  위의 명령어로 실행해도 자연스럽게 아래 명령어로 실행됨 (마스크가 어떻게 설정되었느냐만 다를 뿐)
## umask(2) 시스템 호출
```c
#include <sys/stat.h>
mode_t umask(mode_t cmask);
// Returns: previous file mode creation mask

$ umask // umask값 확인
$ umask -S // umask값 확인
$ umask 22 // umask값을 22로 설정
```

• umask 함수는 프로세스의 파일 모드 생성 마스크를 설정합니다.
![[Pasted image 20241008162232.png|500]]
![[Pasted image 20241008162332.png|500]]
## access(2) 시스템 호출
```c
#include <unistd.h>
int access(const char *pathname, int amode);
// Returns: 0 if OK,-1 on error
```
• `access`는 ruid(euid x) 및 그룹 ID를 기반으로 경로명의 접근 권한을 확인합니다.
• 인수
![[Pasted image 20241008202555.png|400]]
![[Pasted image 20241008202707.png|450]]

## chmod(2) 시스템 호출
```c
#include <unistd.h>
int chmod(const char *pathname, mode_t newmode);
// Returns: 0 if OK,-1 on error

// newmode에는 command의 chmod처럼 u+w 이런거는 못들어가고 777이런것만 들어갈 수 있음
```
• 기존 파일의 권한을 변경합니다. (change mode)
• 파일의 소유자(변경하려면 euid가 있어야 함) 또는 슈퍼유저만 가능합니다.
## chown(2) 시스템 호출
```c
#include <unistd.h>
int chown(const char *pathname, uid_t owner_id, gid_t group_id);
// Returns: 0 if OK,-1 on error
```
• 파일의 사용자 ID와 그룹 ID를 변경할 수 있습니다. (change owner)
• 인수
	• owner_id: 새로운 소유자 ID
	• group_id: 새로운 그룹 ID
• owner_id 또는 group_id 중 하나라도 -1인 경우, 해당 ID는 변경되지 않습니다. (안 바꾸고 싶으면 바꾸고 싶지 않은 것에 -1을 넣는다)
• 다른 owner의 파일 소유권을 변경하려는 시도 시 항상 **EPERM** 오류가 반환됩니다.
• **파일의 소유권이 변경되면 해당 파일의 set-user-id 및 set-group-id 권한이 해제**됩니다.
- 해제되지 않는다면, chown으로 다른 owner로 변경 후 그 파일을 이용해서 set-user-id로 owner가 볼 수 있는 모든 권한을 가져갈 수 있기 때문이다.

## 3.2 여러 이름을 가진 파일
파일 시스템
• 파일 시스템은 파일 및 폴더의 명명 규칙을 지정합니다.
### Mount-on
• 디렉토리는 마운트된 파일 시스템에 의해 덮여집니다.
• 마운트 테이블 및 vfs 목록
![[Pasted image 20241008204230.png|350]]
이렇게 다른 디렉토리에 루트를 다는 행위를 mount라 한다.
## UNIX 파일 시스템
• 파일에 대한 링크 개념을 이해하려면 UNIX 파일 시스템의 구조에 대한 개념적 이해가 필요합니다.
• 오늘날 여러 UNIX 파일 시스템 구현이 사용되고 있습니다. (UFS, PCFS, HSFS 등)
![[Pasted image 20241014000136.png]]
### 부트 블록 (unix 시작시 실행하는 정보를 담음)
• UNIX가 처음 활성화될 때 사용되는 부트 코드
### 슈퍼 블록 (파일 시스템의 정보를 담음)
• 파일 시스템의 총 블록 수
• inode 자유 목록에 있는 inode 수
• 자유 블록의 비트 맵
• 블록 크기(바이트 단위) - 보통 4K
• free block 수
• used block 수
### i-노드
• 디스크에 있는 파일과 연관된 모든 inode
• 파일을 고유하게 식별함(1:1로 매핑되어 있음)
- file에 대한 정보를 가지고 있음
### 데이터 블록
• 파일 블록을 저장하기 위한 블록
## i-노드
• 각 파일(일반 파일, 디렉토리, 특수 파일 등)은 하나의 i-노드를 사용하며 적어도 하나의 디렉토리에서 링크되어야 합니다.
• 디스크에 데이터를 가진 파일(일반 파일, 디렉토리, 심볼릭 링크)도 i-노드에서 가리키는 데이터 블록을 가집니다
• i-노드 0과 1은 사용되지 않습니다.
	• 0: “no i-node”를 의미
	• 1: 나쁜 디스크 블록(에러나는 애들)을 모으는 데 사용됨
• i-노드 2는 루트 디렉토리(/)에 예약되어 있습니다.
## 하드 링크 & 심볼 링크
### 하드 링크
• 하드 링크는 파일에 대한 직접 포인터입니다.
• 링크 수는 i-노드를 가리키는 디렉토리 항목 수입니다.
• 링크 수가 0이 되어야 파일이 삭제된 것으로 간주한다.
• 이러한 유형의 링크를 하드 링크라고 합니다.
• 파일 시스템을 넘나들 수 없습니다. (마운트 한 파일시스템에는 하드 링크를 할 수 없다.)
• 디렉토리에 하드 링크를 생성할 수 있는 유일한 사용자는 슈퍼유저입니다.
![[Pasted image 20241008204841.png|500]]
두 파일(name1, name2)이 같은 inode에 hard link를 추가하게 되면 inode의 count는 2가 된다.
### 심볼 링크
ex) 윈도우의 바로가기 파일
• 심볼릭 링크는 파일에 대한 간접 포인터입니다.
• 심볼 링크의 실제 내용은 링크된 파일입니다.
• 파일 시스템 제한이 없습니다.
• 하드 링크와 심볼 링크에서 하드 링크가 생성됩니다.
• 하지만, 심볼 링크에 의해 생성된 하드 링크는 경로 문자열을 포함하는 파일에 대한 링크입니다.
![[Pasted image 20241008205609.png|500]]
첫 번째가 original 두 번째가 symbolic link이다.
symbolic link가 가리키는 inode의 block은 original의 path name를 가지고 있다. 그래서 그 path name으로 original을 찾아간다.
앞의 l은 symbolic link라는 뜻 그리고 name2 -> dirA/name1라고 dirA/name1을 가리키고 있다는 것을 볼 수 있음
## link(2) 시스템 호출
```c
#include <unistd.h>
int link(const char *orginal_path, const char *new_path);
// Returns: 0 if OK, -1 on error
```
• 새로운 디렉토리 항목을 생성하고 링크 수를 증가시킵니다. (하드 링크)
• 디렉토리에 하드 링크 생성은 슈퍼유저에게만 제한됩니다. (파일 시스템 루프 방지)
• 두 경로명이 동일한 파일 시스템에 있어야 합니다.
## unlink(2) 시스템 호출
```c
#include <unistd.h>
int unlink(const char *pathname);
// Return 0 if OK, -1 on error
```
![[Pasted image 20241008233653.png|250]]
• 기존 디렉토리 항목을 제거합니다.
• **이름이 지정된 링크만 제거**하고 파일의 링크 수를 하나 줄입니다. 
• 파일에 다른 링크가 있는 경우, 다른 링크를 통해 파일의 데이터에 여전히 접근할 수 있습니다.
• 링크 수가 0으로 줄어들면 디스크 블록이 자유 블록 목록에 추가됩니다.
unlink하려면 write permission이 있어야 하고 directory에 대해 read permission이 있어야 한다.
![[Pasted image 20241008233945.png|450]]
## remove(2) 시스템 
```c
#include <stdio.h>
int remove(const char *pathname);
// Returns: 0 if OK, -1 on error
```
• 파일의 경우, remove는 unlink와 동일합니다.
## rename(2) system call
```c
#include <stdio.h>
int rename(const char *oldname, const char *newname);
// Returns: 0 if OK, -1 on error
```
• 파일이나 디렉토리는 rename 함수를 사용하여 이름이 변경됩니다.
• **인수**
• oldname과 newname이 동일한 파일을 참조하는 경우, 함수는 아무 것도 변경하지 않고 성공적으로 반환됩니다.
## symlink(2) 시스템 호출
```c
#include <unistd.h>
int symlink(const char *realname, const char *symname);
// Returns: 0 if OK, -1 on error
```
• 심볼릭 링크 파일이 open으로 열리면, open 시스템 호출은 경로를 따라 realname을 정확하게 찾습니다. (symbolic link file을 open하면 symbolic link file이 아닌, 참조하고 있는 file을 보여준다.)
• 프로그래머가 symname 자체에 저장된 데이터를 보려면 readlink 시스템 호출을 사용해야 합니다.

## readlink(2) 시스템 호출
```c
#include <unistd.h>
ssize_t readlink(const char* sympath, char* buffer, size_t bufsize)
// Returns: number of bytes read if OK, -1 on error
```
1. sympath를 엽니다.
2. 파일의 내용을 버퍼로 읽어들입니다.
3. sympath를 닫습니다.

• 원본 파일이 제거된 경우,
	• 프로그램은 여전히 심볼릭 링크를 ‘볼’ 수 있지만, open 호출은 그 안에 포함된 경로를 따라갈 수 없으며 errno가 EEXIST로 설정된 상태로 반환됩니다.
# 파일 정보 얻기: stat과 fstat
## stat(2) 시스템 호출
```c
#include <sys/stat.h>
int stat(const char *pathname, struct stat *buf);
int fstat(int filedes, struct stat *buf);
int lstat(const char *pathname, struct stat *buf);
// All three return: 0 if OK, -1 on error
```
• 이 함수들은 파일에 대한 정보를 얻습니다. (status)
	• **stat**: 지정된 파일 (심볼릭 링크 파일에 stat을 쓰면 심볼릭 링크가 참조하고 있는 파일의 i-node 정보가 나옴, 따라서 심볼릭 링크는 lstat을 써야함)
	• **fstat**: 열린 파일
	• **lstat**: 심볼릭 링크(l이 symbolic link를 나타냄)

```c
struct stat {
	mode_t st_mode; /* file type(directory of socket or fifo...) & mode (permissions) */
	ino_t st_ino; /* i-node number */ 
	dev_t st_dev; /* device number (file system) */ // file system에서 저장하는 device 파일
	dev_t st_rdev; /* device number for special files device number */ // real device 
	nlink_t st_nlink; /* 링크 count */
	uid_t st_uid; /* user ID of owner */
	gid_t st_gid; /* group ID of owner */
	off_t st_size; /* size in bytes, for regular files */
	time_t st_atime; /* time of last access */
	time_t st_mtime; /* time of last modification */
	time_t st_ctime; /* time of last file status change */
	blksize_t st_blksize; /* best I/O block size */
	blkcnt_t st_blocks; /* number of disk blocks allocated */
};
```

파일의 permission 정보를 출력하는 함수
![[Pasted image 20241008235637.png|550]]
![[Pasted image 20241008235704.png|550]]
![[Pasted image 20241008235719.png|550]]
![[Pasted image 20241008235735.png|550]]
마지막 `if (stat(name, &sb) == ―1 || sb.st_mtime ! = last)`에서 왼쪽이 true면 오른쪽을 실행하지 않는다.
![[Pasted image 20241008235754.png|550]]
변경하고 저장하지 않아도 되나봄
 

# CH04 DIRECTORIES
### 디렉토리
- 디렉토리 항목을 포함하는 파일.
- 파일에 사용되는 많은 시스템 호출이 디렉토리를 조작하는 데 사용할 수 있습니다.
- 디렉토리와 일반 파일의 차이점:
  - 디렉토리는 open 시스템 호출을 사용하여 생성할 수 없습니다.
  - O_WRONLY 또는 O_RDWR 플래그가 설정된 상태에서 디렉토리를 열려고 하면 (errno=EISDIR) 오류가 발생합니다.
  - 디렉토리를 write를 사용하여 업데이트하는 것은 불가능합니다.
  - 오직 커널만이 디렉토리에 쓸 수 있습니다.
- 디렉토리는 포함된 각 파일이나 하위 디렉토리에 대해 하나의 디렉토리 항목으로 구성됩니다.
- 디렉토리 항목은 다음으로 구성됩니다:
  - i-노드 번호
  - 문자 필드
![[Pasted image 20241009165646.png|300]]
### 링크 및 언링크
- 각 링크는 원본과 동일한 i-노드 번호를 가진 새로운 디렉토리 슬롯과 새 이름을 생성합니다.
- unlink 시스템 호출을 사용하여 링크를 제거할 때:
  - 해당 파일명에 대한 마지막 링크를 나타내는 경우, 전체 i-노드 구조가 지워집니다.
### 닷과 더블닷
- `.` : 현재 작업 디렉토리
- `..` : 부모 디렉토리
![[Pasted image 20241009165226.png|400]]
### ex)
![[Pasted image 20241009165747.png|450]]
![[Pasted image 20241009170053.png|450]]
## 디렉토리 권한
- 디렉토리 권한은 일반 파일 권한과 정확히 동일한 방식으로 구성됩니다.
- 하지만, 해석 방식이 다릅니다.
  - **읽기 권한**: 파일이나 하위 디렉토리의 이름 목록을 볼 수 있습니다.
  - **쓰기 권한**: 새로운 파일을 생성하거나 기존 파일을 제거할 수 있습니다.
  - **실행 권한(검색 권한)**: 디렉토리로 이동하거나 프로그램 내에서 chdir 시스템 호출을 사용할 수 있습니다.
- 예를 들어, 파일 `/usr/include/stdio.h`를 열려면:
  - `/`, `/usr`, `/usr/include`에 대해 실행 권한이 필요합니다.
- 디렉토리에 대한 읽기 권한과 실행 권한은 다른 의미를 가집니다.
  - **읽기 권한**: 디렉토리 내의 모든 파일명을 얻습니다.
  - **실행 권한**: 디렉토리를 통과하여 특정 파일명을 검색할 수 있습니다. (search permission으로 생각하자)
- 따라서 디렉토리에 대한 실행 권한 비트는 종종 검색 비트라고도 합니다.
- 저장-텍스트-이미지(sticky bit) - S_ISVTX
  - 이 비트가 디렉토리에 설정된 경우: **owner여야 한다.**
    - 다음 중 하나를 만족해야만 디렉토리에 대한 쓰기 권한으로 파일을 제거하거나 이름을 변경할 수 있습니다:
      - 파일의 owner
      - 디렉토리의 owner
      - 슈퍼유저
  - 사용자들은 다른 사람들이 소유한 파일을 삭제하거나 이름을 변경할 수 없습니다.

#### sgt 표기 위치
![[Pasted image 20241009171348.png]]
# 4.4 디렉토리 프로그래밍
## dirent 구조체
```c
#include <dirent.h>
struct dirent {
	ino_t d_ino; /* i-node number */
	char d_name[NAME_MAX + 1]; /* null-terminated filename */
}
```
- d_inode의 값이 0인 것은 디렉토리에서 빈 슬롯을 나타냅니다.
## mkdir(2) 시스템 호출
```c
#include <sys/stat.h>
int mkdir(const char *pathname, mode_t mode);
// Returns: 0 if OK, -1 on error
```
- 권한은 프로세스의 umask 값에 의해 수정됩니다.
- mkdir은 새로 생성된 디렉토리에 두 개의 링크 `.`와 `..`를 추가한다는 점입니다.
- 일반 파일처럼 읽기 및 쓰기 권한만 지정하는 실수를 저지르는 경우가 많다 . 
	- 하지만 디렉토리의 경우, 디렉토리 내 파일명에 접근할 수 있도록 적어도 하나의 excute bit가 활성화되어야 한다.
![[Pasted image 20241009171718.png]]
excute permission이 없으면 cat을 통해 파일 안의 특정 파일명을 검색할 수 없다.
read permission이 없으면 ls를 통해 디렉토리 내의 모든 파일명을 얻을 수 없다
## rmdir(2) 시스템 호출
```c
#include <unistd.h>
int rmdir(const char *pathname);
// Returns: 0 if OK, -1 on error
```
- 빈 디렉토리는 rmdir 함수로 삭제됩니다. (비지 않으면 삭제 못함)
- 빈 디렉토리는 `.`와 `..` 항목만 포함하는 디렉토리입니다.
## opendir(3)
```c
#include <dirent.h>
DIR *opendir(const char *dirname);
// Returns: pointer if OK, NULL on error
```
- DIR은 표준 I/O 라이브러리에서 사용되는 FILE 타입과 유사한 방식으로 작동합니다.
- 항상 null 포인터를 테스트하는 적절한 오류 검사 코드를 작성해야 합니다.
- 프로그램이 디렉토리 접근을 마치면 닫아야 합니다. 이것은 closedir 함수로 달성할 수 있습니다.
## closedir(3)
```c
#include <dirent.h>
int closedir(DIR *dirptr);
// Returns: 0 if OK, -1 on error
```
- closedir 함수는 인수로 주어진 dirptr이 가리키는 디렉토리 스트림을 닫습니다.
![[Pasted image 20241009172204.png|450]]
## readdir(3)
```c 
#include <dirent.h>
struct dirent *readdir(DIR *dp);
// Returns: pointer if OK, NULL at end of directory or error
```
- 첫 번째 readdir에서 첫 번째 디렉토리 항목이 struct dirent로 읽힙니다. (directory entry)
- **완료 시 디렉토리 포인터는 디렉토리의 다음 항목으로 이동**합니다.
## rewinddir(3)
```c
#include <dirent.h>
void rewinddir(DIR *dp);
// Returns: 0 if OK, -1 on error
```
- rewinddir 호출 후, 다음 readdir은 dp가 가리키는 디렉토리의 첫 번째 항목을 반환합니다.
![[Pasted image 20241009172812.png|500]]

dirname 아래 파일에서 주어진 접미사로 끝나는 첫 번째 파일을 찾는 함수
첫 번째 검색 find_entry(\_,suffix,0)
두 번째 이후 검색 find_entry(\_,suffix,1)
![[Pasted image 20241009173221.png|500]]
![[Pasted image 20241009173234.png|500]]

## 현재 작업 디렉토리
- 각 UNIX 프로세스는 고유한 현재 작업 디렉토리를 가집니다.
- 사용자와 관련된 현재 디렉토리는 실제로 그의 명령을 해석하는 셸 프로세스와 관련된 현재 작업 디렉토리입니다.
- 처음에는 프로세스의 현재 작업 디렉토리가 프로세스를 시작한 프로세스의 현재 작업 디렉토리로 설정됩니다. 이는 보통 셸입니다.

## chdir(2) 시스템 호출
```c
#include <unistd.h>
int chdir(const char *path);
// Return: 0 if OK, -1 on error
```
- 이 변경은 chdir을 호출하는 프로세스에만 적용됩니다. (command cd)
- **오류**
	  - 경로가 유효한 디렉토리를 정의하지 않습니다.
	  - 모든 구성 요소 디렉토리에 실행 권한이 없습니다.
- **디렉토리를 변경하고 이 새 디렉토리에 상대적인 파일명을 사용하는 것이 절대 파일명을 사용하는 것보다 더 효율적**입니다.
![[Pasted image 20241009181709.png]]
## getcwd(3)
```c
#include <unistd.h>
char *getcwd(char *name, size_t size);
// Returns: name if OK, NULL on error
```
- 현재 디렉토리 경로명을 가리키는 포인터를 반환합니다.
- 현재 디렉토리 이름이 name이 가리키는 배열에 복사됩니다.
![[Pasted image 20241009182051.png|400]]
# 4.5 UNIX 파일 시스템
## 캐싱, sync 및 fsync
- 메모리에서 디스크로의 모든 전송(즉, 쓰기)은 즉시 디스크에 기록되지 않고 일반적으로 운영 체제의 데이터 공간에 캐시됩니다.
- 읽기도 캐시 내에서 버퍼링됩니다.
- UNIX는 버퍼의 데이터를 디스크에 쓰기 위한 두 가지 함수를 제공합니다.
  - **sync**: 파일 시스템에 대한 정보를 포함하는 메인 메모리 버퍼를 디스크에 플러시하는 데 사용됩니다.
  - **fsync**: 특정 파일과 관련된 모든 데이터와 속성을 플러시하는 데 호출됩니다.
## sync(2) & fsync(2) 시스템 호출
```c
#include <unistd.h>
int fsync(int filedes);
//Returns: 0 if OK, -1 on error
void sync(void);
```
- **중요한 차이점**:
  - fsync는 모든 파일 데이터가 디스크에 기록될 때까지 반환하지 않습니다.
  - sync 호출은 데이터 쓰기가 예약되었지만 완료되지 않았을 때 반환할 수 있습니다.
- UNIX 시스템은 sync를 반복적으로 호출하는 코드를 지속적으로 실행합니다.
- # 4.6 UNIX 장치 파일
## UNIX 장치
- UNIX에서 장치는 할당된 장치 번호로 접근됩니다.
  - 장치 번호는 **주 번호**와 **부 번호**로 구성됩니다.
	  - **주 번호**: 장치 유형 (장치 드라이버)
	  - **부 번호**: 특정 장치의 인스턴스
- 사용자는 특정 장치에 접근하기 위해 장치 번호를 사용하고 싶어하지 않습니다.
  - UNIX는 장치 번호를 장치 파일에 매핑합니다.
## 장치 파일:
- 따라서 장치 파일의 i-노드에는 장치 번호가 포함됩니다 (inode->i_rdev).
- 주변 장치에 대한 간단한 인터페이스를 제공합니다.
- 파일 시스템에 나타납니다.
- 사용자는 표준 시스템 호출을 사용하여 장치에 접근하고 이를 일반 컴퓨터 파일처럼 취급합니다.
- 슈퍼유저만이 장치 파일을 생성할 수 있습니다.
## UNIX 장치 파일
- 주변 장치는 파일 시스템의 파일 이름을 통해 접근됩니다.
  - 디스크, 터미널, 프린터, 테이프 유닛 등
- 일반 디스크 파일과 달리, 이들 장치 파일에 대한 읽기와 쓰기는 시스템과 해당 주변 장치 간에 데이터를 직접 전송합니다.
- 이러한 특수 파일은 /dev 디렉토리에 저장됩니다.
- 장치 파일은 명령 레벨이나 프로그램 내에서 일반 파일처럼 사용할 수 있습니다.
![[Pasted image 20241009183554.png|450]]
tty00 -> terminal의 device file
## 블록 및 문자 장치 파일
- **블록 장치 파일**:
	  - 디스크, 자기 테이프, 블록 단위로 전송, 랜덤 접근
	  - 파일 시스템은 블록 장치에서만 존재할 수 있으며, 이러한 블록 장치에는 종종 raw 장치로 알려진 연관된 문자 장치가 있습니다 (mkfs, fsck).
- **문자 장치 파일**:
	  - 터미널, 모뎀, 프린터, 랜덤 접근 (할 수도 있고 아닐 수도 있음)
## stat 구조체 재방문
- **st_mode**: 해당 파일명을 포함하는 파일 시스템의  장치 번호 및 해당 i-node를 나타냅니다.
![[Pasted image 20241009184016.png|500]]
![[Pasted image 20241009184243.png|500]]
- **st_rdev**: 문자 특수 파일과 블록 특수 파일만 st_rdev 값을 가집니다.
  - 대부분의 구현에서는 major와 minor 매크로가 정의되어 있습니다. (<sys/types.h>)
![[Pasted image 20241009184329.png|500]]
# CH05 PROCESS1
# mainFunction
• 메인 함수의 프로토타입
```c
int main(int argc, char *argv[]);
```
• 인수
	• argc는 명령줄 인수의 수입니다.
	• argv는 인수에 대한 포인터 배열입니다.
• C 프로그램이 exec 함수 중 하나에 의해 커널에 의해 실행될 때, 메인 함수가 호출되기 전에 특별한 시작 루틴이 호출됩니다.
![[Pasted image 20241011235503.png|200]]
• 실행 가능한 프로그램 파일은 이 루틴을 프로그램의 시작 주소로 지정합니다.
• 이 시작 루틴은 커널로부터 값을 받아옵니다:
	• 명령줄 인수(argc, argv 세팅)
	• Environment - 실행환경 세팅
## Command-Line Argument
• 프로그램이 실행될 때, exec을 수행하는 프로세스는 새로운 프로그램에 명령줄 인수를 전달할 수 있습니다.
![[Pasted image 20241007124549.png|450]]
![[Pasted image 20241007124140.png|200]]
### 환경 변수 리스트
• 환경 리스트는 문자 포인터의 배열입니다.
• 포인터 배열의 주소는 전역 변수 `environ`에 포함되어 있습니다:

• 특정 환경 변수를 접근하기 위해서는 보통 `environ` 변수를 통해서가 아닌 `getenv`와 `putenv` 함수를 통해서 합니다.
![[Pasted image 20241007125006.png|300]]
• 대부분의 UNIX 시스템은 메인 함수에 세 번째 인수를 제공합니다.
사실 main함수는 envp라는 세번째 인수를 가지고 있다.
![[Pasted image 20241007124947.png]]
# 메모리 레이아웃 C 프로그램
• C 프로그램은 다음으로 구성됩니다:
	• 텍스트(코드) 세그먼트:
		• 실행할 프로그램 명령어(기계 명령어)
	• 초기화된 데이터 세그먼트:
		• 초기화된 global 및 static 변수
		`int maxcount = 99;`
	• 초기화되지 않은 데이터 세그먼트(bss):
		• 초기화되지 않은 global 및 static 변수
		• 이 세그먼트의 데이터는 프로그램이 실행되기 전에 커널에 의해 0 또는 null 포인터로 초기화됩니다.
		`long sum[1000];`
• 스택:
	• 함수에 로컬인 변수를 저장합니다.
	• 함수가 호출되면, 그 함수의 자동 변수들이 스택의 맨 위에 할당됩니다.
	• 함수가 종료되면 그 변수들은 할당 해제됩니다.
• 힙:
	• 동적 메모리는 힙에서 할당됩니다.
• **초기화되지 않은 데이터 세그먼트의 내용은 디스크에 있는 프로그램 파일에 저장되지 않습니다**.
• 프로그램 파일에 저장되어야 하는 프로그램의 유일한 부분은 `텍스트 세그먼트`와 `초기화된 데이터`입니다.
![[Pasted image 20241012001001.png|400]]

![[Pasted image 20241007125455.png|300]]
초기화 해서 첫 번째 것은 data가 200272지만, 두 번째 것은 data가 252밖에 안됨
# 프로세스(1/2)
• 실행 중인 프로그램의 인스턴스입니다.
• 프로세스는 프로그램의 실행에 해당합니다.(프로세스는 매순간 내용이 달라짐)
• 프로그램 ≠ 프로세스

• 프로세스는 다음을 포함합니다:
	• 프로그램 코드
	• 프로그램 변수 내의 데이터 값
	• 하드웨어 레지스터
	• 프로그램 스택 (stack, heap)
• 프로세스는 프로세스 ID(pid)에 의해 식별됩니다.
• 셸은 새로운 프로세스를 생성합니다.
![[Pasted image 20241012003525.png]]
유저가 cat을 실행하여 cat process를 생성하는 예제
pipe를 이용해서 ls에서의 출력 값을 wc에 입력하는 예제
• 프로세스 환경
	• 모든 UNIX 프로세스는 다른 프로세스를 시작할 수 있습니다. (fork, exec...)
	• 이는 파일 시스템의 디렉토리 트리와 비슷한 계층 구조로 UNIX 프로세스 환경을 형성합니다.
	• 프로세스 트리의 **최상위에는 init**이라는 매우 중요한 프로그램의 실행인 단일 제어 프로세스가 있으며, 이는 모든 시스템 및 사용자 프로세스의 궁극적인 조상입니다.
• UNIX는 프로세스 생성 및 조작을 위한 몇 가지 시스템 호출을 제공합니다:
	• fork, exec, wait, exit 등
# getpid(2)와 getppid(2) 시스템 호출
```c
#include <unistd.h>
pid_t getpid(void);
// Returns: the process ID of the calling process
pid_t getppid(void);
// Returns: the parent process ID of the calling process
```
프로세스 ID
	• 모든 프로세스는 고유한 프로세스 ID, 즉 0 이상의 정수를 가집니다.
	• 고유하지만, 프로세스 ID는 재사용됩니다.
## fork(2) system call
```c
#include <unistd.h>
pid_t fork(void);
// Returns: 0 in child, process ID of child in parent, -1 on error
```
호출된 프로세스의 추출된 복제본인 새로운 프로세스를 생성한다.
- 자식 프로세스는 부모 프로세스의 데이터 공간, 힙, 스택의 복사본을 받지만 공유하지는 않음
- 하지만, 텍스트 세그먼트는 공유합니다.
- 어떤 프로세스가 먼저 실행을 시작할지는 커널에서 사용하는 스케줄링 알고리즘에 따라 달라지므로 알 수 없다.
 ![[Pasted image 20241012005342.png|600]]
텍스트 세그먼트를 공유하는 것을 볼 수 있다.

![[Pasted image 20241007130721.png|600]]
자식(B)은 fork()가 실행된 이후 Two를 각각 실행하게 된다.
parent와 child는 똑같은 fork()를 실행하지만, child는 pid를 0으로 반환한다.

**오류 처리 (EAGAIN)**
• 시스템 전체에서 생성할 수 있는 프로세스의 수에 제한이 있을 때 발생하는 오류입니다.
• 개별 사용자가 생성할 수 있는 프로세스 수에 제한이 있을 때도 발생할 수 있습니다.

![[Pasted image 20241007120856.png]]
그냥 child와 parent가 다른 함수를 실행할 수 있다는 예제
## exec family
• exec 패밀리는 새로운 프로그램의 실행을 시작하는 데 사용할 수 있습니다. (자기 자신을 새로운 프로그램을 시작하도록 바꿈)
• 새로운 프로세스가 생성되지 않으므로 프로세스 ID는 변경되지 않습니다.
• exec는 단순히 현재 프로세스의 텍스트, 데이터, 힙, 스택 세그먼트를 디스크에 있는 새로운 프로그램으로 대체합니다.
• execve만이 커널 내의 시스템 호출이다. 나머지 exec family는 library다
```c
#include <unistd.h>
int execl(const char *pathname, const char *arg0,…/*NULL*/ );
int execv(const char *pathname, char *const argv[]);
int execle(const char *pathname, const char *arg0,…/*NULL*/,char *const envp[]);
int execve(const char *pathname, char *const argv[], char *const envp[]);
int execlp(const char *filename, const char *arg0,.../*NULL*/ );
int execvp(const char *filename, char *const argv[]);
// All six return: -1 on error, **no return on success**
```
l / v - e / p 가 뒤에 붙는다.
execve만 system call이다.
l - list 인자들을 리스트처럼 나열하고 마지막은 NULL로 끝남 (`arg0`, `arg1` ...)
v - vector - 인수들이 배열 형태(`argv[]`)로 전달됨
e - environment - 환경변수 배열(`envp[]`)을 함께 전달함
p - path를 뜻하고, 파일의 경로를 직접 명시하지 않고 시스템의 PATH 환경변수를 사용하여 실행파일을 찾는다. - 따라서 filename만 받음
```jsx
$ echo $PATH
PATH=/bin:/usr/bin:/usr/local/bin/:.
```
##### ex)
![[Pasted image 20241012214101.png|550]]
![[Pasted image 20241012214157.png|550]]
- Accessing arguments passed with `exec`
![[Pasted image 20241012214210.png|550]]
## `exec`와 `fork` 사용
![[Pasted image 20241012214416.png|550]]
![[Pasted image 20241012214432.png|550]]
## `decommand` example
![[Pasted image 20241012214514.png|550]]
다음 문자열 인자를 표준 입력 대신 명령으로 처리하라는 의미에서 -c 인자를 쉘 호출 시 사용합니다.
## fork, 파일 및 데이터
•	부모에서 열려 있는 모든 파일은 자식에서도 열려 있습니다.
•	**부모와 자식이 동일한 파일 오프셋을 공유한다**
•	**자식이 표준 출력에 쓸 때 부모의 오프셋이 업데이트된다**
![[Pasted image 20241012215234.png|550]]
printpos -> 현재 파일 디스크립터의 offset을 프린트하는 함수 (print position)

Before fork: 10
Child before read: 10
Child after read: 20
Parent after wait: 20
## 부모 프로세스에서 상속된 속성들
•	실제 사용자 ID, 실제 그룹 ID, 유효 사용자 ID, 유효 그룹 ID
•	보조 그룹 ID
•	프로세스 그룹 ID
•	세션 ID
•	제어 터미널
•	set-user-ID 및 set-group-ID 플래그
•	현재 작업 디렉토리
•	루트 디렉토리
•	파일 모드 생성 마스크
•	신호 마스크 및 처리 방식
•	모든 열린 파일 디스크립터에 대한 close-on-exec 플래그
•	환경
•	연결된 공유 메모리 세그먼트
•	메모리 매핑
•	자원 한계
=> 대부분이 상속된다.
## 부모와 자식의 차이점
•	**fork의 반환 값**
•	프로세스 ID
•	두 프로세스는 다른 부모 프로세스 ID를 가진다.
•	자식의 tms_utime, tms_stime, tms_cutime, tms_cstime 값은 0으로 설정됩니다. (process time은 다름)
•	부모에 의해 설정된 파일 잠금은 자식에게 상속되지 않습니다.
•	자식의 보류 중인 알람은 지워집니다.
•	자식의 보류 중인 신호 세트는 빈 세트로 설정됩니다.
## exec와 열린 파일들
•	**exec도 완전히 새로운 프로그램이 시작될 때 원래 프로그램에서 열려 있던 파일은 그대로 열려 있다**
•	**file offset은 exec 호출에 의해 변경되지 않는다**
•	close-on-exec 플래그(child가 exec을 하면 parent가 open한 file descripter가 자동으로 close됨)가 켜져 있으면(기본값은 꺼져 있음)
![[Pasted image 20241012220334.png|600]]
![[Pasted image 20241012220430.png|600]]
다른 프로그램에서 read가 가능하므로 close on exit 플래그를 on하면 좋다.
## 호출 프로세스에서 상속된 속성들
• 실제 사용자 ID 및 실제 그룹 ID 
• 보조 그룹 ID 
• 프로세스 그룹 ID 
• 세션 ID 
• 제어 터미널 
• 알람 시계까지 남은 시간 => 상속
• 현재 작업 디렉토리 
• 루트 디렉토리 
• 파일 모드 생성 마스크 
• 파일 잠금 => 상속
• 프로세스 신호 마스크 
• 보류 중인 신호 => 상속
• 자원 한계 
• tms_utime, tms_stime, tms_cutime, tms_cstime에 대한 값 => 상속

# CH05 PROCESS2
# exit 시스템 호출로 프로세스 종료

## 프로세스 종료
- 프로세스는 여덟 가지 방법으로 종료될 수 있습니다.
### 정상 종료
  - main 함수에서 반환
  - exit 호출
  - \_exit 또는 \_Exit 호출
### 비정상 종료
  - abort 호출
  - signal 수신
  - 마지막 스레드가 취소 요청에 응답
## exit(3) 시스템 호출
- exit의 인수는 프로세스의 종료 상태를 나타냅니다.
- 관례적으로, 프로세스는 다음을 반환합니다:
  - 정상 종료 시 0
  - 문제가 발생하면 0이 아닌 값
- `_exit`와 `_Exit`는 즉시 커널로 반환됩니다.
- exit는 특정 정리 작업을 수행합니다.
  - 표준 I/O 라이브러리의 깨끗한 종료 (fclose)
- exit(0)은 main()에서 return(0)과 동일합니다.
![[Pasted image 20241012221856.png|150]]
## `atexit(3)`
```c
#include <stdlib.h>
int atexit(void (*func)(void));
// Returns: 0 if OK, nonzero on error
```
- ISO C에서는 프로세스가 exit에 의해 자동으로 호출되는 최대 32개의 함수를 등록할 수 있습니다.
- 이러한 함수들은 exit 핸들러라고 불리며 atexit 함수를 호출하여 등록됩니다.
- exit 함수는 이 함수들을 등록된 역순으로 호출합니다.
- 플랫폼에 의해 지원되는 최대 exit 핸들러 수
![[Pasted image 20241012222342.png|500]]
exit은 하나만 exit해주는 것이 아니라 여러가지를 exit해주고 돌아온다.
`_exit``_Exit`은 cleanup 작업을 안하고 바로 kernel에 exit 작업을 해준다.
![[Pasted image 20241012222602.png|600]]
# 프로세스 동기화

## 자식 프로세스와의 동기화
- 프로세스가 종료되면 (정상적이든 비정상적이든)
  - 커널은 프로세스의 모든 열린 디스크립터를 닫고, 사용 중이던 메모리를 해제합니다.
  - 커널은 종료된 프로세스에 대한 proc entry만 유지합니다 (pid, 종료 상태 - exit(status), CPU 시간).
  - 이 정보는 종료된 프로세스의 부모 프로세스가 확인할 때까지 남아 있습니다.
  - 부모 프로세스는 wait() 시스템 호출을 통해 이 정보를 확인합니다.
  - wait() 후에 종료된 프로세스의 proc entry는 proc 테이블에서 해제됩니다.
## wait(2) 시스템 호출
```c
#include <sys/wait.h>
pid_t wait(int *statloc);
// Return: child process ID if OK, 0 (see later), or -1 on error
```
- wait는 자식 프로세스가 실행되는 동안 프로세스의 실행을 일시 중지합니다.
- 자식이 종료되면 대기 중인 부모 프로세스가 다시 시작됩니다.
- 여러 자식 프로세스가 실행 중인 경우, wait는 부모의 자식 중 하나가 종료되면 반환됩니다.
- wait가 (pid_t) -1을 반환하면, 자식이 없음을 의미할 수 있습니다.
  - errno = ECHILD
- 부모 프로세스는 자식 중 하나가 종료될 때까지 루프에서 기다릴 수 있습니다.
![[Pasted image 20241013160702.png|400]]
child가 여러개면 wait도 여러개
wait(NULL)은 stat값을 받지 않겠다는 의미, -1이 반환될 때까지 wait한다.
![[Pasted image 20241013160933.png|500]]
![[Pasted image 20241013161022.png|500]]
보통 status 정보는 exit을 통해 자식의 exit-status가 된다.
## waitpid(2) 시스템 호출
```c
#include <sys/wait.h>
pid_t waitpid(pid_t pid, int *statloc, int options);
// Return: child process ID if OK, 0 (see later), or -1 on error
```
wait할 pid를 지정하는 system call
- 언급했듯이, 여러 자식이 있는 경우 wait는 자식 중 하나가 종료될 때 반환됩니다.

pid == -1 모든 자식 프로세스를 기다립니다. 이 점에서 waitpid는 wait와 동일합니다.
pid > 0 프로세스 ID가 pid와 동일한 자식을 기다립니다.
pid == 0 호출 프로세스의 프로세스 그룹 ID와 동일한 프로세스 그룹 ID를 가진 모든 자식을 기다립니다.
pid < 0 프로세스 그룹 ID가 pid의 절대값과 동일한 모든 자식을 기다립니다.

`WNOHANG`: pid로 지정된 자식이 즉시 사용 가능하지 않으면 waitpid 함수는 블록하지 않습니다. 이 경우 반환 값은 0입니다. (hang = 매달다 = 기다리다 NOHANG = 기다리지 말라)
![[Pasted image 20241013162935.png|600]]
Still waiting은 4번 print 할 것
## wait(2) & waitpid(2) 함수의 차이점
  - wait 함수는 호출자를 자식 프로세스가 종료될 때까지 블록할 수 있습니다. 반면에 waitpid는 블록을 방지하는 옵션이 있습니다 (`WNOHANG`).
  - waitpid 함수는 종료된 자식을 기다리지 않으며, 어떤 프로세스를 기다릴지 제어하는 여러 옵션이 있습니다.
## 종료 상태 확인 (2/2)
`WIFEXITED(status)`, `WEXITSTATUS(status)`
자식 프로세스가 정상적으로 종료되었을 때 0이 아닌 값을 반환합니다. WIFEXITED가 0이 아닌 값을 반환하면, WEXITSTATUS는 자식 프로세스가 `_exit()`, `exit()` 또는 main 함수에서 반환한 하위 8비트 값을 반환합니다.

`WIFSIGNALED(status)`,`WTERMSIG(status)`,`WCOREDUMP(status)` 
자식 프로세스가 캐치되지 않은 시그널로 인해 종료되었을 때 0이 아닌 값을 반환합니다. WIFSIGNALED가 0이 아닌 값을 반환하면, WTERMSIG는 종료를 유발한 시그널 번호를 반환합니다.

`WIFSTOPPED(status)`, `WSTOPSIG(status)` 
자식 프로세스가 현재 중지된 경우 0이 아닌 값을 반환합니다. WIFSTOPPED가 0이 아닌 값을 반환하면, WSTOPSIG는 자식 프로세스가 중지된 시그널 번호를 반환합니다.

`WIFCONTINUED(status)` 
자식 프로세스가 현재 다시 실행 중인 경우 0이 아닌 값을 반환합니다.
![[Pasted image 20241013164117.png|600]]
# 좀비프로세스와 조기 종료

## 좀비 프로세스 (defunct 프로세스)
- 부모가 종료된 자식에 대해 wait()를 호출하지 않으면 좀비 상태가 됩니다 (ps에서 "Z" 상태로 표시됨).
- 부모가 wait() 또는 waitpid()를 호출할 때까지 좀비는 남아 있습니다.
- 이는 실행을 완료했지만 프로세스 테이블에 항목이 남아 있는 프로세스입니다.
![[Pasted image 20241013164610.png|500]]
![[Pasted image 20241013164619.png|500]]
## 고아 프로세스
- 부모 프로세스가 죽으면 자식 프로세스는 고아 프로세스가 됩니다.
- init 프로세스 (pid = 1)가 고아 프로세스의 부모가 됩니다.
- init 프로세스는 주기적으로 자식에 대해 wait를 실행하므로 결국 고아 좀비는 제거됩니다.
![[Pasted image 20241013164701.png|500]]
![[Pasted image 20241013164721.png|400]]
### 5.9 smallsh: 명령어 프로세서

#### 명령어 프로세서의 기본 로직
```c
while (EOF not typed) // EOF가 입력되지 않는 동안
{
    사용자로부터 명령어를 입력받음
    // fgets() 함수를 사용하여 입력을 받음
    명령어 인수를 조립하고 실행
    // excute_cmdline() 함수를 사용하여 실행
}
```
## ls를 실행하는 step
![[Pasted image 20241014143419.png|500]]
#### Fork Code:
• 자식 프로세스의 프로세스 테이블 항목을 할당합니다.
• 부모 프로세스로부터 자식 프로세스의 항목을 채웁니다.
• 자식 프로세스의 스택과 사용자 영역을 할당합니다.
• 부모로부터 자식의 사용자 영역을 채웁니다.
• 자식 프로세스의 PID를 할당합니다.
• 자식 프로세스가 부모의 텍스트를 공유하도록 설정합니다.
• 데이터와 스택의 페이지 테이블을 복사합니다.
• 열린 파일의 공유 설정을 합니다.
• 부모의 레지스터를 자식에게 복사합니다.
#### Exec code
• 실행할 프로그램을 찾습니다.
• 실행 권한을 확인합니다.
• 헤더를 읽고 확인합니다.
• 인수와 환경을 커널로 복사합니다.
• 이전 주소 공간을 해제합니다.
• 새로운 주소 공간을 할당합니다.
• 인수와 환경을 스택으로 복사합니다.
• 신호를 재설정합니다.
• 레지스터를 초기화합니다.
![[Pasted image 20241014143727.png|500]]
## smallsh - shell example
![[Pasted image 20241014145344.png|550]]

입력을 inputbuf에 넣고, 입력 글자 수가 유효한지 확인하는 함수
![[Pasted image 20241014145408.png|550]]
명령을 tok과 tokbuf로 나눠서 읽는다.
![[Pasted image 20241014145420.png|550]]
나눈 명령을 실행한다.
![[Pasted image 20241014145437.png|550]]
![[Pasted image 20241014145446.png|550]]

## 프로세스 속성

## 프로세스 ID 0 & 1
![[Pasted image 20241014120812.png|500]]
- **스케줄러 프로세스 (swapper)**: 프로세스 ID 0
  - 이 프로세스에 해당하는 디스크의 프로그램이 없습니다.
  - 커널의 일부이며 시스템 프로세스로 알려져 있습니다.
- **init 프로세스**: 프로세스 ID 1
  - 부트스트랩 절차가 끝날 때 커널에 의해 호출됩니다.
  - 이 프로세스의 프로그램 파일은 구 버전 UNIX 시스템에서는 /etc/init였고, 최신 버전에서는 /sbin/init입니다.
  - 이 프로세스는 UNIX 시스템을 시작하는 역할을 합니다.
  - init 프로세스는 죽지 않습니다.
  - 이는 커널 내의 시스템 프로세스가 아닌 일반 사용자 프로세스이며, superuser 권한으로 실행됩니다.
![[Pasted image 20241014120453.png|600]]
![[Pasted image 20241014120509.png|600]]
## 프로세스 그룹과 프로세스 그룹 ID
- 프로세스 그룹은 하나 이상의 프로세스로 구성되며, 일반적으로 동일한 작업과 관련이 있습니다.
	- 프로세스는 파이프로 연결됩니다.
- 각 프로세스 그룹은 고유한 프로세스 그룹 ID를 가집니다.
- 프로세스 그룹 ID는 프로세스 ID와 유사합니다.
	- 양의 정수입니다.
	- pid_t 데이터 유형입니다.
- 각 프로세스 그룹에는 프로세스 그룹 리더가 있을 수 있습니다.
	- (pid == pgid)인 경우 프로세스 그룹 리더입니다.
```c
#include <unistd.h>
pid_t getpgrp(void);
// Returns: process group ID of calling process
pid_t getpgid(pid_t pid);  /* getpgid(0) == getpgrp() */
// Returns: process group ID if OK, -1 on error
```
![[Pasted image 20241014121035.png]]
`$ cmd1 | cmd2`는 cmd1과 cmd2가 같은 프로세스 그룹이 되고, shell은 다른 프로세스 그룹이다.
bash가 cmd1과 cmd2를 만들고 그룹을 분리시킨 것
## 프로세스 그룹 변경
```c
#include <unistd.h>
int setpgid(pid_t pid, pid_t pgid);
// Returns: 0 if OK, -1 on error
```
- 이 함수는 프로세스의 프로세스 ID가 pid와 같은 프로세스의 프로세스 그룹 ID를 pgid로 설정합니다.
	-  pid == pgid: 지정된 프로세스 ID(pid)가 프로세스 그룹 리더가 됩니다.
	- pid == 0: 호출자의 프로세스 ID가 사용됩니다.
	- pgid == 0: 지정된 프로세스 ID(pid)가 프로세스 그룹 ID로 사용됩니다.
- **프로세스는 자신이나 자식의 프로세스 그룹 ID만 설정할 수 있다**
- 또한 자식이 exec 함수 중 하나를 호출한 후에는 자식의 프로세스 그룹 ID를 변경할 수 없습니다.
## 세션 및 세션 ID
- 세션은 하나 이상의 프로세스 그룹의 모음입니다.
- 세션 내의 프로세스 그룹은 하나의 포어그라운드 프로세스 그룹과 하나 이상의 백그라운드 프로세스 그룹으로 나눌 수 있습니다.
![[Pasted image 20241014122130.png|500]]
모든 프로세스는 controlling terminal이 관리한다.

```c
#include <unistd.h>
pid_t getsid(pid_t pid);
// Returns: session leader's process group ID if OK, -1 on error
```
- pid가 0이면, getsid는 호출 프로세스의 세션 리더의 프로세스 그룹 ID를 반환합니다.
- 데몬 프로세스:
  - 제어 터미널이 없는 단순한 프로세스입니다.
  - 예로는 cron이 있습니다.
```c
#include <unistd.h>
pid_t setsid(void);
// Returns: process group ID if OK, -1 on error
```
- 호출 프로세스가 프로세스 그룹 리더가 아니면, 이 함수는 새로운 세션을 만듭니다.
- 세 가지 일이 발생합니다:
  - 프로세스는 이 새로운 세션의 **세션 리더**가 됩니다. (세션 리더는 세션을 만드는 프로세스입니다.)
  - 프로세스는 새로운 프로세스 그룹의 **프로세스 그룹 리더**가 됩니다.
  - 프로세스는 **제어 터미널이 없다**. 프로세스가 setsid를 호출하기 전에 제어 터미널이 있었다면, 그 연결이 끊어진다.
## 현재 작업 디렉토리 및 루트 디렉토리 
### 현재 작업 디렉토리:
  - 현재 작업 디렉토리는 프로세스를 시작한 fork 또는 exec을 통해 상속됩니다.
  - 프로세스별 속성입니다.
  - 자식 프로세스가 `chdir`을 호출하여 위치를 변경하면, 부모 프로세스의 현재 작업 디렉토리는 변경되지 않습니다.
### 현재 루트 디렉토리:
  - 각 프로세스는 절대 경로 이름 검색에 사용되는 루트 디렉토리와도 연결됩니다.
  - 파일 시스템 계층 구조의 시작 지점입니다.
```c
#include <unistd.h>
int chroot(const char *path);
// Return: 0 if OK, -1 on error
```
  - chroot가 성공하면, path는 '/'로 시작하는 파일 검색의 시작 지점이 됩니다.
  - 호출 프로세스에만 영향을 미치며, 시스템 전체에는 영향을 미치지 않습니다.
![[Pasted image 20241014124502.png|500]]
## 사용자 ID 및 그룹 ID 변경
```c
#include <unistd.h>
int setuid(uid_t uid);
int setgid(gid_t gid);
// Both return: 0 if OK, -1 on error
```
- UNIX 시스템에서, 현재 날짜를 변경하는 등의 특권과 특정 파일을 읽거나 쓸 수 있는 접근 제어는 사용자 및 그룹 ID에 기반합니다.
- setuid 함수를 사용하여 real user ID와 effective user ID를 설정할 수 있습니다.
- 마찬가지로, setgid 함수를 사용하여 real group ID와 the effective group ID를 설정할 수 있습니다.
## 파일 크기 제한: ulimit
```c
#include <ulimit.h>
long ulimit(int cmd, [long newlimit]);
// Return: the value of the requested limit if OK, -1 on error
```
- write 시스템 호출로 생성할 수 있는 파일의 크기에는 프로세스별로 제한이 있습니다.
- 현재 파일 크기 제한을 얻으려면:
  - 매개변수 cmd를 UL_GETFSIZE로 설정합니다.
- 파일 크기 제한을 변경하려면:
  - 매개변수 cmd를 UL_SETFSIZE로 설정하고 새로운 제한을 적용합니다.
- 이 방법으로 파일 크기 제한을 실제로 증가시킬 수 있는 것은 슈퍼유저만 가능합니다.
- 다른 사용자의 유효 사용자 ID를 가진 프로세스는 제한을 줄이는 것이 허용됩니다.
## 프로세스 우선순위: nice
- 시스템은 특정 프로세스에 할당되는 CPU 시간의 비율을 부분적으로 정수 nice 값에 기반하여 결정합니다.
- **nice 값 범위**:
  - 0 ~ 시스템에서 우선순위가 가장 높은 값
  - 숫자가 높을수록 프로세스의 우선순위가 낮아집니다.
- 슈퍼유저 프로세스는 nice 호출의 매개변수로 음수 값을 사용하여 우선순위를 높일 수 있습니다.

# CH06 SIGNAL
# Signal Concepts
-  커널에서 일어나는 일
	- 키보드 입력을 담당하는 커널이 인터럽트 문자를 감지한다.
	- SIGINT라는 신호를 모든 프로세스(포어그라운드 그룹)에 보낸다.
	- cc가 이 신호를 받으면, SIGINT와 관련된 기본 동작을 수행하고 종료한다.
- 신호는 소프트웨어 인터럽트이다.
- 신호는 비동기 이벤트를 처리하는 방법을 제공한다.
- 프로세스는 단순히 변수를 테스트하여(예: errno) 신호가 발생했는지 확인할 수 없다.
	-  대신 프로세스는 커널에 “이 신호가 발생하면 다음 작업을 수행하라”고 알려야 한다.

- 모든 신호에는 이름이 있다.
	- 이 이름들은 모두 <signal.h> 헤더에 정의된 양의 정수 상수(신호 번호)로 정의된다.
- 다양한 조건이 신호를 생성할 수 있다.
- 터미널에서 생성된 신호(Control-C -> SIGINT)
- 하드웨어 예외가 신호를 생성한다(0으로 나누기 등).
- kill(2) 함수
- kill(1) 명령어(kill -9 \#pid)
- 소프트웨어 조건(SIGURG, SIGPIPE, SIGALRM 등)

![[Pasted image 20241014130910.png|600]]
• SIGABRT : abort 함수 호출에 의해 생성됨.
• SIGALRM : 설정된 타이머가 만료되면 생성됨.
• SIGCHLD : 프로세스가 종료되거나 멈출 때마다 부모 프로세스에 신호가 보내짐.
• SIGCONT : 멈춘 프로세스가 계속될 때 보내지는 신호.
• SIGFPE : 0으로 나누기, 부동 소수점 오버플로 등 산술 예외를 알림.
• SIGILL : 프로세스가 불법 하드웨어 명령어를 실행했음을 알림.
• SIGINT : 인터럽트 키를 입력할 때 터미널 드라이버에 의해 생성되어 포어그라운드 프로세스 그룹의 모든 프로세스에 보내짐.
• SIGKILL : **잡을 수 없고 무시할 수 없다.** 어떤 프로세스든 확실히 종료시킬 수 있는 방법.
• SIGPIPE : 파이프라인에 쓰기 시도 시 리더가 종료된 경우 생성됨.
• SIGSEGV : 프로세스가 유효하지 않은 메모리 참조를 했음을 알림. (코어 덤프)
• SIGTERM : 기본적으로 kill(1) 명령어에 의해 보내지는 종료 신호.
• SIGTSTP : 터미널 드라이버에서 Cntl-Z가 입력되어 포어그라운드 프로세스 그룹의 모든 프로세스에 보내짐.
• SIGUSR1 : 사용자 정의 신호 1
• SIGUSR2 : 사용자 정의 신호 2
• SIGSTOP : 잡 제어 신호로, **잡을 수 없고 무시할 수 없다.**

signal에 대한 default action이 terminate가 아닌 signal
- SIGSTOP (STOP)
- SIGTSTP (STOP)
- SIGCONT(CONTINUE)
- SIGUSR1 (IGNORE)
- SIGUSR2 (IGNORE)

• 신호는 이벤트의 소프트웨어 알림이다.
• 신호는 해당 신호를 발생시키는 이벤트가 발생하면 생성된다.
• 신호는 프로세스가 해당 신호에 기반하여 작업을 취할 때 전달된다.
• 신호의 수명은 생성과 전달 사이의 간격이다.
• 생성되었지만 아직 전달되지 않은 신호는 보류 중이라고 한다.
• 프로세스가 신호 핸들러를 실행할 때 신호를 Catch했다고 한다.
• 프로그램은 sigaction을 호출하여 사용자 정의 함수 이름으로 신호 핸들러를 설치한다.

시그널은 default action을 하거나, ignore 되거나 catch될 수 있다. 하지만, SIGKILL과 SIGSTOP은 default action만 가능하다.
## 정상 비정상 종료
![[Pasted image 20241014131012.png|600]]
# Signal handling
- 신호가 발생하면 세 가지 작업 중 하나를 수행한다.
	- 무시 동작
		-  하지만 SIGKILL과 SIGSTOP 두 신호는 무시할 수 없다.
	- 사용자 정의 동작 (catch)
		- 이를 위해 신호가 발생할 때마다 커널이 우리의 함수를 호출하도록 지시한다(신호 핸들러).
		- SIGKILL과 SIGSTOP 두 신호는 잡을 수 없음을 유의한다.
	- 기본 동작
		- 모든 신호에는 기본 동작이 있다.
		- 기본 동작은 일반적으로 프로세스를 종료시키는 것이다.
## 신호 처리: 사용자 정의 동작
• 잡힌 신호가 프로세스에 의해 처리될 때, 프로세스가 실행 중인 정상적인 명령어 시퀀스는 신호 핸들러에 의해 일시 중단된다.
• 그런 다음 프로세스는 계속 실행되지만 신호 핸들러의 명령어를 실행한다.
![[Pasted image 20241014134019.png|500]]
신호 핸들러가 반환되면, 신호가 잡혔을 때 프로세스가 실행 중이던 정상적인 명령어 시퀀스가 계속 실행된다.
• 그러나 신호 핸들러 내에서는 신호가 잡혔을 때 프로세스가 어디에서 실행 중이었는지 알 수 없다.
## 프로세스 신호 마스크 – 프로세스 속성
• 신호가 생성될 때 취해지는 동작은 현재 신호 핸들러와 프로세스 신호 마스크에 따라 다르다.
• 신호 마스크는 차단될 신호 목록을 포함한다.
• 프로그램은 sigprocmask를 사용하여 프로세스 신호 마스크를 변경하여 신호를 차단한다.
• 프로세스는 fork와 exec 이후에도 신호 마스크를 상속한다.
// 여기까지
## signal(2) 시스템 호출(1/2)
```c
#include <signal.h>
void (*signal(int signo, void (*func)(int)))(int);
// Returns: previous disposition of signal (see following) if OK, SIG_ERR on error
```

• signal 함수는 ISO C에 정의되어 있으며, 이는 다중 프로세스, 프로세스 그룹, 터미널 I/O 등을 포함하지 않는다.
• signal의 의미가 구현마다 다르기 때문에, sigaction 함수를 사용하는 것이 좋다.
• 이 함수는 구형 의미를 필요로 하는 응용 프로그램에 대한 하위 호환성을 제공한다.
• 새로운 응용 프로그램은 이러한 신뢰할 수 없는 신호를 사용해서는 안 된다.
signal()의 프로토타입은 두 개의 인수를 필요로 하며 아무것도 반환하지 않는 함수( void)를 가리키는 포인터를 반환한다고 명시하고 있다.