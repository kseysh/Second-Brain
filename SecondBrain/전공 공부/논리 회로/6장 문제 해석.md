## 6-2
![[Pasted image 20241126141723.png]]
다음의 부호 있는 10진수를 2의 보수 체계로 나타내십시오. 부호 비트를 포함하여 총 8비트를 사용하십시오.
## 6-3
![[Pasted image 20241126141732.png]]
다음의 각 숫자는 2의 보수 체계에서 부호 있는 10진수를 나타냅니다. 각 경우에 10진 값을 구하십시오. (힌트: 음수를 양수로 변환하려면 부정을 사용하십시오.)
## 6-8
![[Pasted image 20241126141741.png]]
2의 보수 시스템이 컴퓨터 시스템에서 부호 있는 숫자(음수와 양수 모두)를 표현하는 데 있어 부호-크기 시스템보다 더 적절한지 분석하십시오. 다음 사례를 사용하십시오:
## 6-9
![[Pasted image 20241126141749.png]]
다음 연산을 2의 보수 체계에서 수행하십시오. 각 숫자에 대해 부호 비트를 포함하여 8비트를 사용하십시오. 결과를 이진수에서 10진수로 다시 변환하여 확인하십시오.
(g) +15에서 +51을 빼기
(h) -12에서 -12를 빼기
(i) +85에 -85 더하기
(j) -26에서 -26을 빼기
## 6-10
![[Pasted image 20241126141757.png]]
6-10 문제를 반복하고 각 경우에 오버플로가 발생하는지 보여주십시오.
(a) +45에 +89 더하기
(d) +89에서 -45 빼기
## 6-19
![[Pasted image 20241126141809.png]]
6-19.반가산기의 기능표를 작성하십시오 (입력 A와 B; 출력 합(SUM)과 자리올림(CARRY)). 기능표를 바탕으로 반가산기로 작동하는 논리 회로를 설계하십시오.
## 6-21
![[Pasted image 20241126142206.png|500]]
![[Pasted image 20241126141818.png]]
6-21. 그림 6-10을 참조하십시오. 다음 연산 순서 후 A 레지스터의 내용을 구하십시오: 
`[A] = 0000, [0100] -> [B], [S] -> [A], [1011] -> [B], [S] -> [A]`.
## 6-22
![[Pasted image 20241126141933.png]]
6-22. 그림 6-10을 참조하십시오. 각 플립플롭(FF)의 tPLH = tPHL = 50ns이고 설정 시간(setup time)이 15ns이며, 각 풀 애더(FA)의 전파 지연이 65ns일 때, LOAD 펄스의 PGT와 TRANSFER 펄스의 PGT 사이에 정상적인 동작을 위한 최소 시간은 얼마입니까?
## 6-23
![[Pasted image 20241126141944.png]]
![[Pasted image 20241126141954.png]]
6-23. 이 장에서 다룬 덧셈기와 뺄셈기 회로에서는 오버플로우 가능성에 대해 고려하지 않았습니다. 오버플로우는 더하거나 뺀 두 수의 결과가 누산기의 용량을 초과하는 비트 수를 포함할 때 발생합니다. 예를 들어, 부호 비트를 포함한 4비트 레지스터를 사용하면 +7에서 -8까지의 숫자를 저장할 수 있습니다. 따라서 덧셈 또는 뺄셈의 결과가 +7을 초과하거나 -8보다 작으면 오버플로우가 발생했다고 말할 수 있습니다. 오버플로우가 발생하면 결과는 누산기 레지스터에 올바르게 저장할 수 없으므로 유용하지 않습니다. 예를 들어, +5(1010)와 +4(0100)를 더하면 결과는 1001이 됩니다. 이 1001은 부호 비트 위치에 1이 있기 때문에 음수로 잘못 해석될 것입니다. 컴퓨터와 계산기에는 보통 오버플로우 상태를 감지하는 회로가 있습니다. 이를 위한 여러 방법이 있습니다. 2의 보수 시스템에서 동작하는 덧셈기에 사용할 수 있는 방법은 다음과 같습니다:
1. 더하고 있는 두 수의 부호 비트를 확인합니다.
2. 결과의 부호 비트를 확인합니다.
3. 오버플로우는 더하는 두 수가 모두 양수이고 결과의 부호 비트가 1이거나, 두 수가 모두 음수이고 결과의 부호 비트가 0일 때 발생합니다.
이 방법은 여러 예제를 통해 검증할 수 있습니다. 
다음 경우를 시도하십시오: 
(1) 5 + 4;
(2) -4 + (-6); 
(3) 3 + 2. 
Case 1과 2는 오버플로우가 발생하며, 경우 3은 오버플로우가 발생하지 않습니다. 따라서 부호 비트를 확인하여 오버플로우 상태가 발생할 때 1을 출력하는 논리 회로를 설계할 수 있습니다. 그림 6-10에 대한 오버플로우 회로를 설계하십시오.
## 6-25
![[Pasted image 20241126142003.png]]
6-25. 그림 6-10에 대해, A0, B0, C0, A1, B1, A2, B2의 값을 기반으로 MSB 위치의 FA로 전달될 carry C3를 생성하는 look-ahead carry 회로를 설계하십시오. 즉, C3를 A0, B0, C0, A1, B1, A2, B2에 대한 식으로 유도하십시오. (힌트: 먼저 A0, B0, C0에 대한 C1의 식을 작성하십시오. 그런 다음 A1, B1, C1에 대한 C2의 식을 작성하고, C1의 식을 C2의 식에 대입하십시오. 그 후, A2, B2, C2에 대한 C3의 식을 작성하고, C2의 식을 C3의 식에 대입하십시오. 최종적으로 C3의 식을 간단히 하고, 합의 곱 형태(sum-of-products form)로 작성하십시오. 회로를 구현하십시오.)
## 6-26
![[Pasted image 20241126142236.png|500]]
![[Pasted image 20241126142012.png]]
6-26. 그림 6-11(b)의 각 덧셈기에 대해, 3F<sub>16</sub>을 A3<sub>16</sub>에 더할 때 입력 캐리 1을 사용할 때의 논리 레벨을 구하십시오.
## 6-28
![[Pasted image 20241126142307.png|500]]
![[Pasted image 20241126142023.png]]
6-28. 그림 6-14의 회로에 대해, 다음 경우에 대한 합 출력값을 구하십시오.
(a) A 레지스터 = 1010 (-6), B 레지스터 = 0001 (+1); SUB = 1, ADD = 0.
(b) A 레지스터 = 1001 (-7), B 레지스터 = 0110 (+6); SUB = 1, ADD = 0.
(c) A 레지스터 = 1110 (-2), B 레지스터 = 0101 (+5); SUB = 0, ADD = 1.
## 6-30
![[Pasted image 20241126142030.png]]
6-30. 문제 6-28에서 계산한 각 경우에 대해 오버플로우가 발생했는지 여부를 구하십시오.
## 6-33
![[Pasted image 20241126142038.png]]
6-33. 74LS382에 적용된 각 입력 세트에 대해 F, CN+4, OVR 출력을 구하십시오.
(a) [S] = 011, [A] = 0110, [B] = 0011, CN = 0
(b) [S] = 001, [A] = 0110, [B] = 0011, CN = 1
(c) [S] = 010, [A] = 0110, [B] = 0011, CN = 1
## 6-39
![[Pasted image 20241126142047.png]]
6-39. 그림 6-14의 회로에서 ADD와 SUB 선이 서로 단락되었을 때 다음 지점에서 발생할 증상을 설명하십시오.
(a) 74LS283 IC의 B[3..0] 입력
(b) 74LS283 IC의 C0 입력
(c) SUM (Σ) [3..0] 출력
(d) C4