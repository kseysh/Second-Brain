## 6-2
다음의 부호 있는 10진수를 2의 보수 체계로 나타내십시오. 부호 비트를 포함하여 총 8비트를 사용하십시오.
## 6-3
다음의 각 숫자는 2의 보수 체계에서 부호 있는 10진수를 나타냅니다. 각 경우에 10진 값을 구하십시오. (힌트: 음수를 양수로 변환하려면 부정을 사용하십시오.)
## 6-8
2의 보수 시스템이 컴퓨터 시스템에서 부호 있는 숫자(음수와 양수 모두)를 표현하는 데 있어 부호-크기 시스템보다 더 적절한지 분석하십시오. 다음 사례를 사용하십시오:
## 6-9
다음 연산을 2의 보수 체계에서 수행하십시오. 각 숫자에 대해 부호 비트를 포함하여 8비트를 사용하십시오. 결과를 이진수에서 10진수로 다시 변환하여 확인하십시오.
(g) +15에서 +51을 빼기
(h) -12에서 -12를 빼기
(i) +85에 -85 더하기
(j) -26에서 -26을 빼기
## 6-10
6-10 문제를 반복하고 각 경우에 오버플로가 발생하는지 보여주십시오.
(a) +45에 +89 더하기
(d) +89에서 -45 빼기
## 6-19
6-19.** 반가산기의 기능표를 작성하십시오 (입력 A와 B; 출력 합(SUM)과 자리올림(CARRY)). 기능표를 바탕으로 반가산기로 작동하는 논리 회로를 설계하십시오.
## 6-21
6-21. **그림 6-10을 참조하십시오. 다음 연산 순서 후 A 레지스터의 내용을 구하십시오: [A] = 0000, [0100] S [B], [S] S [A], [1011] S [B], [S] S [A].**
## 6-22
6-22. **그림 6-10을 참조하십시오. 각 플립플롭(FF)의 tPLH = tPHL = 50ns이고 설정 시간(setup time)이 15ns이며, 각 풀 애더(FA)의 전파 지연이 65ns일 때, LOAD 펄스의 PGT와 TRANSFER 펄스의 PGT 사이에 정상적인 동작을 위한 최소 시간은 얼마입니까?**
## 6-23
6-23. 이 장에서 다룬 덧셈기와 뺄셈기 회로에서는 오버플로우 가능성에 대해 고려하지 않았습니다. 오버플로우는 더하거나 뺀 두 수의 결과가 누산기의 용량을 초과하는 비트 수를 포함할 때 발생합니다. 예를 들어, 부호 비트를 포함한 4비트 레지스터를 사용하면 +7에서 -8까지의 숫자를 저장할 수 있습니다. 따라서 덧셈 또는 뺄셈의 결과가 +7을 초과하거나 -8보다 작으면 오버플로우가 발생했다고 말할 수 있습니다. 오버플로우가 발생하면 결과는 누산기 레지스터에 올바르게 저장할 수 없으므로 유용하지 않습니다. 예를 들어, +5(101012)와 +4(101002)를 더하면 결과는 1001이 됩니다. 이 1001은 부호 비트 위치에 1이 있기 때문에 부정적인 수로 잘못 해석될 것입니다.
## 6-25
## 6-26
## 6-28
## 6-30
## 6-33
## 6-39