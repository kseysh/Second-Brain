# C1
제1장 목표

• 아날로그와 디지털 표현을 구분한다.
• 정보가 단 두 개의 상태(1과 0)를 사용하여 어떻게 표현될 수 있는지 설명한다.
• 아날로그에 비해 디지털 기술의 장점과 단점을 언급한다.
• 아날로그-디지털 변환기(ADC)와 디지털-아날로그 변환기(DAC)의 목적을 설명한다.
• 이진수 시스템의 기본 특성을 인식한다.
• 이진수를 십진수로 변환한다.
• 이진수 시스템에서 수를 센다.
• 일반적인 디지털 신호를 식별한다.
• 타이밍 다이어그램을 식별한다.
• 병렬 전송과 직렬 전송의 차이점을 언급한다.
• 메모리의 특성을 설명한다.
• 디지털 컴퓨터의 주요 부품을 설명하고 그 기능을 이해한다.
• 마이크로컴퓨터, 마이크로프로세서, 마이크로컨트롤러를 구분한다.
# C2
### 디지털의 장점:
• 설계의 용이성
• 정보 저장에 적합함
• 정확성과 정밀성을 유지하기 쉬움
• 프로그래밍 가능한 동작
• 잡음의 영향을 덜 받음
• 집적 회로(IC) 칩에 쉽게 제작 가능
# Number Systems and Codes

### 여기서 알아야 하는 것
- 16진수 체계의 장점
- 16진수로 숫자 세는 법
- 십진수를 BCD로 표현하는 법
- BCD를 사용하는 장단점
- BCD와 순수 이진수의 차이점
- ASCII 코드와 같은 알파벳-숫자 코드의 목적 설명
- 오류 검출을 위한 패리티 방법 설명
- 디지털 데이터 문자열에 추가해야 하는 패리티 비트 결정

### 이진수-> 십진수를 구하는 Double-dabble 방식
![[Pasted image 20240913220228.png|300]]
### 십진수 -> 이진수를 구하는 방법
![[Pasted image 20240913220505.png|300]]

- LSB (Least Significant Bit): 최하위 비트
- MSB (Most Significant Bit): 최상위 비트

## 16진수, 10진수, 이진수 사이의 관계

### 16진수를 10진수로 변환  
각 16진수 자릿수를 그 위치 가중치에 곱하여 변환한다.
### 10진수를 16진수로 변환  
10진수를 2진수로 변환할 때 사용되는 반복 나눗셈 방법을 사용한다.
- 10진수를 16으로 나눈다.
- 첫 번째 나머지가 LSB이고, 마지막 나머지가 MSB이다.
- 마지막 그룹을 채우기 위해 MSB 왼쪽에 0을 추가할 수 있다.
### 이진수를 16진수로 변환  
LSB(최하위 비트)부터 시작하여 비트를 네 개씩 그룹으로 묶는다.
- 각 그룹을 해당하는 16진수 값으로 변환한다.
- 이진수를 4비트 그룹으로 묶고, 각 그룹을 그에 해당하는 16진수 자리로 변환한다.
### 십진수를 2진수로 변환
- 16진수로 변환한 후에 이진수로 변환하는 것이 편하다.
## BCD
Binary Coded Decimal: 10진수를 이진 형태로 표현하는 널리 사용되는 방법
- 10진수와 이진수 시스템의 특징을 결합한 방식이다.
- 각 자릿수를 이진수로 변환한다.
- BCD는 숫자 체계가 아니다.
- 10진수를 각 자릿수를 이진수로 변환하여 인코딩한 것이다.
- BCD 숫자는 순수 이진수와 동일하지 않다.
- BCD의 주요 장점은 *10진수로의 변환과 10진수에서의 변환이 상대적으로 쉽다*는 것이다.

십진수를 BCD로 변환
![[Pasted image 20240913225210.png|200]]

BCD를 십진수로 변환
![[Pasted image 20240913225329.png|200]]

## Gray Code
**Gray 코드**는 숫자가 빠르게 변하는 응용 분야에서 사용된다.
- 각 값에서 다음 값으로 변경될 때 오직 1비트만 바뀐다.

구하는 방법
1. **가장 왼쪽 비트는 동일하게 유지됩니다.**
2. **그 다음 비트는 현재 비트와 그 다음 비트를 XOR 연산하여 구합니다.**

ex) 이진수 1011을 GRAY 코드로 변환
1. **가장 왼쪽 비트:** 1 (변하지 않음)
2. **두 번째 비트:** 첫 번째 비트와 두 번째 비트를 XOR: 1 XOR 0 = 1
3. **세 번째 비트:** 두 번째 비트와 세 번째 비트를 XOR: 0 XOR 1 = 1
4. **네 번째 비트:** 세 번째 비트와 네 번째 비트를 XOR: 1 XOR 1 = 0

따라서, 이진수 1011의 그레이 코드는 1110입니다.
![[Pasted image 20240913225538.png|300]]

![[Pasted image 20240913225556.png|300]]

![[Pasted image 20240913231419.png]]
# Parity Method
비트 전송 시에는 오류가 발생할 수 있다. 따라서 code group에 추가 비트를 더하는 패티티 방법을 사용해 오류 수정을 제공할 수 있다.
### 짝수 패리티
패리티 비트를 포함한 그룹의 전체 비트 수는 짝수가 되어야 한다
- 이진 그룹 `1 0 1 1`은 패리티 비트 `1`을 추가해야 한다. 그러면 그룹은 `1 0 1 1 1`이 된다.
- 패리티 비트는 그룹의 어느 쪽 끝에나 추가할 수 있다.
### 홀수 패리티
패리티 비트를 포함한 그룹의 전체 비트 수는 홀수가 되어야 한다
이진 그룹 `1 1 1 1`은 패리티 비트 `1`을 추가해야 한다. 그러면 그룹은 `1 1 1 1 1`이 된다.
# C3
# 목표
- AND, OR, NOT의 기본 논리 연산 수행
- 논리게이트의 작동 이해 및 진리표 작성
- 논리 회로 게이트에 대한 타이밍 다이어그램 그리기
- 논리 게이트 및 논리 게이트 조합에 대한 불 표현식 작성
- AND, OR, NOT 게이트를 이용해 논리 회로 구현
- 불 대수를 사용해 복잡한 논리회로 단순화
- 드 모르간의 정리를 사용하여 논리 표현식 단순화
- NAND 또는 NOR와 같은 범용 게이트를 사용하여 불 표현식으로 표현된 회로 구현
- 표준 논리 게이트 기호 대신 대체 게이트 기호를 사용하여 논리 회로도 구성하는 장점 설명
- active-LOW와 active-HIGH 논리 신호의 개념 설명
- 전파 지연 시간 설명 및 측정
- 논리 회로의 작동을 다양한 방법으로 설명
- 하드웨어 설명 언어(HDL)로 정의된 간단한 회로 해석
- HDL과 컴퓨터 프로그래밍 언어의 차이점 설명
- 간단한 논리 게이트를 위한 HDL 파일 만들기
- 중간 변수가 포함된 조합 회로를 위한 HDL 파일 만들기
## 진리표
![[Pasted image 20240925004805.png|300]]
## OR 게이트
![[Pasted image 20240925005130.png|300]]
![[Pasted image 20240925005331.png|300]]
## AND 게이트
![[Pasted image 20240925005445.png|300]]
![[Pasted image 20240925005457.png|300]]
## NOT 연산
![[Pasted image 20240925005624.png|100]]![[Pasted image 20240925005635.png|200]]
![[Pasted image 20240925005654.png|200]]![[Pasted image 20240925005706.png|200]]
NOT 회로는 일반적으로 INVERTER라고 불린다.
![[Pasted image 20240925005842.png|300]]
버튼이 눌리면 (Logic level이 1이면) NOT gate 뒤의 값이 0이고, 
버튼이 눌리지 않으면 (Logic level이 0이면) NOT gate 뒤의 값이 1이다.
## 논리 회로 설명
표현식에 AND와 OR 게이트가 모두 포함된 경우, AND 연산이 먼저 수행된다. (곱셈이 먼저 수행되는 것처럼)
단, 표현식에 괄호가 있을 경우는 예외이다.
![[Pasted image 20240925011405.png|300]]
![[Pasted image 20240925011418.png|300]]
![[Pasted image 20240925011435.png|300]]
![[Pasted image 20240925011456.png|300]]
## 논리 회로 출력 계산하는 방법 (진리표 작성법)
여러 논리 게이트로 구성된 회로를 분석하는 가장 좋은 방법은 진리표를 사용하는 것
진리표를 사용하면 하나의 게이트 또는 논리 조합을 한 번에 분석할 수 있다.

![[Pasted image 20240925011711.png|400]]
![[Pasted image 20240925011931.png|150]]        ![[Pasted image 20240925011942.png|150]]
![[Pasted image 20240925012055.png|400]]
## 불 표현식을 사용한 회로 구현
불 표현식으로부터 논리 회로를 그릴 줄도 알아야 한다.
![[Pasted image 20240925012749.png|300]]
하나씩 하나씩 나눠서 그려본다.
![[Pasted image 20240925012811.png|300]]

![[Pasted image 20240925012840.png|300]]
## NOR 게이트와 NAND 게이트
NAND와 NOR게이트의 출력은 AND또는 OR게이트 진리표의 보수를 보여준다.
![[Pasted image 20240925013306.png|300]]
![[Pasted image 20240925013556.png|200]]
뒤에 동그라미가 붙어있다. 동그라미는 NOT이라고 생각하자.
![[Pasted image 20240925013453.png|300]]
![[Pasted image 20240925013542.png|200]]

![[Pasted image 20240925013628.png|70]]을 NOR와 NAND만 사용하여 구현한 논리회로
![[Pasted image 20240925013621.png|300]]
## 불 정리
•	정리 (1): 어떤 변수가 0과 AND 연산되면, 결과는 항상 0이 됩니다.
![[Pasted image 20240925013841.png|200]]
•	정리 (2): 일반 곱셈과 비교하여도 명백합니다.
![[Pasted image 20240925013857.png|200]]
•	정리 (3): 각 경우를 시도하여 증명합니다.
x = 0이면, 0⋅0 = 0
x = 1이면, 1 ⋅ 1 = 1
![[Pasted image 20240925013912.png|200]]
•	정리 (4): 동일한 방식으로 증명할 수 있습니다.
![[Pasted image 20240925013926.png|200]]
•	정리 (5): 0을 더해도 값에 영향을 미치지 않으므로, 일반 덧셈이나 OR 연산 덧셈에서 모두 동일합니다.
![[Pasted image 20240925014148.png|200]]
•	정리 (6): 어떤 변수가 1과 OR 연산되면, 결과는 항상 1입니다.
•	값 확인: 0 + 1 = 1과 1 + 1 = 1
![[Pasted image 20240925014233.png|200]]
•	정리 (7): x의 두 값에 대해 확인하여 증명할 수 있습니다:
•	0 + 0 = 0과 1 + 1 = 1
![[Pasted image 20240925014255.png|200]]
•	정리 (8): 유사한 방식으로 증명할 수 있습니다.
![[Pasted image 20240925014309.png|200]]
#### 교환 법칙
x  + y = y + x
x ⋅ y = y ⋅ x
#### 결합 법칙
x + (y + z) = (x + y) + z = x + y + z
x(yz) = (xy)z = xyz
#### 분배 법칙
x(y + z) = xy + xz
(w + x)(y + z) = wy + xy + wz + xz
#### 이외
![[Pasted image 20240925014602.png|150]]
![[Pasted image 20240925014628.png|250]]
## 드모르간의 법칙
NOR과 NAND의 대체 기호
![[Pasted image 20240925165004.png|400]]
![[Pasted image 20240925165045.png|400]]

## NAND 및 NOR 게이트의 보편성
NAND NOR 게이트는 OR AND INVERT의 세 가지 기본 논리 표현을 생성하는데 사용할 수 있다.
이는 논리 회로 설계에 유연성을 제공한다.
![[Pasted image 20240925165452.png|400]]
![[Pasted image 20240925165515.png|400]]
NOR 게이트는 불 연산의 모든 작업을 구현하도록 배열할 수 있다.
![[Pasted image 20240925165829.png|400]]
![[Pasted image 20240925165843.png|400]]
## 대체 논리 게이트 표현
1.  표준 기호의 각 입력과 출력을 반전시킨다
2. o가 없는 곳에 o를 추가한다.
3. o가 있던 곳에는 o를 제거한다.
4. AND를 OR로, OR을 AND로 변경한다.
![[Pasted image 20240925170151.png|400]]
- 회로는 임의의 입력 수를 가진 게이트로 확장할 수 있는데, 표준 AND OR NOT은 어느 것도 입력에 o가 없지만, 모든 대체 기호는 입력에 o가 들어가게 된다.
- NOR 과 NAND 게이트는 반전 게이트로, 각 게이트의 표준 및 대체 기호 모두 입력 또는 출력에 o가 있다.
- AND 및 OR 게이트는 비반전 게이트로 각 게이트의 대체 기호는 입력과 출력 모두에 o가 있다.
- Active-HIGH : 입력/출력에 o가 없음
- Active-LOW: 입력 또는 출력에 o가 있음
두 NAND 게이트 기호의 해석
![[Pasted image 20240925170927.png|350]]
두 OR 게이트 기호의 해석
![[Pasted image 20240925170942.png|350]]

## 어떤 게이트 표현을 사용할 것인가
회로 다이어그램에서 대체 게이트 기호를 적절히 사용하면 회로의 동작을 더 명확하게 할 수 있다.
- 표준 NAND 기호를 사용한 원래 회로
![[Pasted image 20240925171529.png|300]]
- Z가 Active-HIGH인 표현
![[Pasted image 20240925171443.png|300]]
- Z가 Active-LOW인 표현
![[Pasted image 20240925171558.png|300]]
### asserted
논리 신호가 활성 상태(HIGH or LOW)에 있을 때는 asserted 라고 한다
신호 위에 막대가 있으면 asserted (active) LOW라고 한다. (![[Pasted image 20240925171930.png|30]])
신호 위에 막대가 없으면 asserted (active) HIGH라고 한다. (![[Pasted image 20240925171951.png|30]])
### unasserted
논리 신호가 비활성 상태(HIGH or LOW)에 있을 때는 unasserted 라고 한다

----
출력 신호는 두 가지 활성 상태를 가질 수 있으며, HIGH 상태에서 중요한 기능을 하고, LOW 상태에서 또 다른 기능을 할 수 있다.
이러한 신호는 두 가지 활성 상태가 명확히 드러나도록 라벨링하는 것이 일반적이다.
가능한 경우, o가 달린 출력이 o가 달린 입력에 연결되도록 게이트 기호를 선택하는 것이 좋다
o가 없는 출력은 o가 없는 입력에 연결한다.

아래는 Z가 HIGH가 될 때 알람을 작동시킨다.
![[Pasted image 20240925172246.png|300]]
회로의 동작을 더 효과적으로 표현할 수 있도록 회로 다이어그램을 수정한 버전
![[Pasted image 20240925172341.png|300]]
NOR 게이트 기호를 버블이 없는(활성-HIGH) 출력 기호로 변경하여 AND 게이트 2의 버블이 없는 입력과 일치시켜야 합니다.
• 이제 회로는 게이트 2의 o가 없는 입력에 o가 없는 출력이 연결되었습니다.

![[Pasted image 20241003202058.png]]
# C4
# Chapter 4 목표
- 논리식을 합곱형(SOP) 표현으로 변환한다.
- 합곱형 표현을 가장 간단한 형태로 줄이기 위한 단계를 수행한다.
- 논리 회로를 간소화하고 설계하기 위해 부울 대수와 카르노 맵(Karnaugh map)을 도구로 사용한다.
- 배타적 OR(Exclusive-OR) 및 배타적 NOR(Exclusive-NOR) 회로의 동작을 설명한다.
- 진리표 없이 간단한 논리 회로를 설계한다.
- 인에이블(Enable) 회로를 구현하는 방법을 설명한다.
- TTL 및 CMOS 디지털 IC의 기본 특성을 설명한다.
- 디지털 시스템의 기본 문제 해결 규칙을 사용한다.
- 조합 논리 회로의 오작동 원인을 관찰된 결과로부터 추론한다.
- 프로그래머블 논리 장치(PLD)의 기본 개념을 설명한다.
- 간단한 조합 논리 기능을 수행하도록 PLD를 프로그래밍하는 데 필요한 단계를 설명한다.
- 계층적 설계 방법을 설명한다.
- 단일 비트, 비트 배열 및 숫자 값 변수에 적합한 데이터 유형을 식별한다.

# 4-1 합곱형(SOP) 표현
- 합곱형(SOP) 표현은 둘 이상의 AND 항이 OR로 결합된 형태로 나타난다.
![[Pasted image 20240926135143.png]]
- 곱합형(POS) 표현은 둘 이상의 OR 항(합)이 AND로 결합된 형태로 구성된다. 
![[Pasted image 20240926135215.png]]
# 4-2 회로 단순화
![[Pasted image 20241012231113.png]]
논리 회로는 부울 대수와 카르노 맵을 사용하여 간소화할 수 있다.
# 4-3 대수적 간소화
- 드모르간 법칙(DeMorgan's Theorems)을 적용하고 항을 곱하여 표현을 SOP 형태로 변환한다.
- SOP 형태에서 공통 항을 확인한다.
- 가능한 경우 인수를 분리하여 하나 이상의 항을 제거해야 한다.
![[Pasted image 20241012231405.png]]
먼저 출력에 대한 표현식을 결정합니다. 표현식이 결정되면, 드모르간의 정리를 사용하여 큰 인버터 기호를 분해하고 모든 항을 곱합니다.

![[Pasted image 20241012231455.png|300]]

인수 분해 - 위의 첫 번째 및 세 번째 항은 AC를 공통으로 가지고 있으며, 이를 인수로 분해할 수 있습니다.
![[Pasted image 20241012231833.png|150]]
![[Pasted image 20241012231839.png|150]]
# 4-4 조합 논리 회로 설계
- 논리 설계 문제를 해결하려면:
    1. 문제를 해석하고 진리표를 작성한다.
    2. 출력이 1인 경우에 대해 각각 AND(곱) 항을 작성한다.
    3. 이 항들을 SOP(합곱형) 형태로 결합한다.
    4. 가능하다면 출력식을 간소화한다.
    5. 최종적으로 간소화된 식에 맞는 회로를 구현한다.

- AND 게이트는 특정 입력 조건 세트에 대해 HIGH 출력을 생성하는 데 사용될 수 있다. 
![[Pasted image 20241012232137.png|400]]
- 1 출력이 되어야 하는 각 입력 조건 세트는 개별 AND 게이트로 구현된다. 
- AND 출력들은 OR 게이트로 결합되어 최종 출력을 만든다.
![[Pasted image 20241012232246.png|400]]
- 3입력 회로의 진리표:
    - 출력이 1인 경우에 대한 AND 항들
![[Pasted image 20241012232350.png|200]]
- A, B, C 세 가지 입력을 가진 논리 회로를 설계하라. 출력은 입력의 과반수가 HIGH일 때만 HIGH가 된다.
![[Pasted image 20241012232455.png|200]]
- 진리표를 작성하고, 출력이 1인 경우의 AND 항들을 식으로 표현.
- 간소화된 출력 표현: 인수 분해 후 회로 구현.
![[Pasted image 20241012232624.png|400]]
- 식이 SOP 형태이므로, 회로는 AND 게이트들의 그룹이 하나의 OR 게이트에 연결된 형태이다.
# 4-5 카르노 맵(Karnaugh Map) 방법
- 논리 방정식이나 진리표를 간소화하는 그래픽적 방법, 흔히 K 맵이라고 불린다.
- 이론적으로는 어떤 입력 변수 수에 대해서도 사용할 수 있지만, 실제로는 5~6개의 변수에 제한된다.
---
- 진리표의 값을 K 맵에 배치한다. 여기에서는 2변수 맵이 나타나 있다.
![[Pasted image 20241012232702.png|500]]
---
- 4변수 K-맵: 인접한 K 맵 사각형은 수평 및 수직으로 오직 하나의 변수만 다르다.
- 인접한 카르노 맵의 사각형은 가로와 세로로 오직 하나의 변수만 다릅니다. SOP 표현식은 1을 포함하는 모든 사각형을 OR 연산으로 결합하여 얻을 수 있습니다.
![[Pasted image 20241012233424.png|500]]
- 2, 4, 8개의 인접 그룹으로 1을 묶으면 추가 간소화가 이루어진다.
![[Pasted image 20241012233528.png|500]]
- 가능한 최대 크기의 그룹을 묶은 후, 공통 항들만 최종 표현식에 포함된다.
    - 묶음은 위, 아래, 좌우를 넘나들어 연결될 수 있다.
- K 맵 간소화 과정:
    1. K 맵을 작성하고 진리표에 따라 1을 배치한다.
    2. 다른 1과 인접하지 않은 1들을 묶는다.
    3. 쌍으로 된 1들을 묶는다.
    4. 이미 묶인 경우라도 8개의 1을 포함하는 그룹으로 묶는다.
    5. 아직 묶이지 않은 1이 하나 이상 있는 4개의 1을 포함하는 그룹을 묶는다.
    6. 아직 묶이지 않은 1을 포함시키기 위해 필요한 쌍을 묶는다.
    7. 각 묶음에서 생성된 항들의 OR 합을 형성한다.
# 4-6 배타적 OR(XOR) 및 배타적 NOR(XNOR) 회로
배타적 OR(XOR)은 두 입력이 서로 반대일 때 HIGH 출력을 생성한다.
![[Pasted image 20241012233758.png|400]]
- 이 회로는 두 입력이 서로 반대일 때 HIGH 출력을 생성한다.
---
- 전통적인 XOR 게이트 심볼.
![[Pasted image 20241012234237.png|400]]
- XOR 게이트는 두 입력을 결합하여 ![[Pasted image 20241012234328.png|80]]가 되도록 한다.
- XOR 출력식을 간단히 나타내는 방법: x=A⊕B, 여기서 ⊕는 XOR 연산을 나타낸다.
- 출력은 두 입력이 서로 다른 레벨일 때만 HIGH가 된다.
---
- 배타적 NOR(XNOR)은 두 입력이 같은 레벨일 때 HIGH 출력을 생성한다.
- XOR과 XNOR의 출력은 반대이다.
- 배타적 NOR 회로와 진리표.
- XNOR은 두 입력이 같은 레벨일 때 HIGH 출력을 생성한다.
![[Pasted image 20241012234536.png|400]]
- 전통적인 XNOR 게이트 심볼.
![[Pasted image 20241012234624.png|200]]
![[Pasted image 20241012234958.png|80]]
- XNOR 출력식을 간단히 나타내는 방법: ![[Pasted image 20241012235042.png|80]]이는 XOR 연산의 반대를 의미한다.
- 출력은 두 입력이 같은 레벨일 때만 HIGH가 된다.
---
![[Pasted image 20241012235205.png|500]]
- 2비트 이진수의 동등성을 검출하는 진리표와 회로.
![[Pasted image 20241012235231.png|500]]
- XNOR 게이트가 회로 구현을 간소화하는 방법.
# 4-7 패리티 생성기 및 검사기
![[Pasted image 20241012235648.png|500]]
- XOR과 XNOR 게이트는 패리티 생성 및 검사 회로에서 유용하다.
# 4-8 인에이블/디스에이블 회로
- 인에이블/디스에이블 회로가 필요한 상황은 디지털 회로 설계에서 자주 발생한다.
    - 회로가 인에이블되면 입력 신호가 출력으로 전달될 수 있다.
    - 회로가 디스에이블되면 입력 신호가 출력으로 전달되지 않는다.
![[Pasted image 20241016174152.png|300]]

![[Pasted image 20241016174227.png|300]]
- 제어 입력 B와 C가 둘 다 HIGH일 때만 신호가 출력으로 전달되는 논리 회로.
    - 그렇지 않으면 출력은 LOW로 유지된다.

![[Pasted image 20241016174245.png|300]]
- 제어 입력 중 하나만 HIGH일 때 신호를 출력으로 전달하는 논리 회로.
    - 그렇지 않으면 출력은 HIGH로 유지된다.

![[Pasted image 20241016174258.png|300]]
- 입력 신호 A, 제어 입력 B, 출력 X 및 Y를 가진 논리 회로는 다음과 같이 동작한다:
    - B = 1일 때, 출력 X는 입력 A를 따르고, 출력 Y는 0이 된다.
    - B = 0일 때, 출력 X는 0이 되고, 출력 Y는 입력 A를 따른다.
# 4-9 디지털 IC의 기본 특성
• IC “칩”은 기판이라고 불리는 반도체 재료 위에 저항기, 다이오드, 트랜지스터로 구성됩니다. 디지털 IC는 일반적으로 기판 위의 논리 게이트 수에 따라 복잡도로 분류됩니다.

• 듀얼 인라인 패키지(DIP)는 두 개의 병렬 핀 행을 포함합니다. 
	DIP는 아마도 구형 디지털 장비에서 가장 흔한 디지털 IC 패키지일 것입니다. 
![[Pasted image 20241016174905.png|150]]

핀은 식별용 노치나 점이 있는 끝에서부터 시계 반대 방향으로 번호가 매겨집니다.
![[Pasted image 20241016174848.png|200]]

• 실제 실리콘 칩은 DIP보다 훨씬 작습니다. 보통 약 0.05인치 정사각형입니다. 
실리콘 칩은 매우 가는 (1밀) 와이어로 DIP 핀에 연결됩니다.
![[Pasted image 20241016175225.png|250]]

• PLCC(Plastic Leaded Chip Carrier)는 현대 디지털 회로에서 흔히 볼 수 있는 패키지 중 하나입니다. 
이 유형은 IC 아래로 말려 들어가는 J자형 리드를 사용합니다.
![[Pasted image 20241016175256.png|200]]

IC는 또한 회로에서 사용되는 구성 요소의 유형에 따라 분류됩니다.
	• 양극성 IC는 NPN 및 PNP 트랜지스터를 사용합니다 -> TTL
	• 단극성 IC는 FET 트랜지스터를 사용합니다 -> CMOS

트랜지스터-트랜지스터 로직(TTL) 패밀리는 다음과 같은 서브 패밀리로 구성됩니다.
• TTL 장치 간의 차이는 전력 소모 및 스위칭 속도와 같은 전기적 특성에 국한됩니다. 핀 배치와 논리 연산은 동일합니다.
![[Pasted image 20241016175344.png|300]]

상보성 금속 산화막 반도체(CMOS) 패밀리는 여러 시리즈로 구성됩니다.
• CMOS 장치는 TTL 장치와 동일한 기능을 수행하지만 반드시 핀 호환성은 아닙니다.
![[Pasted image 20241016175401.png|250]]

• 연결되지 않은 입력은 부유(floating) 상태라고 합니다.
	• 부유하는 TTL 입력은 논리 1처럼 동작합니다. 
		전압 측정은 불확정적으로 보일 수 있지만 장치는 부유 입력에 1이 있는 것처럼 동작합니다.
• 부유하는 CMOS 입력은 과열과 장치 손상을 초래할 수 있습니다. 

일부 IC는 보호 회로가 내장되어 있습니다.
• 가장 좋은 방법은 모든 사용하지 않는 입력을 고정하는 것입니다.
	• 높거나 낮게 고정.

![[Pasted image 20241016175440.png|350]]
• 불확정 범위의 전압은 예측할 수 없는 결과를 초래하므로 피해야 합니다.

![[Pasted image 20241016175512.png|350]]
• 연결 다이어그램은 모든 전기적 연결, 핀 번호, IC 번호, 구성 요소 값, 신호 이름 및 전원 공급 전압을 보여줍니다.
• 이 회로는 두 개의 다른 IC에서 논리 게이트를 사용합니다. 각 게이트 입력 및 출력 핀 번호는 회로의 어느 지점을 쉽게 참조할 수 있도록 다이어그램에 표시됩니다.
• 각 IC의 전원/접지 연결이 표시됩니다.

![[Pasted image 20241016175552.png|450]]
• Quartus II 회로도 캡처를 사용한 논리 다이어그램.
# 4-10 디지털 시스템 문제 해결
• 결함(고장)이 있는 디지털 회로 또는 시스템을 고치는 기본 단계는 다음과 같습니다:
	• 결함 탐지: 예상되는 동작과의 차이를 결정합니다
	• 결함 격리: 결함을 격리하기 위해 테스트 및 측정을 수행합니다.
	• 결함 수정: 결함을 수리합니다

기본적인 문제 해결 도구는 논리 프로브, 오실로스코프 및 논리 펄서입니다
• 논리 프로브는 핀에 접촉했을 때 신호의 존재 유무를 나타냅니다.
# 4-11 디지털 IC 내부 결함
• 가장 흔한 내부 고장은 다음과 같습니다:
	• 내부 회로의 오작동:
		• 입력에 제대로 응답하지 않는 출력
		• 예측 불가능한 출력
• 입력 또는 출력이 접지 또는 VCC에 단락됨:
	• 입력이 LOW 또는 HIGH 상태에 고정됩니다.
• 입력 또는 출력의 단선:
	• 열린 출력은 부유 상태를 나타냅니다.
	• TTL의 부유 입력은 HIGH 출력을 초래합니다.
	• CMOS 장치의 부유 입력은 불규칙하거나 파괴적인 출력을 초래합니다.
• 두 핀 간의 단락(접지 또는 VCC 이외의 경우):
	• 해당 핀의 신호는 항상 동일합니다.

![[Pasted image 20241016175943.png|500]]
이 두 가지 유형의 고장은 단락된 핀에서 입력 신호가 동일한 상태로 유지되도록 합니다.
• 왼쪽: IC 입력이 내부적으로 접지에 단락됨.
• 오른쪽: IC 입력이 내부적으로 공급 전압에 단락됨.

![[Pasted image 20241016180052.png|500]]
이 두 가지 유형의 고장은 IC 입력의 신호에 영향을 미치지 않습니다.
• 왼쪽: IC 출력이 내부적으로 접지에 단락됨.
• 오른쪽: IC 출력이 내부적으로 공급 전압에 단락됨.

![[Pasted image 20241016180231.png|500]]
내부적으로 열린 입력이 있는 IC는 해당 입력 핀에 적용된 신호에 응답하지 않습니다.
내부적으로 열린 출력은 해당 출력 핀에서 예측 불가능한 전압을 생성합니다.

![[Pasted image 20241016180255.png|500]]
IC의 두 핀 간 내부 단락은 해당 핀의 논리 신호가 항상 동일하도록 강제합니다.
두 입력 핀이 내부적으로 단락되면 이 핀을 구동하는 신호는 동일하게 강제되며, 일반적으로 세 가지 서로 다른 수준의 신호가 발생합니다.
# 4-12 외부 결함
• 열린 신호선: 신호가 포인트 간 이동을 방해합니다. 원인은 다음과 같습니다:
	• 끊어진 와이어.
	• 불량한 연결(납땜 또는 와이어 랩).
	• PCB 트레이스의 절단 또는 균열.
	• 휜 또는 부러진 IC 핀.
• 불량한 IC 소켓.
	• 이러한 유형의 결함은 육안A 으로 감지할 수 있으며, 문제의 포인트 간 저항계를 사용하여 확인할 수 있습니다

회로에서 가장 가능한 결함은 무엇입니까?
![[Pasted image 20241016180352.png|500]]
• NOR 게이트 출력의 불확정 수준은 아마도 2번 핀의 불확정 입력 때문일 것입니다.
• Z1-6에서 LOW가 있기 때문에 이 LOW는 Z2-2에서도 있어야 합니다.
• Z1-6과 Z2-2 사이의 개방 회로.

단락된 신호선: 동일한 신호가 두 개 이상의 핀에 나타나며 VCC 또는 접지에도 단락될 수 있습니다. 원인은 다음과 같습니다:
	• 부주의한 배선.
	• 납땜 다리.
	• 불완전한 에칭.
		• 이러한 유형의 결함은 육안으로 감지할 수 있으며, 문제의 포인트 간 저항계를 사용하여 확인할 수 있습니다.
불량한 전원 공급 장치: IC가 작동하지 않거나 불규칙하게 작동합니다.
	• 내부 결함으로 인해 규제가 손실되거나 회로가 너무 많은 전류를 소모할 수 있습니다.
• 전원 공급 장치가 지정된 범위의 전압을 제공하고 제대로 접지되었는지 확인합니다.
	• 오실로스코프를 사용하여 AC 리플이 없는지 확인하고 DC 전압이 규제된 상태를 유지하는지 확인합니다
• 일부 IC는 전원 변동에 더 잘 견디며 정상적으로 작동할 수 있지만, 다른 IC는 그렇지 않을 수 있습니다.
	• 잘못 작동하는 것처럼 보이는 각 IC의 전원 및 접지 수준을 확인합니다.
출력 로딩: IC 출력에 너무 많은 입력을 연결하여 출력 전류 용량을 초과하는 경우 발생합니다.
	• 출력 전압이 불확정 범위로 떨어집니다
		• 이를 출력 신호의 로딩이라고 합니다.
	• 보통 설계 불량 또는 잘못된 연결의 결과입니다
# 4-13 프로토타입 회로 문제 해결
• 설계를 프로토타입하기 전에 검증하여 결함 있는 설계로 회로를 구축하면서 겪는 좌절을 피하십시오.
• 가능한 많은 결함 위치를 제거합니다.
	• 결함 시나리오 #1: U1B의 5번 핀이 A가 아닌 실제로 A에 연결되어 있습니다. (212페이지)
	• 문제를 격리하기 위한 문제 해결 단계
# 4-14 프로그래머블 논리 장치 (PLD)
• 프로그래머블 논리 장치의 개념은 간단합니다. 하나의 IC에 많은 논리 게이트가 포함됩니다.
	• 이러한 게이트의 상호 연결을 전자적으로 제어합니다.
• PLD는 설계 과정을 자동화할 수 있게 합니다. 설계자는 입력, 출력 및 논리적 관계를 식별합니다.
	• PLD는 정의된 논리 회로를 형성하도록 전자적으로 구성됩니다.

![[Pasted image 20241016180523.png|500]]
• PLD는 종종 프로그래머블 배열이라고 불리는 스위치 매트릭스를 사용합니다. 
어떤 교차점이 연결되고 연결되지 않는지를 결정함으로써, 우리는 입력이 배열의 출력과 연결되는 방식을 “프로그래밍”할 수 있습니다

• 시스템 외부 프로그래밍에서는 PLD를 프로그래머에 놓고 PC에 연결합니다
	• PC 소프트웨어는 정보를 변환하고 로드합니다.
• 시스템 내 프로그래밍은 IC가 시스템에 남아 있는 동안 “포털” 핀에 직접 연결하여 수행됩니다.
	• 인터페이스 케이블이 PLD를 소프트웨어를 실행하는 PC에 연결하여 장치를 로드합니다.
• 논리 회로는 회로도, 논리 방정식, 진리표 및 HDL을 사용하여 설명할 수 있습니다.
	• PLD 개발 소프트웨어는 이러한 설명 중 어느 것이든 1과 0으로 변환하여 PLD에 로드할 수 있습니다.
• Altera MAX+PLUS II는 그래픽 설계 파일과 타이밍 다이어그램을 사용하여 회로를 설명할 수 있는 개발 소프트웨어입니다.

![[Pasted image 20241016180722.png|300]]
• 계층적 설계: 작은 논리 회로가 정의되고 다른 회로와 결합하여 프로젝트의 큰 부분을 형성합니다.
	• 큰 부분을 결합하 시스템을 형성할 수 있습니다.

• 탑다운 설계: 시스템을 구성할 하위 섹션을 정의하는 것을 요구합니다.
![[Pasted image 20241016180703.png|500]]

• HDL로 설명된 회로의 타이밍 시뮬레이션. 시스템은 아래에서부터 위로 구축됩니다.
![[Pasted image 20241016180639.png|500]]

• 각 블록은 설계 파일로 설명됩니다.
• 테스트 후 개발 소프트웨어를 사용하여 컴파일됩니다.
• 컴파일된 블록은 올바른 동작을 확인하기 위해 시뮬레이터를 사용하여 테스트됩니다.
• PLD는 올바른 동작을 확인하기 위해 프로그래밍됩다.

![[Pasted image 20241016180827.png|300]]
# C5
• 가장 중요한 메모리 요소는 플립플롭(FF)입니다. 논리 게이트의 조합으로 구성되어 있습니다. 
![[Pasted image 20241017091324.png|500]]
플립플롭은 래치 및 쌍안정 멀티바이브레이터 등으로도 알려져 있습니다.
# 5-1 NAND 게이트 래치
![[Pasted image 20241017091353.png|400]]
• NAND 게이트 래치 또는 단순히 래치는 기본적인 플립플롭입니다.
	• 입력은 SET와 CLEAR(RESET)입니다.
• 입력은 active LOW입니다. 입력이 LOW로 펄스되면 출력이 변경됩니다.
![[Pasted image 20241017091427.png|400]]
## 5-1 NAND 게이트 래치 – 래치(FF) 설정
• SET 입력을 0 상태로 펄스할 때…
• (a) SET 펄스 이전에 Q = 0
• (b) SET 펄스 이전에 Q = 1
![[Pasted image 20241017100011.png|500]]
• 두 경우 모두 Q는 HIGH가 됩니다.
## 5-1 NAND 게이트 래치 – 래치(FF) 재설정
• RESET을 LOW로 펄스할 때…
• (a) RESET 펄스 이전에 Q = 0
• (b) RESET 펄스 이전에 Q = 1
![[Pasted image 20241017100035.png|500]]
• 두 경우 모두 Q는 LOW가 됩니다.
## 5-1 NAND 게이트 래치 – 대체 표현
![[Pasted image 20241017100052.png|500]]
• NAND 래치의 등가 표현 및 단순화된 블록 다이어그램.

## 5-1 NAND 게이트 래치 – 요약
![[Pasted image 20241017224241.png|200]]
• NAND 래치의 요약:
• SET = 1, RESET = 1—정상적인 휴식 상태, 출력은 입력 이전 상태를 유지합니다.
• SET = 0, RESET = 1—출력은 Q = 1로 변경되며, SET가 HIGH로 돌아간 후에도 그대로 유지됩니다. 이를 래치 설정이라고 합니다.
• SET = 1, RESET = 0—출력은 Q = 0 LOW가 되며, RESET이 HIGH로 돌아간 후에도 그대로 유지됩니다. 이를 래치 재설정 또는 초기화라고 합니다.
• SET = 0, RESET = 0—래치를 동시에 설정하고 초기화하려고 시도합니다.
• ![[Pasted image 20241017092440.png|50]]
• 이 입력 조건은 사용해서는 안 됩니다.
## 5-2 NOR 게이트 래치
• 두 개의 교차 결합된 NOR 게이트를 사용하여 NOR 게이트 래치를 만들 수 있습니다. 이는 NAND 래치와 유사합니다.
• Q와 Q 출력은 반대로 됩니다. 
![[Pasted image 20241017100137.png|500]]
SET 및 RESET 입력은 활성 HIGH입니다. 입력이 HIGH로 펄스되면 출력이 변경됩니다.
## 5-2 NOR 게이트 래치 – 요약
![[Pasted image 20241017224024.png|200]]
• NOR 래치의 요약:
• SET = 0, RESET = 0—정상적인 휴식 상태, 출력 상태에 영향을 주지 않습니다.
• SET = 1, RESET = 0—항상 Q = 1을 설정하며, SET가 0으로 돌아간 후에도 그대로 유지됩니다
• SET = 0, RESET = 1—항상 Q = 0을 초기화하며, RESET이 0으로 돌아간 후에도 그대로 유지됩니다.
• SET = 1, RESET = 1—래치를 동시에 설정하고 초기화하려고 시도합니다.
• Q = Q = 0
• 이 입력 조건은 사용해서는 안 됩니다
## 5-2 전원 켜짐 시 상태
• 전원이 공급될 때, 플립플롭의 출력 시작 상태를 예측할 수 없습니다. SET 및 RESET 입력이 비활성 상태에 있을 경우.
• 래치 또는 플립플롭을 특정 상태에서 시작하려면, 초기 동작 시 SET 또는 RESET 입력을 일시적으로 활성화하여 해당 상태로 설정해야 합니다.
• 일반적으로 적절한 입력에 펄스를 적용하여 달성합니다.
## 5-3 문제 해결 사례 연구
![[Pasted image 20241017094722.png|500]]
• 회로 문제 해결:
• 여러 가지 가능성이 있습니다:
	• Z1-1의 내부 개방 연결로 인해 Q가 입력에 반응하지 못합니다.
	• NAND 게이트 Z1의 내부 부품 고장으로 인해 제대로 반응하지 못합니다.

![[Pasted image 20241017094751.png|500]]
	• Q 출력이 LOW에 고정됨. 이는 다음과 같은 원인일 수 있습니다:
		• Z1-3이 내부적으로 접지에 단락됨
		• Z1-4가 내부적으로 접지에 단락됨
		• Z2-2가 내부적으로 접지에 단락됨
		• Q 노드가 외부적으로 접지에 단락됨
## 5-4 디지털 펄스
![[Pasted image 20241015135642.png|400]]
양의 펄스는 활성 HIGH 수준을 가지고 있습니다. 

![[Pasted image 20241015135709.png|400]]
활성 및 비활성 상태 사이를 전환하는 신호는 펄스 파형이라고 합니다. 
음의 펄스는 활성 LOW 수준을 가지고 있습니다. 

실제 회로에서는 펄스 파형이 한 수준에서 다른 수준으로 변하는 데 시간이 걸립니다.
	• 양의 펄스에서 LOW에서 HIGH로의 전환을 상승 시간(tr)이라고 합니다. 

![[Pasted image 20241015135859.png|400]]
전압 파형의 전면에서 10%와 90% 지점 사이에서 측정됩니다. 

실제 회로에서는 펄스 파형이 한 수준에서 다른 수준으로 변하는 데 시간이 걸립니다.
	• 양의 펄스에서 HIGH에서 LOW로의 전환을 하강 시간(tf)이라고 합니다. 

![[Pasted image 20241015140002.png|400]]
전압 파형의 후면에서 90%와 10% 지점 사이에서 측정됩니다. 

실제 회로에서는 펄스 파형이 한 수준에서 다른 수준으로 변하는 데 시간이 걸립니다.
	• 펄스는 또한 지속 시간—폭—(tw)을 가집니다. 전압의 HIGH 수준의 50% 지점에서 전면과 후면 사이의 시간을 의미합니다.
## 5-5 클럭 신호 및 클럭 플립플롭
디지털 시스템은 비동기식 또는 동기식으로 작동할 수 있습니다.
	• 비동기식 시스템—입력의 변화가 있을 때 언제든지 출력이 상태를 변경할 수 있습니다.
	• 동기식 시스템—출력은 클럭 주기 내에서 특정 시간에만 상태를 변경할 수 있습니다. 

클럭 신호는 직사각형 펄스 열 또는 정사각형 파형입니다.
	• 양의 전이(PGT)—클럭 펄스가 0에서 1로 변합니다.
	• 음의 전이(NGT)—클럭 펄스가 1에서 0으로 변합니다. 
![[Pasted image 20241015140624.png|300]]
전이도 에지라고 합니다. 

클럭된 플립플롭은 한쪽 클럭 전이에서 상태를 변경합니다.
• 클럭 입력은 CLK, CK, 또는 CP로 표시됩니다. 

![[Pasted image 20241015141037.png|400]]
CLK 입력에 작은 삼각형이 있으면 입력이 PGT로 활성화됨을 나타냅니다. 
![[Pasted image 20241015141050.png|400]]
버블과 삼각형은 CLK 입력이 NGT로 활성화됨을 나타냅니다.

제어 입력은 활성 클럭 전이(NGT 또는 PGT)에서만 출력에 영향을 미칩니다—이를 동기 제어 입력이라고도 합니다.
	• 제어 입력은 출력을 변경할 준비를 하지만, 변화는 CLK 에지가 발생할 때까지 트리거되지 않습니다. 
![[Pasted image 20241015141117.png|300]]
설정 시간(tS)은 활성 CLK 전이 전 최소 시간 간격으로, 제어 입력이 적절한 수준에서 유지되어야 합니다. 

![[Pasted image 20241017094910.png|300]]
유지 시간(tH)은 CLK의 활성 전이 후 시간으로, 제어 입력이 적절한 수준에서 유지되어야 합니다.
## 5-6 클럭된 S-R 플립플롭
S와 R 입력은 동기 제어 입력으로, 클럭 펄스가 발생할 때 플립플롭이 갈 상태를 제어합니다.
	• CLK 입력은 S와 R 입력에 따라 플립플롭이 상태를 변경하게 하는 트리거 입력입니다.
SET-RESET(또는 SET-CLEAR) 플립플롭은 양 또는 음의 클럭 에지에서 상태를 변경합니다. 

양의 에지에 의해 트리거된 클럭된 S-R 플립플롭입니다. 
![[Pasted image 20241017095027.png]]
S와 R 입력은 이전에 NOR 게이트 래치에 대해 설명한 것과 동일한 방식으로 플립플롭의 상태를 제어하지만, 플립플롭은 클럭 신호의 PGT가 발생할 때까지 이러한 입력에 응답하지 않습니다.

![[Pasted image 20241017095046.png|400]]
• 클럭 펄스의 양의 에지에 의해 트리거된 클럭된 S-R 플립플롭의 동작 파형입니다.

![[Pasted image 20241017095110.png|500]]
• 클럭 신호의 음의 에지에 의해 트리거된 클럭된 S-R 플립플롭입니다.
• 양의 에지 및 음의 에지 트리거 플립플롭 모두 디지털 시스템에서 사용됩니다.




