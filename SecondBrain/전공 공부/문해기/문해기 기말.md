### 7-A
전형적인 BFS
but 0,0이 왼쪽 아래에 있으니 input 값 받을 때 y는 반대로 받자. 나머지는 똑같다.
### 7-B
DP인데, 가로 idx 0, 세로 idx 0부분을 세팅해주고 좌측 위쪽에서 +1 해가면서 마지막 부분 출력
### 9-A
rockToNode map 하나 만들고, 이외에는 모두 공간을 이용해서 graph만들고 tree 탐색 isVisit 필요없음
nodeDepth 벡터 하나 있으니 편한듯
### 9-B
1부터 size까지 가장자리 i로 채운다.
match라면, i-1, j-1을 그대로 가져온다.
아니라면 `dp[i][j] = 1 + min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1] ));`

### 10-A
우선 순위 큐를 사용, 자신만 출마했을 때 0 출력하는 것 고려
target은 따로 빼서 쓰기
### 10-B
많이 풀어보기
오른쪽 보고 cx와 flag는 따로 관리하기
### 11-A
queue에 넣다 뺐다..
### 11-B

### 12-A

### 12-B
### 13-A

### 13-B