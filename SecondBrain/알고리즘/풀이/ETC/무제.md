# 문제
For a given array A of N integers and a sequence S of N integers from the set {−1, 1}, we define val(A, S) as follows:

> val(A, S) = |**sum**{ A[i]*S[i] for i = 0..N−1 }|

(Assume that the sum of zero elements equals zero.)

For a given array A, we are looking for such a sequence S that minimizes val(A,S).

Write a function:

> `class Solution { public int solution(int[] A); }  content_copy    `

that, given an array A of N integers, computes the minimum value of val(A,S) from all possible values of val(A,S) for all possible sequences S of N integers from the set {−1, 1}.

For example, given array:

  A[0] =  1
  A[1] =  5
  A[2] =  2
  A[3] = -2

content_copy

your function should return 0, since for S = [−1, 1, −1, 1], val(A, S) = 0, which is the minimum possible value.

Write an ****efficient**** algorithm for the following assumptions:

> - N is an integer within the range [0..20,000];
> - each element of array A is an integer within the range [−100..100].

## 풀이
```java
import java.util.Arrays;  
  
class Solution {  
    public int solution(int[] A) {  
        int N = A.length;  
        // 빈 배열이거나 합이 0인 경우 처리  
        if (N == 0) return 0;  
  
        int sum = 0;  
        int maxVal = 0;  
  
        // 1. 빈도수 배열 (Counting Array) 생성  
        // 숫자의 범위가 0~100이므로 크기는 101        int[] count = new int[101];  
  
        for (int num : A) {  
            int val = Math.abs(num);  
            if (val == 0) continue; // 0은 합에 영향 없음  
            count[val]++;  
            sum += val;  
            maxVal = Math.max(maxVal, val);  
        }  
  
        // 2. DP 배열 초기화  
        // dp[j] = 현재 처리 중인 숫자 val을 사용해서 합 j를 만들었을 때, 남은 val의 개수  
        // -1 이면 도달 불가능  
        int[] dp = new int[sum / 2 + 1];  
        Arrays.fill(dp, -1);  
        dp[0] = 0; // 합 0은 아무것도 안 쓰면 되므로 도달 가능  
  
        // 3. 숫자 종류별로(1~100) DP 수행  
        for (int v = 1; v <= maxVal; v++) {  
            if (count[v] > 0) { // 해당 숫자가 존재한다면  
                for (int j = 0; j <= sum / 2; j++) {  
  
                    // Case A: 이미 이전 숫자들로 합 j를 만들 수 있었던 경우  
                    if (dp[j] >= 0) {  
                        dp[j] = count[v]; // 현재 숫자 v는 하나도 안 쓰고 모두 남음 (충전)  
                    }  
                    // Case B: 이전에는 못 만들었지만, 현재 숫자 v를 하나 써서(j-v) 만들 수 있는 경우  
                    else if (j >= v && dp[j - v] > 0) {  
                        dp[j] = dp[j - v] - 1; // v를 하나 소모하여 합 j 도달  
                    }  
                    // Case C: 여전히 못 만드는 경우 -> 그대로 -1 유지  
                }  
            }  
        }  
  
        // 4. 가능한 합 중 sum/2에 가장 가까운 값 찾기  
        int result = sum; // 최악의 경우 (아무것도 못 뺄 때)  
  
        for (int i = 0; i <= sum / 2; i++) {  
            if (dp[i] >= 0) {  
                // i는 도달 가능한 부분 합(P)  
                // 우리가 원하는 값 = |2P - Sum| = Sum - 2P (왜냐하면 P <= Sum/2 이므로)  
                result = Math.min(result, sum - 2 * i);  
            }  
        }  
  
        return result;  
    }  
}
```
A의 절댓값을 구하고, A 원소의 범위인 100까지의 각 원소가 나오는 횟수를 계산해둠
A의 모든 원소의 합을 sum이라고 하면, 나는 sum / 2에 가까운 값을 만들어 내는 것이 목적임 (그래야 최소 diff를 구할 수 있음)

1부터 maxValue까지 한 번씩 순회하며 만들 수 있는 값을 구함 (최대 100번 순회)
