# 정답 본 풀이
```java
import java.io.*;
import java.util.*;

public class Main {
    static final int INF = 987654321;
    static int N, K;
    static int[][] map;
    static int[] dy = { 0, 1, 0, -1 };
    static int[] dx = { 1, 0, -1, 0 };

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        K = Integer.parseInt(st.nextToken());

        map = new int[N + 1][N + 1];
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= N; i++) {
            map[N][i] = Integer.parseInt(st.nextToken());
        }

        int time = 0;
        while (!isFinish()) {
            time++;
            pushFish();

            make2D();
            adjustFish();

            make1D();
            fold();
            adjustFish();

            make1D();
        }
        System.out.println(time);
    }

    private static boolean isFinish() {
        int max = 0;
        int min = INF;
        for (int y = 1; y <= N; y++) {
            for (int x = 1; x <= N; x++) {
                if (map[y][x] == 0)
                    continue;
                if (max < map[y][x])
                    max = map[y][x];
                if (min > map[y][x])
                    min = map[y][x];
            }
        }
        return max - min <= K;
    }

    private static void fold() {
        // 2번 반복
        int pivotX = 1;
        int yCnt = 1; // 현재 접히는 블록의 높이
        for (int cnt = 1; cnt <= 2; cnt++) {
            int ny = N - yCnt * 2 + 1; // 접어서 올리면 높이가 두배가 되므로 바닥(N)에서 yCnt * 2만큼 뺀 위치부터 쌓는다.
            for (int y = N; y > N - yCnt; y--) {
                for (int x = pivotX; x < pivotX +(N - pivotX + 1) / 2; x++) {
                    map[ny][N - (x - pivotX)] = map[y][x];
                    map[y][x]=0;
                }
                ny++;
            }
            yCnt *= 2;
            pivotX += N / 2;
        }
    }

    private static void make1D() {
        List<Integer> list = new ArrayList<>();
        for (int x = 1; x <= N; x++) {
            for (int y = N; y >= 1; y--) {
                if (map[y][x] == 0)
                    break;
                list.add(map[y][x]);
                map[y][x] = 0;
            }
        }
        for (int i = 0; i < N; i++) {
            map[N][i + 1] = list.get(i);
        }
    }

    private static void make2D() {
        int pivotX = 1; // 현재 바닥에 깔린 어항 중 처리되지 않은 시작점
        int w = 1; // 들어올릴 블록의 너비
        int h = 1; // 들어올릴 블록의 높이
        int idx = 0;
        while (h  <= N - w * h) { // w * h : 뭉친 어항의 부피이므로 N - w * h가 1층만 존재하는 어항의 크기
            idx++;
            for (int x = pivotX; x < pivotX + w; x++) {
                for (int y = N; y > N - h; y--) {
                    // ny:
                    // N - w: 바닥을 기준으로 w만큼 위로 올라간 지점
                    // x - pivotX: 기존 블록의 시작점에서 얼마나 오른쪽으로 떨어져 있었는지

                    // nx:
                    // pivotX + w : 어항 블록이 현재 블록(pivotX)의 오른쪽 옆(w)에 있어야 함 (새로운 시작점)
                    // N - y: 바닥(N)에서 얼마나 위에 있었는지
                    int ny = N - w + x - pivotX;
                    int nx = pivotX + w + N - y;
                    map[ny][nx] = map[y][x];
                    map[y][x] = 0;
                }
            }
            pivotX += w;
            if (idx % 2 == 0) { // 너비와 높이를 번갈아 가며 증가
                w++;
            } else {
                h++;
            }
        }
    }

    // 물고기 수가 가장 적은 어항에 물고기 추가
    private static void pushFish() {
        // 한 번의 순회로 최솟값을 찾아내는 방법 알아두기
        List<Integer> posList = new ArrayList<>();
        int min = INF;
        for (int i = 1; i <= N; i++) {
            if (map[N][i] < min) {
                min = map[N][i];
                posList.clear();
                posList.add(i);
            } else if (map[N][i] == min) {
                posList.add(i);
            }
        }

        for (int idx : posList) {
            map[N][idx]++;
        }
    }

    private static void adjustFish() {
        int[][] adjustMap = new int[N + 1][N + 1];

        for (int y = 1; y <= N; y++) {
            for (int x = 1; x <= N; x++) {
                if (map[y][x] == 0)
                    continue;
                for (int d = 0; d < 4; d++) {
                    int ny = y + dy[d];
                    int nx = x + dx[d];
                    if ((ny < 1 || nx < 1 || ny > N || nx > N) || map[ny][nx] == 0)
                        continue;
                    int diff = map[y][x] - map[ny][nx];
                    diff /= 5;
                    // 현재 위치에서 다음 위치로 물고기 보내기 가능
                    if (diff > 0) {
                        adjustMap[y][x] -= diff;
                        adjustMap[ny][nx] += diff;
                    }
                }
            }
        }
        // 보내고 받는 물고기 수를 +- 계산
        for (int y = 1; y <= N; y++) {
            for (int x = 1; x <= N; x++) {
                map[y][x] += adjustMap[y][x];
            }
        }
    }

}
```
설명 잘 되어 있는 c++ 풀이: https://zoosso.tistory.com/1069
java 풀이: https://jangcenter.tistory.com/94
# 알아둘 것
- make2D, fold 함수에서 수학적으로 원소의 위치를 변경하는 방법에 대해서 알아두자.
- 굴릴 때 map을 2차원배열로 만들어서 굴리는 방식을 기억해두자.