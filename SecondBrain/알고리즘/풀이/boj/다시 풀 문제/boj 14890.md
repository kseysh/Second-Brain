# 나의 풀이
```cpp
#include <vector>
#include <iostream>
#define MAX_N 100
using namespace std;

int n, l;
int m[MAX_N][MAX_N];
bool isUsed[MAX_N];
int line[MAX_N];

bool inRange(int i){
    return i >= 0 && i < n;
}

void initIsUsed(){
    for(int i = 0; i < n; i++){
        isUsed[i] = false;
    }
}

bool isSameFloor(int start, int end){
    if(!inRange(start)) return false;
    if(!inRange(end)) return false;
    int floor = line[start];
    for(int i = start; i <= end; i++){
        if(floor != line[i]) return false;
    }
    return true;
}

bool createRunway(int start, int end){
    for(int i = start; i <= end; i++){
        if(isUsed[i]) return false;
        isUsed[i] = true;
    }
    return true;
}

bool canPassBy(){
    for(int i = 0; i < n - 1; i++){
        if(isSameFloor(i, i + 1)) continue;

        if(line[i] == line[i + 1] + 1){// 내리막 경사로 설치
            int lastRunwayIdx = i + l;
            if(!isSameFloor(i + 1, lastRunwayIdx)) return false; // i 부터 i + l까지 같은 층이어야 설치 가능
            if(!createRunway(i + 1, lastRunwayIdx)) return false; // 경사로 설치
            i = lastRunwayIdx - 1;
        }else if(line[i] == line[i + 1] - 1){ // 오르막 경사로 설치
            int startRunwayIdx = i - l + 1;
            if(!isSameFloor(startRunwayIdx, i)) return false; // i - l부터 i까지 같은 층이어야 설치 가능
            if(!createRunway(startRunwayIdx, i)) return false; // 이미 존재하는 경사로가 있다면 실패
        }else{
            return false;
        }
    }
    return true;
}

int main(){
    cin >> n >> l;
    for(int y = 0; y < n; y++){
        for (int x = 0; x < n; x++) {
            cin >> m[y][x];
        }
    }
    
    int passCount = 0; // 지나가지 못하는 길의 수
    for(int y = 0; y < n; y++){
        for(int x = 0; x < n; x++) line[x] = m[y][x];
        initIsUsed();
        if(canPassBy()) passCount++;
    }

    for(int x = 0; x < n; x++){
        for(int y = 0; y < n; y++) line[y] = m[y][x];
        initIsUsed();
        if(canPassBy()) passCount++;
    }

    cout << passCount;
    
    return 0;
}
```
푸는데 너무 오래걸렸다..
각 line으로 분류하면 공통된 함수를 적용할 수 있었는데, 처음에 그렇게 접근하지 못했다.
공통 로직을 함수로 활용할 수 있는 생각을 할 줄 알아야 한다.
자잘한 실수가 많아 디버깅에 오랜 시간이 걸린 문제가 있었다.

# 다른 사람의 풀이
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,l,ans,mp[111][111];
int main(){
    scanf("%d %d",&n,&l);
    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) scanf("%d",&mp[i][j]);

    for(int i=1;i<=n;i++){
        int fl=0,lt=1;
        for(int j=2;j<=n;j++){
            if(abs(mp[i][j]-mp[i][j-1]) > 1) fl=1;

            else{
                if(mp[i][j] < mp[i][j-1]){
                    for(int k=1;k<l;k++){
                        if(j+k>n || mp[i][j] != mp[i][j+k]){
                            fl=1;
                            break;
                        }
                    }
                    lt=j+l;
                }else if(mp[i][j] > mp[i][j-1]){
                    if(j-lt < l){
                        fl=1;
                    }
                    else{
                        lt = j;
                    }
                }
            }

            if(fl) break;
        }
        if(!fl) ans++;
    }

    for(int i=1;i<=n;i++){
        int fl=0,lt=1;
        for(int j=2;j<=n;j++){
            if(abs(mp[j][i]-mp[j-1][i]) > 1) fl=1;

            else{
                if(mp[j][i] < mp[j-1][i]){
                    for(int k=1;k<l;k++){
                        if(j+k>n || mp[j][i] != mp[j+k][i]){
                            fl=1;
                            break;
                        }
                    }
                    lt=j+l;
                }else if(mp[j][i] > mp[j-1][i]){
                    if(j-lt < l){
                        fl=1;
                    }
                    else{
                        lt = j;
                    }
                }
            }
            if(fl) break;
        }
        if(!fl) ans++;
    }


    printf("%d",ans);
}
```