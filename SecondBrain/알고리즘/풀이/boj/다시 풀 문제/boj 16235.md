# 나의 풀이
```java
import java.io.*;
import java.util.*;

public class Main {
    private static class Tree implements Comparable<Tree>{
        int y, x, years;
        boolean isDead;
        public Tree(int y, int x, int years){
            this.y = y;
            this.x = x;
            this.years = years;
            this.isDead = false;
        }

        public static Tree newTree(int y, int x){
            return new Tree(y, x, 1);
        }

        @Override
        public int compareTo(Tree t){
            if (this.y == t.y){
                if(this.x == t.x){
                    return this.years - t.years;
                }
                return this.x - t.x;
            }
            return this.y - t.y;
        }
    }

    private static int n, m, k;
    private static int[][] addedNutrients;
    private static int[][] curNutrients;
    private static final int[] dy = {0,0,1,1,1,-1,-1,-1};
    private static final int[] dx = {1,-1,0,1,-1,0,1,-1};
    private static List<Tree> trees = new LinkedList<>();

    private static void spring(){
        for(Tree t : trees){
            if(t.years <= curNutrients[t.y][t.x]){
                curNutrients[t.y][t.x] -= t.years;
                t.years++;
                // 자신의 나이만큼 양분을 먹고, 나이가 1 증가한다.
            }else{
                t.isDead = true;
                // 양분을 먹을 수 없는 나무는 즉시 죽는다.
            }
        }
    }

    private static void summer(){
        List<Tree> treeToRemove = new ArrayList<>();
        for(Tree t : trees){
            if(t.isDead){ // 죽은 나무가 양분으로 변한다.
                curNutrients[t.y][t.x] += t.years / 2;
                treeToRemove.add(t);
            }
        }
        trees.removeAll(treeToRemove); // 시간 복잡도 문제?
    }

    private static void autumn(){
        List<Tree> addedTrees = new LinkedList<>();
        for(Tree t : trees){
            if(t.years % 5 == 0){ // 번식하는 나무는 5의 배수여야 한다.
                for (int d = 0; d < 8; d++) {
                    int ny = t.y + dy[d];
                    int nx = t.x + dx[d];
                    if(!inRange(ny, nx)) continue;
                    addedTrees.add(Tree.newTree(ny, nx));
                }
            }
        }
        trees.addAll(addedTrees);
    }

    private static void winter(){
        for (int y = 1; y <= n; y++) { // 겨울에 추가되는 양분
            for (int x = 1; x <= n; x++) {
                curNutrients[y][x] += addedNutrients[y][x];
            }
        }
    }

    private static boolean inRange(int y, int x){
        return y > 0 && x > 0 && y <= n && x <= n;
    }

    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        k = Integer.parseInt(st.nextToken());

        addedNutrients = new int[n + 1][n + 1];
        curNutrients = new int[n + 1][n + 1];
        for (int y = 1; y <= n; y++) { // 겨울에 추가되는 양분
            st = new StringTokenizer(br.readLine());
            for (int x = 1; x <= n; x++) {
                addedNutrients[y][x] = Integer.parseInt(st.nextToken());
                curNutrients[y][x] = 5;
            }
        }

        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int x = Integer.parseInt(st.nextToken());
            int y = Integer.parseInt(st.nextToken());
            int years = Integer.parseInt(st.nextToken());
            trees.add(new Tree(y, x, years));
        }

        while(k-- > 0){
            Collections.sort(trees);
            spring();
            summer();
            autumn();
            winter();
        }

        System.out.println(trees.size());
    }
}
```
나름 깔끔하게 풀었지만, 역시 걱정했던 removeAll에서 시간 복잡도 증가 문제가 발생하였다.

## 최적화 풀이
```java

```