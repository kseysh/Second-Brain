# 나의 풀이
```java
import java.io.*;
import java.util.*;

public class Main {
    private static class Tree implements Comparable<Tree>{
        int y, x, years;
        boolean isDead;
        public Tree(int y, int x, int years){
            this.y = y;
            this.x = x;
            this.years = years;
            this.isDead = false;
        }

        public static Tree newTree(int y, int x){
            return new Tree(y, x, 1);
        }

        @Override
        public int compareTo(Tree t){
            if (this.y == t.y){
                if(this.x == t.x){
                    return this.years - t.years;
                }
                return this.x - t.x;
            }
            return this.y - t.y;
        }
    }

    private static int n, m, k;
    private static int[][] addedNutrients;
    private static int[][] curNutrients;
    private static final int[] dy = {0,0,1,1,1,-1,-1,-1};
    private static final int[] dx = {1,-1,0,1,-1,0,1,-1};
    private static List<Tree> trees = new LinkedList<>();

    private static void spring(){
        for(Tree t : trees){
            if(t.years <= curNutrients[t.y][t.x]){
                curNutrients[t.y][t.x] -= t.years;
                t.years++;
                // 자신의 나이만큼 양분을 먹고, 나이가 1 증가한다.
            }else{
                t.isDead = true;
                // 양분을 먹을 수 없는 나무는 즉시 죽는다.
            }
        }
    }

    private static void summer(){
        List<Tree> treeToRemove = new ArrayList<>();
        for(Tree t : trees){
            if(t.isDead){ // 죽은 나무가 양분으로 변한다.
                curNutrients[t.y][t.x] += t.years / 2;
                treeToRemove.add(t);
            }
        }
        trees.removeAll(treeToRemove); // 시간 복잡도 문제?
    }

    private static void autumn(){
        List<Tree> addedTrees = new LinkedList<>();
        for(Tree t : trees){
            if(t.years % 5 == 0){ // 번식하는 나무는 5의 배수여야 한다.
                for (int d = 0; d < 8; d++) {
                    int ny = t.y + dy[d];
                    int nx = t.x + dx[d];
                    if(!inRange(ny, nx)) continue;
                    addedTrees.add(Tree.newTree(ny, nx));
                }
            }
        }
        trees.addAll(addedTrees);
    }

    private static void winter(){
        for (int y = 1; y <= n; y++) { // 겨울에 추가되는 양분
            for (int x = 1; x <= n; x++) {
                curNutrients[y][x] += addedNutrients[y][x];
            }
        }
    }

    private static boolean inRange(int y, int x){
        return y > 0 && x > 0 && y <= n && x <= n;
    }

    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        k = Integer.parseInt(st.nextToken());

        addedNutrients = new int[n + 1][n + 1];
        curNutrients = new int[n + 1][n + 1];
        for (int y = 1; y <= n; y++) { // 겨울에 추가되는 양분
            st = new StringTokenizer(br.readLine());
            for (int x = 1; x <= n; x++) {
                addedNutrients[y][x] = Integer.parseInt(st.nextToken());
                curNutrients[y][x] = 5;
            }
        }

        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int x = Integer.parseInt(st.nextToken());
            int y = Integer.parseInt(st.nextToken());
            int years = Integer.parseInt(st.nextToken());
            trees.add(new Tree(y, x, years));
        }

        while(k-- > 0){
            Collections.sort(trees);
            spring();
            summer();
            autumn();
            winter();
        }

        System.out.println(trees.size());
    }
}
```
나름 깔끔하게 풀었지만, 역시 걱정했던 removeAll에서 시간 복잡도 증가 문제가 발생하였다.

## 최적화 풀이
```java
import java.io.*;  
import java.util.*;  
  
public class Main {  
    private static class Tree implements Comparable<Tree>{  
        int y, x, years;  
        public Tree(int y, int x, int years){  
            this.y = y;  
            this.x = x;  
            this.years = years;  
        }  
  
        public static Tree newTree(int y, int x){  
            return new Tree(y, x, 1);  
        }  
  
        @Override  
        public int compareTo(Tree t){  
            return this.years - t.years;  
        }  
    }  
  
    private static int n, m, k;  
    private static int[][] addedNutrients;  
    private static int[][] curNutrients;  
    private static final int[] dy = {0,0,1,1,1,-1,-1,-1};  
    private static final int[] dx = {1,-1,0,1,-1,0,1,-1};  
    private static Deque<Tree> trees = new ArrayDeque<>();  
    private static Queue<Tree> treesToRemove = new LinkedList<>();  
  
    private static void spring(){  
        int size = trees.size();  
        for(int i = 0; i < size; i++){  
            Tree t = trees.pollFirst();  
            if(curNutrients[t.y][t.x] >= t.years){  
                curNutrients[t.y][t.x] -= t.years;  
                t.years++;  
                trees.addLast(t);  
            }else{  
                treesToRemove.add(t);  
            }  
        }  
    }  
  
    private static void summer(){  
        while(!treesToRemove.isEmpty()){  
            Tree t = treesToRemove.poll();  
            curNutrients[t.y][t.x] += t.years / 2;  
        }  
    }  
  
    private static void autumn(){  
        List<Tree> addedTrees = new LinkedList<>();  
        for(Tree t : trees){  
            if(t.years % 5 == 0){ // 번식하는 나무는 5의 배수여야 한다.  
                for (int d = 0; d < 8; d++) {  
                    int ny = t.y + dy[d];  
                    int nx = t.x + dx[d];  
                    if(!inRange(ny, nx)) continue;  
                    addedTrees.add(Tree.newTree(ny, nx));  
                }  
            }  
        }  
  
        for (Tree t : addedTrees){  
            trees.addFirst(t); // 가장 어린 나무를 앞으로 넣음으로써 정렬유지  
        }  
    }  
  
    private static void winter(){  
        for (int y = 1; y <= n; y++) { // 겨울에 추가되는 양분  
            for (int x = 1; x <= n; x++) {  
                curNutrients[y][x] += addedNutrients[y][x];  
            }  
        }  
    }  
  
    private static boolean inRange(int y, int x){  
        return y > 0 && x > 0 && y <= n && x <= n;  
    }  
  
    public static void main(String[] args) throws IOException{  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
  
        n = Integer.parseInt(st.nextToken());  
        m = Integer.parseInt(st.nextToken());  
        k = Integer.parseInt(st.nextToken());  
  
        addedNutrients = new int[n + 1][n + 1];  
        curNutrients = new int[n + 1][n + 1];  
        for (int y = 1; y <= n; y++) { // 겨울에 추가되는 양분  
            st = new StringTokenizer(br.readLine());  
            for (int x = 1; x <= n; x++) {  
                addedNutrients[y][x] = Integer.parseInt(st.nextToken());  
                curNutrients[y][x] = 5;  
            }  
        }  
  
        List<Tree> initTrees = new ArrayList<>();  
        for (int i = 0; i < m; i++) {  
            st = new StringTokenizer(br.readLine());  
            int y = Integer.parseInt(st.nextToken());  
            int x = Integer.parseInt(st.nextToken());  
            int years = Integer.parseInt(st.nextToken());  
            initTrees.add(new Tree(y, x, years));  
        }  
  
        Collections.sort(initTrees);  
        trees.addAll(initTrees);  
  
        while(k-- > 0){  
            spring();  
            summer();  
            autumn();  
            winter();  
        }  
  
        System.out.println(trees.size());  
    }  
}
```
추가 정렬을 하지 않고 Deque를 사용해서 새로 번식된 나무를 맨 앞으로 가져옴으로써 추가적인 정렬을 구현하지 않아도 되도록 했다.

## 알아둘 것
![[Linked List의 성능 문제]]