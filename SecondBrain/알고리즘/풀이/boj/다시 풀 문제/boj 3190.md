
# 나의 풀이
```cpp
#include <vector>
#include <iostream>
#define MAX_N 100
using namespace std;

pair<bool, int> map[MAX_N + 1][MAX_N + 1]; // 존재하는지, d
int n, k, l;
const pair<bool, int> APPLE = {false, 100001};
const pair<bool, int> EMPTY = {false, 10000};

bool inRange(int y, int x){
    return y <= n && x <= n && x > 0 && y > 0;
}

int dy[4] = {0, 1, 0, -1};
int dx[4] = {1, 0, -1, 0}; 
// 우 하 좌 상
// D -> + 1, L -> -1

bool isGameEnd(int y, int x){
    if(!inRange(y, x)) return true; // 벽에 부딫힌다.
    if(map[y][x].first) return true; // 자신 몸에 부딫힌다.
    return false;
}

int main(){

    cin >> n >> k;

    int row, col;

    for(int i = 0; i <= n; i++){
        for(int j = 0; j <= n; j++){
            map[i][j] = EMPTY;
        }
    }

    for(int i = 0; i < k; i++){
        cin >> row >> col;
        map[row][col] = APPLE;
    }

    cin >> l;

    int time;
    char d;
    vector<pair<int, char>> v;
    for(int i = 0; i < l; i++){
        cin >> time >> d;
        v.push_back({time, d});
    }

    time = 0;
    int hy = 1;
    int hx = 1;
    int ty = 1;
    int tx = 1;
    int timeIdx = 0;
    map[1][1] = {true, 0};
    while(true){
        pair<bool, int> p = map[hy][hx];
        int d = p.second;
        // 정해진 time에 방향을 전환한다.
        if(timeIdx < v.size() && time == v[timeIdx].first){
            if(v[timeIdx].second == 'L'){
                d = (d + 3) % 4;
            }else{
                d = (d + 1) % 4;
            }
            timeIdx++;
            map[hy][hx] = {true, d};
        }
        // 먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다.
        hy = hy + dy[d];
        hx = hx + dx[d];
        time++;
        // 만약 벽이나 자기자신의 몸과 부딪히면 게임이 끝난다.
        if(isGameEnd(hy, hx)) break;
        
        if(map[hy][hx] != APPLE){
            int td = map[ty][tx].second;
            map[ty][tx] = EMPTY; // 현재 꼬리를 지우고
            // 새로운 꼬리 위치 할당
            ty = ty + dy[td];
            tx = tx + dx[td];
        }
        
        map[hy][hx] = {true, d};
        
    }
    cout << time;
    return 0;
}
```
뭔가 복잡하다
1. 굳이 사과를 map 안에 넣을 필요없이 아래처럼 따로 board를 만들어 사과가 있는지 없는지 확인하는 편이 훨씬 편하다.

## 다른 사람의 풀이
```cpp
#include <bits/stdc++.h>
using namespace std;

int boardSize, appleCount, turnCount;
int board[111][111];   // 1이면 사과 존재
int snake[111][111];   // 뱀이 차지한 위치의 시간 기록
int headX, headY, direction, snakeLength, timeCount;

// 방향 (우, 하, 좌, 상)
int dx[4] = {0, 1, 0, -1};
int dy[4] = {1, 0, -1, 0};

int main() {
    cin >> boardSize >> appleCount;

    // 사과 위치 입력
    for (int i = 1; i <= appleCount; i++) {
        int row, col;
        cin >> row >> col;
        board[row][col] = 1;
    }

    // 초기값 (뱀 시작 위치)
    headX = headY = 1;
    snakeLength = 1;
    timeCount = 0;
    snake[headX][headY] = ++timeCount;

    // 방향 전환 명령 입력
    cin >> turnCount;
    while (turnCount--) {
        int targetTime;
        char turnDir;
        cin >> targetTime >> turnDir;

        // 해당 시간까지 뱀 이동
        while (timeCount <= targetTime) {
            int nextX = headX + dx[direction];
            int nextY = headY + dy[direction];

            // 벽 또는 자기 몸에 부딪히면 종료
            if (nextX < 1 || nextY < 1 || nextX > boardSize || nextY > boardSize
                || timeCount - snakeLength < snake[nextX][nextY]) {
                cout << timeCount << "\n";
                return 0;
            }

            // 이동
            headX = nextX;
            headY = nextY;
            snake[headX][headY] = ++timeCount;

            // 사과 먹으면 길이 증가
            if (board[headX][headY]) {
                board[headX][headY] = 0;
                snakeLength++;
            }
        }

        // 방향 전환
        if (turnDir == 'L') direction = (direction + 3) % 4; // 왼쪽 회전
        else direction = (direction + 1) % 4;                // 오른쪽 회전
    }

    // 더 이상 명령이 없으면 계속 직진
    while (true) {
        int nextX = headX + dx[direction];
        int nextY = headY + dy[direction];

        if (nextX < 1 || nextY < 1 || nextX > boardSize || nextY > boardSize
            || timeCount - snakeLength < snake[nextX][nextY]) {
            cout << timeCount << "\n";
            return 0;
        }

        headX = nextX;
        headY = nextY;
        snake[headX][headY] = ++timeCount;

        if (board[headX][headY]) {
            board[headX][headY] = 0;
            snakeLength++;
        }
    }
}

```
처음에 나도 비슷한 접근을 했는데, 여기서는 `timeCount - snakeLength < snake[nextX][nextY]`를 이용해 내가 하려했던 방식으로 구현했다.
그래도 나름 큰 차이는 없는 듯