## 나의 풀이
```java
import java.io.*;  
import java.util.*;  
  
public class Main {  
    private static final char EMPTY = '.';  
    private static final char WALL = '#';  
    private static final char HOLE = 'O';  
    private static final char RED = 'R';  
    private static final char BLUE = 'B';  
    private static final int BOUNDARY = 10;  
    private static char[][] map;  
    private static int n, m;  
    private static int answer = Integer.MAX_VALUE;  
    private static int cry, crx, cby, cbx;  
    private static int[] dy = {0, -1, 0, 1};  
    private static int[] dx = {1, 0, -1, 0};  
    // 우 상 좌 하  

  
    private static boolean isInHall(int d, char color){  
        boolean isRed = color == RED;  
        int cy = (isRed) ? cry : cby;  
        int cx = (isRed) ? crx : cbx;  
  
        while(true){  
            int ny = cy + dy[d];  
            int nx = cx + dx[d];  
  
            if(map[ny][nx] == EMPTY){  
                if(isRed){  
                    if(cby == ny && cbx == nx){  
                        cry = cy;  
                        crx = cx;  
                        return false;  
                    }  
                }else{  
                    if(cry == ny && crx == nx){  
                        cby = cy;  
                        cbx = cx;  
                        return false;  
                    }  
                }  
                cy = ny;  
                cx = nx;  
            }else if(map[ny][nx] == HOLE){  
                if(isRed){  
                    cry = -1;  
                    crx = -1;  
                }else{  
                    cby = -1;  
                    cbx = -1;  
                }  
                return true; // hole에 들어감  
            }else{ // 벽에 부딫힘  
                if(isRed){  
                    cry = cy;  
                    crx = cx;  
                }else{  
                    cby = cy;  
                    cbx = cx;  
                }  
                return false;  
            }  
        }  
    }  
  
    private static boolean move(int d, int count){  
        // 무언가 구멍에 들어가면 false, 그게 빨간 구슬만 들어갔으면 answer 업데이트  
        boolean redInHall = false;  
        boolean blueInHall = false;  
        boolean redFirst = true;  
        if(crx == cbx){ // 세로로 움직일 때 순서를 정해야 함  
            if(d == 1){ // 상  
                redFirst = (cry < cby);  
            } else if (d == 3) { // 하  
                redFirst = (cry > cby);  
            }  
        }else if (cry == cby){ // 가로로 움직일 때 순서를 정해야 함  
            if(d == 0){ // 우  
                redFirst = (crx > cbx);  
            } else if (d == 2) { // 좌  
                redFirst = (crx < cbx);  
            }  
        }  
  
        if(redFirst){ // red가 먼저 움직이는 상황  
            if(isInHall(d, RED)) redInHall = true;  
            if(isInHall(d, BLUE)) blueInHall = true;  
        }else{ // blue가 먼저 움직이는 상황  
            if(isInHall(d, BLUE)) blueInHall = true;  
            if(isInHall(d, RED)) redInHall = true;  
        }  

        if(redInHall && !blueInHall) answer = Math.min(answer, count);  
        return !redInHall && !blueInHall; // 구멍에 들어가면 false    }  
  
    private static void simulate(int count){  
        if(count > BOUNDARY) return;  
        int pry = cry;  
        int prx = crx;  
        int pby = cby;  
        int pbx = cbx;  
        for (int d = 0; d < 4; d++) {  
            if(move(d, count)){ // 구멍에 뭔가 들어갔으면 더 진행하지 않음  
                simulate(count + 1);  
            }  
            cry = pry;  
            crx = prx;  
            cby = pby;  
            cbx = pbx;  
        }  
    }  
  
    public static void main(String[] args) throws IOException{  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
  
        n = Integer.parseInt(st.nextToken());  
        m = Integer.parseInt(st.nextToken());  
        map = new char[n][m];  
  
        for (int y = 0; y < n; y++) {  
            String str = br.readLine();  
            for (int x = 0; x < m; x++) {  
                map[y][x] = str.charAt(x);  
                if(map[y][x] == BLUE){  
                    cby = y;  
                    cbx = x;  
                    map[y][x] = EMPTY;  
                } else if(map[y][x] == RED){  
                    cry = y;  
                    crx = x;  
                    map[y][x] = EMPTY;  
                }  
            }  
        }  
  
        simulate(1);  
        if(answer == Integer.MAX_VALUE) System.out.println(-1);  
        else System.out.println(answer);  
    }  
}
```
코드가 너무 복잡해 저조차도 이해가 어려웠습니다.
전역으로 관리되는 구슬의 위치와 로컬 변수로 관리되는 구슬의 위치를 관리하는 것이 어려웠습니다.
또한, move함수나 isInHall의 반환 타입이 함수명과 맞지 않는 반환타입이었기에 
```java
if(!move(d, count)){ // 구멍에 뭔가 들어갔으면 더 진행하지 않음  
	simulate(count + 1);  
}  

if(move(d, count)){ // 구멍에 뭔가 들어갔으면 더 진행하지 않음  
	simulate(count + 1);  
}  
```
아래처럼 작성해야 했지만, 위처럼 작성해서 틀렸습니다. 

```java
if(d == 1){ // 상  
	redFirst = (cry < cby); // 이 부분도 실수해서 거꾸로 적었습니다.
} else if (d == 3) { // 하  
	redFirst = (cry > cby);  
}  
```
코드를 깔끔하게 짜려면 어떻게 했어야 했을까..

## 다른 사람의 풀이
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.StringTokenizer;

public class Main {
	
	static int N,M;
	static int[] dx = {-1,1,0,0};
	static int[] dy = {0,0,-1,1};
	static char[][] map;
	static boolean[][][][] visit;
	
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());
		map = new char[N][M];
		visit = new boolean[N][M][N][M];//빨강좌표, 파랑좌표
		int rx=0, ry=0, bx=0, by=0;
		for(int i=0; i<N; ++i) {
			String s = br.readLine();
			for(int j=0; j<M; ++j) {
				map[i][j] = s.charAt(j);
				if(map[i][j]=='R') {
					rx = i;
					ry = j;
				}
				else if(map[i][j]=='B') {
					bx = i;
					by = j;
				}
			}
		}
		System.out.print(bfs(rx,ry,bx,by));		
	}
	static int bfs(int rx, int ry, int bx, int by) {
		ArrayDeque<int[]> q = new ArrayDeque<>();
		visit[rx][ry][bx][by] = true;
		q.add(new int[] {rx,ry,bx,by,0});
		while(!q.isEmpty()) {
			int[] now = q.poll();
			if(now[4]>10) break; //움직임 횟수 10초과
			if(map[now[0]][now[1]]=='O') return now[4]; //빨강만 구멍에
			for(int i=0; i<4; ++i) {
				int r1 = now[0];
				int r2 = now[1];
				int b1 = now[2];
				int b2 = now[3];
				int cntr=0, cntb=0;
				//빨강 이동
				while(true) {
					if(map[r1+dx[i]][r2+dy[i]]=='#') break;
					r1 += dx[i];
					r2 += dy[i];
					++cntr;
					if(map[r1][r2]=='O') break;
				}
				//파랑 이동
				while(true) {
					if(map[b1+dx[i]][b2+dy[i]]=='#') break;
					b1 += dx[i];
					b2 += dy[i];
					++cntb;
					if(map[b1][b2]=='O') break;
				}
				//파랑이 구멍에 들어감
				if(map[b1][b2]=='O') continue;
				//겹칠때
				if(r1==b1 && r2==b2) {
					//많이 이동한쪽을 뒤로 물림
					if(cntr>cntb) {
						r1 -= dx[i];
						r2 -= dy[i];
					}
					else {
						b1 -= dx[i];
						b2 -= dy[i];
					}
				}
				if(!visit[r1][r2][b1][b2]) {
					visit[r1][r2][b1][b2] = true;
					q.add(new int[] {r1,r2,b1,b2,now[4]+1});
				}
			}
		}
		return -1;
	}
}
```
배울점
1. BFS를 활용하여 시간 복잡도를 DFS보다 훨씬 줄일 수 있었음
2. boolean\[]\[]\[]\[] visit을 활용하여 같은 상태를 중복해서 탐색하지 않도록 함

여기서는 구슬이 겹쳤을 때, 많이 이동한 쪽을 뒤로 물렸지만 이건 내 방식이 더 이해하기 쉬운 듯 하다.