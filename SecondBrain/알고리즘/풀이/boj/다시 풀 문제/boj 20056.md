# 나의 풀이
```cpp
#include <vector>
#include <iostream>
#include <map>
#include <tuple>

#define MAX_N 50
using namespace std;

struct FireBall{
    int sumedCount, sumedMass, sumedSpeed;
    int m, d, s;
    bool isOddSumed, isEvenSumed;

    FireBall(int m, int d, int s){
        this->sumedCount = 1;
        this->sumedMass = m;
        this->sumedSpeed = s;
        this->m = m;
        this->d = d;
        this->s = s;
        if(d % 2 == 0) {
            isEvenSumed = true;
            isOddSumed = false;    
        }else{
            isOddSumed = true;
            isEvenSumed = false;    
        }
        
    }

    FireBall(){}

    void sum(FireBall &sumedFireBall){
        sumedCount++;
        sumedMass += sumedFireBall.m;
        sumedSpeed += sumedFireBall.s;
        if(sumedFireBall.d % 2 == 0) isEvenSumed = true;
        else isOddSumed = true;
    }

    void divide(){
        // 질량은 ⌊(합쳐진 파이어볼 질량의 합)/5⌋이다.
        int calculatedMass = sumedMass / 5;
        // 속력은 ⌊(합쳐진 파이어볼 속력의 합)/(합쳐진 파이어볼의 개수)⌋이다.
        int calculatedSpeed = sumedSpeed / sumedCount;
        m = calculatedMass;
        sumedMass = calculatedMass;
        s = calculatedSpeed;
        sumedSpeed = calculatedSpeed;
        sumedCount = 4;
        if(isEvenSumed != isOddSumed){
            isEvenSumed = true;
            isOddSumed = false;
        }else{
            isOddSumed = true;
            isEvenSumed = false;
        }
    }
};


int n, fireBallCount, k;
int dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};
int dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};
map<pair<int, int>, FireBall> fireMap;
map<pair<int, int>, FireBall> sumedFireMap;


pair<int, int> setRightRange(pair<int, int> &pos){
    while(pos.first > n) pos.first -= n;
    while(pos.first <= 0) pos.first += n;
    while(pos.second > n) pos.second -= n;
    while(pos.second <= 0) pos.second += n;
    return pos;
}

void insertSumedFireMap(pair<int, int> pos, FireBall fireball){
    // 모든 파이어볼이 자신의 방향 di로 속력 si칸 만큼 이동
    pos.first += dy[fireball.d] * fireball.s;
    pos.second += dx[fireball.d] * fireball.s;
    pos = setRightRange(pos);
    // 이동이 모두 끝난 뒤, 2개 이상의 파이어볼이 있는 칸에서는 다음과 같은 일이 일어난다.
    if(sumedFireMap.find(pos) != sumedFireMap.end()){
        FireBall originFireBall = sumedFireMap.find(pos)->second;
        // 같은 칸에 있는 파이어볼은 모두 하나로 합쳐진다.
        originFireBall.sum(fireball);
        sumedFireMap[pos] = originFireBall;
    }else{
        sumedFireMap[pos] = fireball;
    }
}

int main(){
    cin >> n >> fireBallCount >> k;

    int r, c, m, d, s;
    for(int i = 0; i < fireBallCount; i++){
        cin >> r >> c >> m >> s >> d;
        fireMap[{r, c}] = FireBall(m, d, s);
    }

    for(int i = 0; i < k; i++){
        for(auto &a : fireMap){
            pair<int, int> pos = a.first;
            FireBall fireball = a.second;
            int cy = pos.first;
            int cx = pos.second;

            if(fireball.sumedCount == 1){ // 1 또는 4임
                insertSumedFireMap(pos, fireball);
            }else{
                fireball.sumedCount = 1;
                if(fireball.isEvenSumed){
                    for(int j = 0; j < 4; j++){ 
                        fireball.d = j * 2;
                        insertSumedFireMap(pos, fireball);
                    }        
                }else{
                    for(int j = 0; j < 4; j++){ 
                        fireball.d = j * 2 + 1;
                        insertSumedFireMap(pos, fireball);
                    }        
                }
            }
        }
        

        fireMap.clear();
        for(auto a : sumedFireMap){
            pair<int, int> pos = a.first;
            FireBall fireball = a.second;

            // divide
            if(fireball.sumedCount > 1) {
                fireball.divide();
            }
            // 질량이 0인 파이어볼은 소멸되어 없어진다.
            if(fireball.m == 0) continue;

            fireMap[a.first] = fireball;
        }
        sumedFireMap.clear();
    }

    int massSum = 0;
    for(auto a : fireMap){
        massSum += a.second.m * a.second.sumedCount;
    }

    cout << massSum;
    
    return 0;
}
```

# 다른 사람의 풀이
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

int n, m, k, dx[8] = {-1, -1, 0, 1, 1, 1, 0, -1}, dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};
queue<tuple<int, int, int, int, int>> q; // r, c, m, s, d
vector<tuple<int, int, int>> v[50][50]; // m, s, d

int main(){
    cin >> n >> m >> k;
    for(int i=0;i<m;i++){
        int r, c, m, s, d; cin >> r >> c >> m >> s >> d;
        q.push({r-1, c-1, m, s, d});
    }

    while(k--){
        while(!q.empty()){
            auto [r, c, m, s, d] = q.front(); q.pop();
            // 파이어볼 이동
            if(m) v[(r + dx[d] * s + 10000) % n][(c + dy[d] * s + 10000) % n].push_back({m, s, d});
        }

        for(int i=0;i<n;i++) for(int j=0;j<n;j++) if(!v[i][j].empty()){
            if(v[i][j].size() == 1){ // 한 개면 냅둠
                auto [m, s, d] = v[i][j][0];
                q.push({i, j, m, s, d});
                continue;
            }

            int M = 0, S = 0, D[2] = {0, 0};
            for(auto [m, s, d] : v[i][j]) M += m, S += s, D[d%2]++;
            for(int k=D[0]&&D[1];k<8;k+=2) q.push({i, j, M / 5, S / v[i][j].size(), k});
        }

        for(int i=0;i<n;i++) for(int j=0;j<n;j++) v[i][j].clear();
    }

    int ans = 0;
    while(!q.empty()) ans += get<2>(q.front()), q.pop();
    cout << ans;
}
```