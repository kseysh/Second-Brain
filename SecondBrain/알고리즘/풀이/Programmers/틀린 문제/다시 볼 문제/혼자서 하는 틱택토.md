## 답 본 풀이
```cpp
#include <string>
#include <vector>
using namespace std;

bool isWin(const vector<string>& board, char c) {
    for (int i = 0; i < 3; i++) {
        if (board[i][0] == c && board[i][1] == c && board[i][2] == c) return true; // row
        if (board[0][i] == c && board[1][i] == c && board[2][i] == c) return true; // col
    }
    if (board[0][0] == c && board[1][1] == c && board[2][2] == c) return true;
    if (board[0][2] == c && board[1][1] == c && board[2][0] == c) return true;
    return false;
}

int solution(vector<string> board) {
    int oCount = 0, xCount = 0;
    for (const auto& row : board) {
        for (char c : row) {
            if (c == 'O') oCount++;
            else if (c == 'X') xCount++;
        }
    }

    bool oWin = isWin(board, 'O');
    bool xWin = isWin(board, 'X');

    if (xCount > oCount) return 0; 
    if (oCount > xCount + 1) return 0;
    // oCount == xCount || oCount == xCount + 1 이어야 함
    if (oWin && xWin) return 0; // 둘 다 이기는 상황은 존재하지 않음
    if (oWin && oCount != xCount + 1) return 0; // o가 먼저 시작해야, o가 이길 수 있음
    if (xWin && oCount != xCount) return 0; // x가 먼저 시작해야, x가 이길 수 있음
    return 1;
}
```
## 틀린 이유
내 시도: 틱택토의 모든 과정을 해보려고 했음
단지, O,X의 개수, O,X중 하나가 이겼는지의 여부만을 이용해 풀 수 있는 문제였음

## 다시 푼 풀이
```cpp
#include <string>
#include <vector>
#include <cmath>

using namespace std;

int ocount = 0, xcount = 0;
int answer = 0;

char tb[3][3];

vector<pair<int, int>> opos; // y, x
vector<pair<int, int>> xpos; // y, x
char tmap[3][3];
bool isused[3][3];

bool isTerminate(){
    for(int i = 0; i < 3; i++){
        if(tmap[0][i] != '.'){
            if(tmap[0][i] == tmap[1][i] && tmap[1][i] == tmap[2][i]) return true; // 세로 체크
        }
        
        if(tmap[i][0] != '.'){
            if(tmap[i][0] == tmap[i][1] && tmap[i][1] == tmap[i][2]) return true; // 라로 체크
        }
    }
    
    if(tmap[1][1] != '.'){
        if(tmap[0][0] == tmap[1][1] && tmap[1][1] == tmap[2][2]) return true; // 대각선 체크
        if(tmap[0][2] == tmap[1][1] && tmap[1][1] == tmap[2][0]) return true; // 대각선 체크    
    }
    
    return false;
    
}

void simulation(int o, int x, bool isOTurn){
    if(ocount == o && xcount == x){
        answer = 1;
        debug();
        return;
    }
    if(isTerminate()) return; // 마지막이 아닌데 끝나면 return
    
    if(isOTurn){
        for(pair<int, int> p : opos){
            tmap[p.first][p.second]  = 'O';
            if(isused[p.first][p.second]) continue;
            isused[p.first][p.second] = true;
            simulation(o + 1, x, false);
            tmap[p.first][p.second]  = '.';
            isused[p.first][p.second] = false;
        }    
    }else{
        for(pair<int, int> p : xpos){
            tmap[p.first][p.second]  = 'X';
            if(isused[p.first][p.second]) continue;
            isused[p.first][p.second] = true;
            simulation(o, x + 1, true);
            tmap[p.first][p.second]  = '.';
            isused[p.first][p.second] = false;
        }
    }
}

int solution(vector<string> board) {
    
    for(int i = 0; i < 3; i++){
        for(int j = 0; j < 3; j++){
            if(board[i][j] == 'O'){
                ocount++;
                opos.push_back({i, j});
            }else if(board[i][j] == 'X'){
                xcount++;
                xpos.push_back({i, j});
            }
            tmap[i][j] = '.';
        }
    }
    
    if(ocount != xcount && ocount != xcount + 1) return 0;
    
    simulation(0, 0, true);
    
    return answer;
}
```