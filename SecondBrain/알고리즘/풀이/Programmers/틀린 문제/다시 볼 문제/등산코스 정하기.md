## 나의 풀이
```cpp
#include <string>
#include <vector>
#include <queue>
// #include <iostream>
#define MAX_N 50000
#define SUMMIT_IDX 0
#define MIN_INTENSITY_IDX 1
using namespace std;

vector<int> answer(2, 1e9);
bool isVisit[MAX_N + 1];
bool isSummit[MAX_N + 1];
vector<pair<int, int>> graph[MAX_N + 1]; // weight, node

void initIsVisit(int n, const vector<int> &gates, const vector<int> &summits){
    for(int i = 0; i <= n; i++){
        isVisit[i] = false;
    }
    
    for(int gate : gates){
        isVisit[gate] = true;
    }
}

vector<int> solution(int n, vector<vector<int>> paths, vector<int> gates, vector<int> summits) {
    
    for(const vector<int> &v : paths){
        graph[v[0]].push_back({v[2], v[1]});
        graph[v[1]].push_back({v[2], v[0]});
    }
    
    for(int summit : summits){
        isSummit[summit] = true;
    }
    
    for(int gate : gates){
        int maxWeight = 0;
        bool findSummit = false;
        initIsVisit(n, gates, summits);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; // weight, num 
        
        // 6, 7을 pq에 넣는다.
        for(const pair<int, int> &p : graph[gate]){ 
            if(isVisit[p.second]) continue; // gate와 연결된 곳이 gate면 간선 연결 X
            pq.push({p.first, p.second});    
        }
        
        while(!pq.empty()){
            pair<int, int> p = pq.top(); pq.pop();
            // cout << p.first << ' ' << p.second << "\n";
            if(answer[MIN_INTENSITY_IDX] < maxWeight) break;
            // if(findSummit && maxWeight < p.first) break;
            maxWeight = max(maxWeight, p.first);
            if(isVisit[p.second]) continue;
            isVisit[p.second] = true;
            
            if(isSummit[p.second]){ // 이 간선이 산봉우리와 연결된 간선이라면,
                isVisit[p.second] = true;
                if(answer[MIN_INTENSITY_IDX] > maxWeight || 
                   (answer[MIN_INTENSITY_IDX] == maxWeight && answer[SUMMIT_IDX] > p.second)){
                    answer[MIN_INTENSITY_IDX] = maxWeight;
                    answer[SUMMIT_IDX] = p.second;
                }
                findSummit = true;
            }else{
                for(const pair<int, int> &next : graph[p.second]){ // from과 연결된 모든 간선 집어넣음
                   if(isVisit[next.second]) continue;
                    pq.push({next.first, next.second});
                }    
            }
        }
    }
    return answer;
}
```
`if(answer[MIN_INTENSITY_IDX] < maxWeight) break;`
=> 이걸 적용해주지 못해서 시간 초과 발생.... 너무 아쉽다...
전체에서 최적화를 했어야 했는데 각 gate에서만 최적화를 진행했다.
`if(findSummit && maxWeight < p.first) break;`