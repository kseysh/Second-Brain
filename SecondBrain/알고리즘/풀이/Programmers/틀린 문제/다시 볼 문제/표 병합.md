## 나의 풀이
```cpp
#include <string>
#include <vector>
#include <sstream>
#define TABLE_LEN 50
#define EMPTY "EMPTY"
#define VALUES_LEN 3500
using namespace std;

vector<vector<int>> tvi(TABLE_LEN + 1, vector<int>(TABLE_LEN + 1)); // table value idx
bool isUsed[VALUES_LEN];
vector<string> values(VALUES_LEN, "EMPTY"); // 2500 + command 1000개
int valuesLastIdx = 2500; // 넣고 증가시키기
vector<string> answer;

int caculateIdx(int y, int x){
    return (y - 1) * TABLE_LEN + x - 1;
}

void update(int y, int x, const string &value){
    values[tvi[y][x]] = value;
}

void updateAll(const string &value1, const string &value2){
    for(int i = 0; i < VALUES_LEN; i++){
        if(isUsed[i]){ // 사용중인 것 중에서만 값을 변경
            if(values[i] == value1) values[i] = value2;
        }
    }
}

void merge(int y1, int x1, int y2, int x2){
    if(y1 == y2 && x1 == x2) return; // 같은 셀이면 무시

    int prevIdx1 = tvi[y1][x1];
    int prevIdx2 = tvi[y2][x2];

    isUsed[prevIdx1] = false;
    isUsed[prevIdx2] = false;

    string mergedValue = EMPTY;
    string value1 = values[prevIdx1];
    string value2 = values[prevIdx2];

    bool hasValue1 = (value1 == EMPTY) ? false : true;
    bool hasValue2 = (value2 == EMPTY) ? false : true;

    if(hasValue1){
        mergedValue = value1;
    }else if(hasValue2){
        mergedValue = value2;
    }else{
        mergedValue = EMPTY;
    }
    int mergedValueIdx = valuesLastIdx;
    valuesLastIdx++;

    for(int y = 1; y <= TABLE_LEN; y++){
        for(int x = 1; x <= TABLE_LEN; x++){
            if(tvi[y][x] == prevIdx1 || tvi[y][x] == prevIdx2){ // 병합되어 있는 모든 셀 찾아서 수정
                tvi[y][x] = mergedValueIdx;
            }
        }
    }

    isUsed[mergedValueIdx] = true;
    values[mergedValueIdx] = mergedValue;
}

void unmerge(int ty, int tx){
    int mergedIdx = tvi[ty][tx];
    isUsed[mergedIdx] = false; // 이제 안씀
    string mergedValue = values[mergedIdx];
    for(int y = 1; y <= TABLE_LEN; y++){
        for(int x = 1; x <= TABLE_LEN; x++){
            if(tvi[y][x] == mergedIdx){ // mergedIdx를 가지고 있던 모든 셀을 원래 idx로 돌림
                int originIdx = caculateIdx(y, x);
                tvi[y][x] = originIdx;
                isUsed[originIdx] = true;
                values[originIdx] = EMPTY; // 선택한 셀이 포함한 모든 셀은 프로그램 실행 초기의 상태로 돌아감
            }
        }
    }
    values[caculateIdx(ty, tx)] = mergedValue; // 선택했던 행만 값을 이어받음
}

void print(int y, int x){
    answer.push_back(values[tvi[y][x]]);
}

void init(){
    for(int y = 1; y <= TABLE_LEN; y++){
        for(int x = 1; x <= TABLE_LEN; x++){
            int idx = caculateIdx(y, x);
            isUsed[idx] = true;
            tvi[y][x] = idx;
        }
    }
}

vector<string> solution(vector<string> commands) {

    init();

    for(const string &command : commands){
        char c = command[1];
        if(c == 'E'){ // merge
            vector<string> v;
            string token;
            stringstream ss(command);
            while(ss >> token){
                v.push_back(token);
            }
            merge(stoi(v[1]), stoi(v[2]), stoi(v[3]), stoi(v[4]));
        }else if(c == 'N'){// unmerge
            vector<string> v;
            string token;
            stringstream ss(command);
            while(ss >> token){
                v.push_back(token);
            }
            unmerge(stoi(v[1]), stoi(v[2]));

        }else if(c == 'R'){ // print
            vector<string> v;
            string token;
            stringstream ss(command);
            while(ss >> token){
                v.push_back(token);
            }
            print(stoi(v[1]), stoi(v[2]));
        }else{ // update
            vector<string> v;
            string token;
            stringstream ss(command);
            while(ss >> token){
                v.push_back(token);
            }
            if(v.size() == 4){
                update(stoi(v[1]), stoi(v[2]), v[3]);
            }else{
                updateAll(v[1], v[2]);
            }
        }
    }

    return answer;
}
```
맞긴 맞았다..
## 다른 사람의 풀이
union find라고 합니다.

```cpp
#include <bits/stdc++.h>
using namespace std;

int uf[2501];
string val[2501];

int uf_find(int a) { 
	return uf[a] == -1 ? a : uf[a] = uf_find(uf[a]); 
}

bool uf_union(int a, int b) {
    int A = uf_find(a), B = uf_find(b);
    if (A == B) return false;
    uf[B] = A;
    if (val[A].empty() && val[B].size()) val[A] = val[B];
    else val[B] = val[A];
    return true;
}

vector<string> solution(vector<string> commands) {
    memset(uf, -1, sizeof(uf)); // EMPTY == -1
    vector<string> answer;
    for (string str : commands) {
        stringstream ss(str);

        string com; ss >> com;

        if (com == "UPDATE") {
            if (count(str.begin(), str.end(), ' ') == 3) {
                int r, c; string value;
                ss >> r >> c >> value;
                r--;c--;

                int pos = uf_find(r * 50 + c);
                val[pos] = value;
            } else {
                string val1, val2;
                ss >> val1 >> val2;

                for (int i = 0; i < 2500; i++) {
                    int pos = uf_find(i);
                    if (val[pos] == val1) val[pos] = val2;
                }
            }
        } else if (com == "MERGE") {
            int r1, c1, r2, c2;
            ss >> r1 >> c1 >> r2 >> c2;
            r1--; r2--; c1--; c2--;

            uf_union(r1 * 50 + c1, r2 * 50 + c2);
        } else if (com == "UNMERGE") {
            int r, c;
            ss >> r >> c;
            r--; c--;

            int x = uf_find(r * 50 + c);
            string tmp = val[x];

            for (int i = 0; i < 2500; i++) uf_find(i);
            for (int i = 0; i < 2500; i++) {
                if (uf_find(i) == x) {
                    val[i] = "";
                    uf[i] = -1;
                }
            }

            val[r * 50 + c] = tmp;
        } else {
            int r, c; ss >> r >> c;
            r--; c--;

            int pos = uf_find(r * 50 + c);
            if (val[pos].empty()) answer.push_back("EMPTY");
            else answer.push_back(val[pos]);
        }
    }
    return answer;
}
```