# 정답을 본 풀이
```cpp
#include <string>
#include <vector>

using namespace std;

const int MAX = 120 + 12;

// dp[a][b] : A의 누적 흔적이 a, B의 누적 흔적이 b인 상태 가능 여부
bool dp[MAX][MAX];

int solution(vector<vector<int>> info, int n, int m) {
    int itemCnt = info.size();
    dp[0][0] = true;

    for (int i = 0; i < itemCnt; i++) {
        bool nextDp[MAX][MAX] = {false};
        int traceA = info[i][0];
        int traceB = info[i][1];

        for (int a = 0; a < n; a++) {
            for (int b = 0; b < m; b++) {
                if (!dp[a][b]) continue;
                if (a + traceA < n) nextDp[a + traceA][b] = true;
                if (b + traceB < m) nextDp[a][b + traceB] = true;
            }
        }

        for (int a = 0; a < n; a++) {
            for (int b = 0; b < m; b++) {
                dp[a][b] = nextDp[a][b];
            }
        }
    }

    for (int a = 0; a < n; a++) {
        for (int b = 0; b < m; b++) {
            if (dp[a][b]) return a;
        }
    }

    return -1;
}

```
DP를 이용한 기본적인 풀이였다...

# 다시 푼 풀이
```cpp
#include <string>
#include <vector>

#define MAX_INFO_COUNT 40
#define MAX_N 120
#define EMPTY -1
using namespace std;

bool dp[MAX_INFO_COUNT + 1][MAX_N + 1][MAX_N + 1];

int solution(vector<vector<int>> infos, int n, int m) {
    
    int evidenceA = infos[0][0];
    int evidenceB = infos[0][1];
    if(evidenceA <= n) dp[0][evidenceA][0] = true;
    if(evidenceB <= m) dp[0][0][evidenceB] = true;
    
    for(int i = 1; i < infos.size(); i++){
        for(int j = 0; j < n; j++){
            for(int k = 0; k <= m; k++){
                if(!dp[i - 1][j][k]) continue;
                evidenceA = infos[i][0];
                evidenceB = infos[i][1];
                
                if(j + evidenceA < n) dp[i][j + evidenceA][k] = true;
                if(k + evidenceB < m) dp[i][j][k + evidenceB] = true;
            }
        }
    }
        
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            if(dp[infos.size() - 1][i][j]) return i;
        }
    }
    
    return -1;
}
```

# 다른 사람의 풀이
```cpp
#include <string>
#include <vector>

using namespace std;

int solution(vector<vector<int>> info, int n, int m) {
    int answer = 0;
    vector<vector<int>> knapsack = vector<vector<int>>(info.size() + 1, vector<int>(m));
    int sum_a = 0;

    for(int i = 0; i < info.size(); i++) {
        sum_a += info[i][0];
        for(int j = 0; j < m; j++) {
            knapsack[i + 1][j] = knapsack[i][j];
            if(j >= info[i][1])
                knapsack[i + 1][j] = max(knapsack[i + 1][j], knapsack[i][j - info[i][1]] + info[i][0]);
        }
    }

    answer = sum_a - knapsack[info.size()][m - 1];
    if(answer >= n)
        answer = -1;

    return answer;
}
```
나는 `bool dp[현재 몇 번째 물건을 훔치고 있는지][A의 누적 흔적][B의 누적 흔적] = 이 상황이 존재하는지`로 풀었는데, 
여기서는 `int knapsack[현재 몇 번째 물건을 훔치고 있는지][B의 누적 흔적] = A의 누적 흔적`으로 더 적은 메모리를 활용하였다.
bool은 이렇게 한 차원 더 적은 Vector를 사용한다는 점에 유의하자.

또한, 이 문제를 보고 knapsack 문제라는 것을 파악해야 한다.