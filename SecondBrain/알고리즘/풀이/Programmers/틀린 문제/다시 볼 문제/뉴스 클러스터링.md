# 나의 풀이
```cpp
#include <string>
#include <unordered_map>
using namespace std;

unordered_map<string, int> m1;
unordered_map<string, int> m2;
unordered_map<string, int> intersectm;
unordered_map<string, int> unionm;

string toLowerStr(const string &s){
    string result = "";
    for(char c : s){
        if(c <= 'Z' && c >= 'A') result += tolower(c);
        else result += c;
    }
    return result;
}

bool checkToken(string &s){
    for(char c : s){
        if(c < 'a' || c > 'z') return false;
    }
    return true;
}

void insertToMap(string s, unordered_map<string, int> &m){
    for(int i = 0; i < s.size()-1; i++){
        string token = s.substr(i, 2);
        if(!checkToken(token)) continue;
        if(m.find(token) == m.end()) m[token] = 1;
        else m[token]++;
    }
}

int getSimilarity(){
    for(auto node : m1){
        if(m2.find(node.first) != m2.end()){ // m2에도 같은 원소가 있었다면
            intersectm[node.first] = min(node.second, m2[node.first]); // 교집합에 최솟값
            unionm[node.first] = max(node.second, m2[node.first]); // 합집합에 최댓값
        }else{// 없으면 합집합에 값 넣음
            unionm[node.first] = node.second;  
        }
         
    }
    for(auto node : m2){
        if(m1.find(node.first) != m1.end()){
            intersectm[node.first] = min(node.second, m1[node.first]);
            unionm[node.first] = max(node.second, m1[node.first]);
        } else{
            unionm[node.first] = node.second;
        }
    }
    
    int intersectionCount = 0;
    int unionCount = 0;
    for(auto node : unionm){
        unionCount += node.second;
    }
    for(auto node : intersectm){
        intersectionCount += node.second;
    }
    if(unionCount == 0) return 65536;
    return (int)(((double)intersectionCount / unionCount) * 65536);
}

int solution(string str1, string str2) {
    str1 = toLowerStr(str1);
    str2 = toLowerStr(str2);
    
    insertToMap(str1, m1);
    insertToMap(str2, m2);
    
    return getSimilarity();
}
```

## 다른 사람의 풀이
```cpp
#include <bits/stdc++.h>
using namespace std;
short a, b, C[676], D[676];
int solution(string A, string B) {
    for(int i=1; i<A.size(); i++)
        if(isalpha(A[i-1]) && isalpha(A[i]))
            C[(A[i-1]&31)*26+(A[i]&31)]++;
    for(int i=1; i<B.size(); i++)
        if(isalpha(B[i-1]) && isalpha(B[i]))
            D[(B[i-1]&31)*26+(B[i]&31)]++;
    for(int i=0; i<676; i++) a+=min(C[i], D[i]), b+=max(C[i], D[i]);
    return b ? a*65536/b : 65536;
}
```
나는 unordered_map을 이용한 hash를 사용했지만, 이 사람은 두 글자라는 문제 특성을 이용해
`(A[i-1]&31)*26+(A[i]&31)`라는 방식으로 hashing을 구현했다.
이렇게 하면 나처럼 m1,m2를 둘 다 순회하며 모든 원소를 순회할 필요 없이 해시 범위인 0~65536을 순회하면서 더하기만 해주면 unionCount, intersectCount를 구할 수 있다.

char & 31을 하면, char가 대문자든 소문자든 같은 값을 반환하나 보다.
=> ASCII 코드에서 대문자와 소문자는 bit 6번째 자리만 다르므로 하위 5bit만 추출하여 연산한 방식을 사용한 것