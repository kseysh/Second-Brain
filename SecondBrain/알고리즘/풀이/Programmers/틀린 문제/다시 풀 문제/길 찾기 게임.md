못 푼 문제다.

## 다른 사람의 풀이
```cpp
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

struct tNode {
	tNode* l;
    tNode* r;
    int idx;
    int y;
    int x;

    bool operator<(const tNode& rhs) const {
        return y > rhs.y;
    }
};

void dfs(tNode* cur, vector<vector<int>>& answer, vector<tNode>& nodes) {
    if (cur == nullptr) return;

    answer[0].push_back(cur->idx); // 전위 순회는 상 좌 우 순이므로 먼저 기록
    dfs(cur->l, answer, nodes);
    dfs(cur->r, answer, nodes);
    answer[1].push_back(cur->idx); // 후위 순회는 좌 우 상 순이므로 마지막에 기록
}

vector<vector<int>> solution(vector<vector<int>> nodes) {
    vector<vector<int>> answer(2);

    vector<tNode> tNodes(nodes.size());
    for(int i = 0 ;i < nodes.size(); i++) {
        tNodes[i].idx = i + 1;
        tNodes[i].l = nullptr;
        tNodes[i].r = nullptr;
        tNodes[i].x = nodes[i][0];
        tNodes[i].y = nodes[i][1];
    }

    sort(tNodes.begin(), tNodes.end());
    auto& root = tNodes[0];
    for (int i = 1; i < tNodes.size(); i++) {
        auto& [l, r, idx, y, x] = tNodes[i];
        auto cur = &root; // 모든 노드를 루트부터 출발시켜서 자리를 찾는다.
        while(true) {
            if (cur->x > x) {
                if (cur->l == nullptr) { // 자리가 비어있다면 거기가 자리
                    cur->l = &tNodes[i];
                    break;
                }
                else {
                    cur = cur->l; // 이미 자식이 있으면 왼쪽으로 이동
                }
            } else {
                if (cur->r == nullptr) {
                    cur->r = &tNodes[i];
                    break;
                }
                else {
                    cur = cur->r;
                }
            }
        }
    }

    dfs(&tNodes[0], answer, tNodes);

    return answer;
}
```