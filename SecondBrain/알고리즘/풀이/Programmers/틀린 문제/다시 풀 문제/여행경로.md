## 다른 사람의 풀이
```cpp
#include <string>
#include <vector>

using namespace std;
int visited[1000000];
string ans_string = "a";

void dfs(vector<vector<string>> &tickets, string cur, string path, int depth) {
    if (depth == tickets.size()) {
        string p = path;
        if (path < ans_string) {
            ans_string = path;
        }
        return;
    }

    for (int i = 0; i < tickets.size(); i++) {
        if (cur == tickets[i][0] && !visited[i]) {
            visited[i] = 1;
            dfs(tickets, tickets[i][1], path + tickets[i][1], depth+1);
            visited[i] = 0;
        }
    }
}

vector<string> solution(vector<vector<string>> tickets) {
    vector<string> answer;
    dfs(tickets, "ICN", "ICN", 0);
    for (int i = 0; i < ans_string.size(); i+=3) {
        answer.push_back(ans_string.substr(i, 3));
    }
    return answer;
}
```
백트래킹과 dfs를 합한 형태로 풀이
```cpp
#include <string>
#include <vector>
#include <stack>
#include <algorithm>
using namespace std;

stack<string> st;

int DFS(vector<vector<string>> tickets, vector<bool>& visited, string start)
{
    for (int i = 0; i < tickets.size(); ++i)
    {
        if (!visited[i])
        {
            if (tickets[i][0] == start)
            {
                visited[i] = true;
                DFS(tickets, visited, tickets[i][1]);
                st.push(tickets[i][1]);
            }
        }
    }
    return 0;
}

bool compare(vector<string> a, vector<string> b)
{
    return a[1] < b[1];
}

vector<string> solution(vector<vector<string>> tickets) {
    vector<string> answer;
    vector<bool> visited;

    for (int i = 0; i < tickets.size(); ++i)
        visited.push_back(false);

    sort(tickets.begin(), tickets.end(), compare);

    DFS(tickets, visited, "ICN");

    answer.push_back("ICN");
    while(!st.empty())
    {
        answer.push_back(st.top());
        st.pop();
    }

    return answer;
}
```
주어진 항공권을 모두 사용할 수 있는 path만 주어진다는 사실을 가지고, compare 함수 정의 후 sorting한 후에 우선 순위가 높은 것 부터 탐색

## 다시 푼 풀이
```cpp
#include <string>
#include <vector>
#include <algorithm>
#include <unordered_map>

#define MAX_AIRPORT 10000

using namespace std;

unordered_map<string, int> m;
vector<string> airportName;
vector<pair<int, bool>> graph[MAX_AIRPORT + 1]; // id, isUsed
vector<string> answer;
int answerSize = 0;
void dfs(int sidx){
    int len = graph[sidx].size();
    for(int i = 0; i < len; i++){
        pair<int, bool> p = graph[sidx][i];
        if(p.second) continue;
        int nidx = p.first;
        graph[sidx][i] = {nidx, true};
        answer.push_back(airportName[nidx]);
        dfs(nidx);
        if(answerSize == answer.size()) return;
        graph[sidx][i] = {nidx, false};
        answer.pop_back();
    }
}

bool compare(pair<int, bool> a, pair<int, bool> b){
    return airportName[a.first] < airportName[b.first];
}

vector<string> solution(vector<vector<string>> tickets) {
    int airportNum = 0;
    m["ICN"] = airportNum++;
    airportName.push_back("ICN");
    for(vector<string> &ticket : tickets){
        if(m.find(ticket[0]) == m.end()){
            m[ticket[0]] = airportNum++;
            airportName.push_back({ticket[0], false});
        } 
        if(m.find(ticket[1]) == m.end()){
            m[ticket[1]] = airportNum++;  
            airportName.push_back(ticket[1]);
        } 
        graph[m[ticket[0]]].push_back({m[ticket[1]], false});
    }
    
    for(int i = 0; i < airportName.size(); i++){
        sort(graph[i].begin(), graph[i].end(), compare);
    }

    answer.push_back("ICN");
    answerSize = tickets.size() + 1;
    dfs(0);
    
    return answer;
}
```
시간 오래 걸림 & 한 번 틀림