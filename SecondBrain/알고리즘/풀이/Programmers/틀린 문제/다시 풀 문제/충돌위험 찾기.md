```cpp
#include <string>
#include <vector>
#include <unordered_map>
#include <map>
using namespace std;

unordered_map<int,pair<int,int>> pos; // 각 지점의 좌표를 저장하는 해시맵
vector<map<pair<int,int>,int>> path_count;
int answer;

void movePath(vector<int> &r){
    pair<int,int> target;
    int time = 0;
    for(int i = 0;i < r.size()-1;i++){
        pair<int,int> s = pos[r[i]];
        target = pos[r[i+1]];
        
        while(s!=target){
            path_count[time][s]++;
            if(path_count[time][s] == 2) answer++;
            int dy = s.first - target.first;
            int dx = s.second - target.second;
            
            if(dy!=0){
                if(dy>0)s.first--;
                else s.first++;
            }
            else if(dx!=0){
                if(dx>0)s.second--;
                else s.second++;
            }
            time++;
        }
    }
    // 도착
    path_count[time][target]++;
    if(path_count[time][target]==2)answer++;
}

int solution(vector<vector<int>> points, vector<vector<int>> routes) {
    for(int i = 0;i < points.size();i++){
        pos[i + 1] = {points[i][0], points[i][1]};
    }
    path_count.resize(20000); // 벡터 공간 미리 할당
    
    for(auto p:routes){
        movePath(p);
    }
    
    return answer;
}
```
## 나의 풀이
이 문제를 풀기 위해서는 두 가지 방법이 있다.
1. 1초당 모든 로봇을 한 번씩 움직임
2. 한 개의 로봇을 움직이면서, 몇초에 어디 있었는지 기록
나의 경우에 1의 방법을 사용하니 너무 복잡하였고, 한 개의 로봇을 움직이는 것이 더 쉬운 방법이었다.
또한, Vector의 resize를 이용해 벡터 공간을 할당한 것도 확인해보자

## 다시 푼 풀이

```cpp
#include <string>
#include <vector>

#define MAX_N 100
#define MAX_X 100
#define MAX_TIME 20000


using namespace std;

int m[MAX_TIME + 1][MAX_N + 1][MAX_N + 1];
int dy[4] = {0, -1, 0, 1};
int dx[4] = {1, 0, -1, 0};
// 우, 상, 좌, 하

int drawRoute(int sy, int sx, int ey, int ex, int time){
    int d = 0;
    
    if(sy > ey) d = 1;
    else d = 3;
    while(sy != ey){
        sy += dy[d];
        m[++time][sy][sx]++;
    }

    
    if(sx > ex) d = 2;
    else d = 0;    
    while(sx != ex){
        sx += dx[d];
        m[++time][sy][sx]++;
    }
    
    return time;
}

int solution(vector<vector<int>> points, vector<vector<int>> routes) {
    
    for(vector<int> &r : routes){
        int time = 0;
        m[time][points[r[0] - 1][0]][points[r[0] - 1][1]]++;
        for(int i = 1; i < r.size(); i++){
            int sy = points[r[i - 1] - 1][0];
            int sx = points[r[i - 1] - 1][1];

            int ey = points[r[i] - 1][0];
            int ex = points[r[i] - 1][1];    
            
            time = drawRoute(sy, sx, ey, ex, time);
        }
            
        
    }
    
    int answer = 0;
    for(int t = 0; t <= MAX_TIME; t++){
        for(int y = 1; y <= MAX_N; y++){
            for(int x = 1; x <= MAX_N; x++){
                if(m[t][y][x] >= 2) answer++;
            }
        }
    }
    
    return answer;
}
```
이전 풀이가 더 나은 풀이 같다.
`unordered_map<int,pair<int,int>> pos;` => 몇 번 로봇이 무슨 좌표에 있는지
`vector<map<pair<int,int>,int>> path_count;` => time에 몇번 좌표에 로봇이 몇개 있는지 확인