# 나의 풀이
```cpp
#include <string>
#include <vector>
#include <iostream>
using namespace std;

int lsx = 21, lsy = 21, lex = -1, ley = -1, n, m;
vector<vector<int>> gkey;
vector<vector<int>> lockSpace;
int lockSpaceY, lockSpaceX;

bool inRange(int y, int x){
    return y < m && x < m && y >= 0 && x >= 0;
}

bool check(int ksy, int ksx){
    // 기존 방향
    bool clear = true;
    if(inRange(ksy, ksx) && inRange(ksy + lockSpaceY - 1, ksx + lockSpaceX - 1)){
        for(int y = 0; y < lockSpaceY; y++){
            for(int x = 0; x < lockSpaceX; x++){
                if(gkey[y + ksy][x + ksx] == lockSpace[y][x]) clear = false;
            }
        }
    }else{
        clear = false;
    }
    if(clear) return true;
    
    // 90도 회전
    clear = true;
    if(inRange(ksy, ksx + lockSpaceY - 1) && inRange(ksy + lockSpaceX - 1, ksx)){
        for(int y = 0; y < lockSpaceY; y++){
            for(int x = 0; x < lockSpaceX; x++){
                if(gkey[ksy + x][ksx + lockSpaceY - 1 - y] == lockSpace[y][x]) clear = false;
            }
        }
    }else{
        clear = false;
    }
    if(clear) return true;

    // 90도 회전
    clear = true;
    if(inRange(ksy + lockSpaceY - 1, ksx + lockSpaceX - 1) && inRange(ksy, ksx)){
        for(int y = 0; y < lockSpaceY; y++){
            for(int x = 0; x < lockSpaceX; x++){
                if(gkey[ksy + lockSpaceY - 1 - y][ksx + lockSpaceX - 1 - x] == lockSpace[y][x]) clear = false;
            }
        }
    }else{
        clear = false;
    }
    if(clear) return true;
    
    // 90도 회전
    clear = true;
    if(inRange(ksy + lockSpaceX - 1, ksx) && inRange(ksy, ksx + lockSpaceY - 1)){
        for(int y = 0; y < lockSpaceY; y++){
            for(int x = 0; x < lockSpaceX; x++){
                if(gkey[ksy + lockSpaceX - 1 - x][ksx + y] == lockSpace[y][x]) clear = false;
            }
        }
    }else{
        clear = false;
    }
    return clear;
}

bool solution(vector<vector<int>> key, vector<vector<int>> lock) {
    m = key.size();
    n = lock.size();
    gkey = key;
    
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            if(lock[i][j] == 0){
                lsy = min(lsy, i);
                ley = max(ley, i);
                lsx = min(lsx, j);
                lex = max(lex, j);
            }
        }
    }
    
    
    lockSpaceY = ley - lsy + 1;
    lockSpaceX = lex - lsx + 1;
    if(lockSpaceY < 0) return true;
    lockSpace = vector<vector<int>>(lockSpaceY, vector<int>(lockSpaceX));
    
    for(int y = 0; y < lockSpaceY; y++){
        for(int x = 0; x < lockSpaceX; x++){
            if(lock[y + lsy][x + lsx] == 0){
                lockSpace[y][x] = 0;
            }else{
                lockSpace[y][x] = 1;
            }
        }
    }
    
    
    for(int i = 0; i < m; i++){
        for(int j = 0; j < m; j++){
            if(check(i, j)) return true;
        }
    }
    
    return false;
}
```
풀었지만, 너무 오래걸렸다.
홈이 없는 경우를 간과하여 첫 제출시 틀렸다.

# 다른 사람의 풀이
```cpp
#include <vector>
#include <string>
#include <iostream>

using namespace std;


void rotate(vector<vector<int>>& mat) {
    int N = mat.size();
    for (int x = 0; x < N / 2; x++) {
        for (int y = x; y < N - x - 1; y++) {
            int temp = mat[x][y];
            mat[x][y] = mat[y][N - 1 - x];
            mat[y][N - 1 - x] = mat[N - 1 - x][N - 1 - y];
            mat[N - 1 - x][N - 1 - y] = mat[N - 1 - y][x];
            mat[N - 1 - y][x] = temp;
        }
    }
}

bool solution(vector<vector<int>> key, vector<vector<int>> lock) {
    int N = key.size();
    int M = lock.size();
    vector<vector<int>> paper(M + (N - 1) * 2, vector<int>(M + (N - 1) * 2, 0));
    int size = N + M - 1;
    for (int i = N - 1; i < size; i++) 
        for (int j = N - 1; j < size; j++) 
            paper[i][j] = lock[i - (N - 1)][j - (N - 1)];
    for (int rot = 0; rot < 4; rot++) {
        rotate(key);
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                vector<vector<int>> tmp(paper);
                for (int x = 0; x < N; x++) {
                    for (int y = 0; y < N; y++) {
                        tmp[i + x][j + y] += key[x][y];
                    }
                }
                int flag = 0;
                for (int x = N - 1; x < size; x++) {
                    for (int y = N - 1; y < size; y++) {
                        if (tmp[x][y] != 1) {
                            flag = 1;
                            break;
                        }
                    }
                    if (flag) break;
                }
                if (!flag) return true;
            }
        }
    }
    return false;
}

```