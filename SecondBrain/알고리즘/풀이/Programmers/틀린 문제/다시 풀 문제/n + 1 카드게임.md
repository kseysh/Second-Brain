## 다른 사람의 풀이
```cpp
#include<bits/stdc++.h>
using namespace std;

int solution(int coin, vector<int> cards) {
    int n = cards.size();
    vector<bool> have(1000); // 현재 내가 가지고 있는 카드 표시
    vector<bool> buy(1000); // 뽑아서 가질 수 있는 카드 후보
    int zero=0; // 지금 바로 낼 수 있는 완성된 쌍의 개수
    int one=0; // 동전 하나 내고 쌍 완성 가능
    int two=0;  // 동전 두 개 내고 쌍 완성 가능
    int ans = 1; // 진행된 라운드 수
    for(int i=0;i<n/3;i++){ // 처음에 n/3장의 카드를 가짐
        int x = cards[i];
        have[x] = true;
        if(have[x] && have[n+1-x]){ // 이미 짝이 맞는 카드가 있다면
	        zero++; 
	        have[x] = false;
	        have[n+1-x] = false
        }
    }
    for(int i=n/3;i<n;i+=2){
        int a=cards[i],b=cards[i+1];
        buy[a] = true;
        buy[b] = true;
        // 매 라운드마다 카드 2장을 뽑고, 이는 가질 수 있는 카드에 들어감
        
        // 뽑은 카드가 현재 손에 있는 카드와 짝이 되는 경우 => 동전 하나로 라운드 통과
        if(buy[a]&&have[n+1-a]){ 
	        one++;
	        buy[a] = false;
	        have[n+1-a] = false;
        }
        if(buy[b]&&have[n+1-b]){
	        one++;
	        buy[b] = false;
			have[n+1-b] = false;
        }
        
        // 뽑은 카드끼리 서로 짝이 맞는 경우 => 동전 두개로 라운드 통과
        if(buy[a]&&buy[n+1-a]){
	        two++;
	        buy[a] = false;
			buy[n+1-a] = false;
        }
        if(buy[b]&&buy[n+1-b]){
	        two++;
	        buy[b] = false;
	        buy[n+1-b] = false;
        }
        
        // 라운드 진행
        // 그리디 => 가장 적은 비용으로 한 라운드를 더 늘릴 수 있는 조합부터 사용한다.
        if(zero){ // 동전 낼게 없음
	        zero--;
	        ans++;
        } else if(one&&coin){ // 동전 하나 내면 진행할 수 있고 코인도 있음
	        coin--;
	        one--;
	        ans++;
        } else if(two && coin >= 2){ // 22
	        coin-=2;
	        two--;
	        ans++;
        } else break; // 불가능하면 종료
    }
    return ans;
}
```
그리디일 것이라고는 판단했으나...


