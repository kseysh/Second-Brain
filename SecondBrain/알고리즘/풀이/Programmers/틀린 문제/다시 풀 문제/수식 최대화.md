## 나의 풀이
```cpp
#include <string>
#include <vector>
#include <list>
#include <iostream>
using namespace std;

list<long long> num;
list<long long> tnum;
list<char> op;
list<char> top;

void caculate(char oper){
    list<char>::iterator topit = top.begin();
    list<long long>::iterator tnumit = tnum.begin();
    
    while(topit != top.end()){
        if (*topit == oper) {
            // 1. 현재 숫자와 다음 숫자를 가져와 곱셈 결과를 계산합니다.
            long long current_num = *tnumit;
            long long next_num = *next(tnumit, 1);
            long long result;
            if(oper == '*'){
                result = current_num * next_num;;
            }else if(oper == '+'){
                result = current_num + next_num;
            }else{
                result = current_num - next_num;
            }
            

            // 2. 두 숫자를 list에서 삭제합니다.
            // 첫 번째 숫자를 삭제하고, tnumit은 다음 숫자를 가리키도록 업데이트합니다.
            tnumit = tnum.erase(tnumit); 
            // 이제 tnumit이 가리키는 두 번째 숫자를 삭제하고, 그 다음 위치를 가리키도록 업데이트합니다.
            tnumit = tnum.erase(tnumit);

            // 3. 삭제된 위치에 계산 결과를 삽입합니다.
            tnum.insert(tnumit, result);
            tnumit = prev(tnumit, 1);

            // 4. 사용된 '*' 연산자를 삭제하고, topit은 다음 연산자를 가리키도록 업데이트합니다.
            topit = top.erase(topit);

        } else {
            // '*'가 아닐 경우, 다음 원소를 확인하기 위해 반복자를 한 칸씩만 이동합니다.
            topit++;
            tnumit++;
        }
    }
}

long long solution(string expression) {
    int sidx = 0;
    
    for(int i = 0; i < expression.size(); i++){
        if(expression[i] > '9' || expression[i] < '0'){ // 표현식이 기호라면
            op.push_back(expression[i]);
            num.push_back(stoi(expression.substr(sidx, i - sidx)));
            sidx = i + 1;
        }
    }
    num.push_back(stoi(expression.substr(sidx)));
    
    long long answer = 0;
    
    // * > + > - 
    tnum = list<long long>(num);
    top = list<char>(op);
    caculate('*');
    caculate('+');
    caculate('-');
    answer = max(answer, abs(*tnum.begin()));
    // * > - > +
    tnum = list<long long>(num);
    top = list<char>(op);
    caculate('*');
    caculate('-');
    caculate('+');
    answer = max(answer, abs(*tnum.begin()));
    // + > * > -
    tnum = list<long long>(num);
    top = list<char>(op);
    caculate('+');
    caculate('*');
    caculate('-');
    answer = max(answer, abs(*tnum.begin()));
    // + > - > *
    tnum = list<long long>(num);
    top = list<char>(op);
    caculate('+');
    caculate('-');
    caculate('*');
    answer = max(answer, abs(*tnum.begin()));
    // - > + > *
    tnum = list<long long>(num);
    top = list<char>(op);
    caculate('-');
    caculate('+');
    caculate('*');
    answer = max(answer, abs(*tnum.begin()));
    // - > * > +
    tnum = list<long long>(num);
    top = list<char>(op);
    caculate('-');
    caculate('*');
    caculate('+');
    answer = max(answer, abs(*tnum.begin()));
    return answer;
}
```
푸는게 오래걸렸고, 수식이 너무 더럽다.

## 다른 사람의 풀이
```cpp
#include <string>
#include <vector>
#include <cmath>

using namespace std;

long long solution(string expression) {
    long long answer = 0;
    vector<long long> nums;
    vector<char> op;

    int idx = 0;
    for(int i=0;i<expression.size();i++){
        char ch = expression[i];
        if(ch == '*' | ch == '+' | ch == '-'){
            op.push_back(ch);
            nums.push_back(stoi(expression.substr(idx,i-idx)));
            idx = i+1;
        }else if(i == expression.size()-1){
            nums.push_back(stoi(expression.substr(idx,i-idx+1)));
        }
    }

    string prior[6] = {
        "*+-", "*-+",
        "+*-", "+-*", 
        "-*+", "-+*",
    };

    for(int i=0;i<6;i++){
        vector<long long> temp_nums = nums;
        vector<char> temp_op = op;
        string pr = prior[i];
        for(int j=0;j<3;j++){
            for(int k=0;k<temp_op.size();k++){
                if(pr[j] == temp_op[k]){
                    if(pr[j] == '*'){
                        temp_nums[k] = temp_nums[k]*temp_nums[k+1];
                        temp_nums.erase(temp_nums.begin()+k+1);
                    }else if(pr[j] == '+'){
                        temp_nums[k] = temp_nums[k]+temp_nums[k+1];
                        temp_nums.erase(temp_nums.begin()+k+1);
                    }else if(pr[j] == '-'){
                        temp_nums[k] = temp_nums[k]-temp_nums[k+1];
                        temp_nums.erase(temp_nums.begin()+k+1);
                    }
                    temp_op.erase(temp_op.begin()+k--);
                }
            }
        }
        answer = max(answer, abs(temp_nums[0]));
    }

    return answer;
}
```
string prior를 활용하여 나처럼 코드를 쓸데없이 풀지 않음
나는 vector의 erase함수가 오버헤드가 클 것이라 생각해서 이렇게 풀었는데 안 그래도 되었다보다.