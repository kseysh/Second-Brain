
## 다른 사람의 풀이
```java
class Solution
{   
    public int solution(int[][] board) {
        int answer = 0;

        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                if (board[i][j] > 0) {
                    // 위 , 좌 , 좌측 대각선 값을 찾아 그중 최소값 + 1 로 업데이트
                    int up = (j - 1 >= 0) ? board[i][j - 1] : 0;
                    int left = (i - 1 >= 0) ? board[i - 1][j] : 0;
                    int diagonal = (i - 1 >= 0 && j - 1 >= 0) ? board[i - 1][j - 1] : 0;

                    board[i][j] = Math.min(Math.min(up, left), diagonal) + 1;

                    answer = Math.max(answer, board[i][j]); // 최대값을 업데이트
                }
            }
        }

        return answer * answer;
    }
}
```
자신이 1일 때, 왼쪽, 위쪽, 왼쪽 위 대각선이 모두 1이면, 총 길이가 2

1 1 1
1 2 2
1 2 3
이런식으로 크기를 판별한다.. ㄷㄷ

## 나의 풀이
```java
class Solution{
    
    public int yLen, xLen;
    public int[][] boardSum;
    
    public boolean canMakeRectangle(int len, int y, int x){
        int ty = y + len - 1;
        int tx = x + len - 1;
        if(ty >= yLen || tx >= xLen) return false;
        
        if(y == 0 && x == 0) return boardSum[ty][tx] == len * len;
        if(y == 0) return boardSum[ty][tx] - boardSum[ty][x - 1] == len * len;
        if(x == 0) return boardSum[ty][tx] - boardSum[y - 1][tx] == len * len;
        return len * len == boardSum[ty][tx] - boardSum[y - 1][tx] - boardSum[ty][x - 1] + boardSum[y - 1][x - 1];
    }
    
    public int checkMaxLen(int maxLen, int y, int x){ // maxLen보다 큰 정사각형이 존재하면 반환
        boolean flag = false;
        while(canMakeRectangle(++maxLen, y, x)){
            flag = true;
        }
        if(flag) return maxLen - 1;
        return -1;
    }
    
    public void initBoardSum(int[][] board){
        yLen = board.length;
        xLen = board[0].length;
        boardSum = new int[yLen][xLen];
        
        for(int i = 0; i < yLen; i++){
            for(int j = 0; j < xLen; j++){
                boardSum[i][j] += board[i][j];
                if(i + 1 < yLen && j + 1 < xLen){
                    boardSum[i][j + 1] += boardSum[i][j];
                    boardSum[i + 1][j] += boardSum[i][j];
                    boardSum[i + 1][j + 1] -= boardSum[i][j];
                }else if(i + 1 < yLen){
                    boardSum[i + 1][j] += boardSum[i][j];
                }else if(j + 1 < xLen){
                    boardSum[i][j + 1] += boardSum[i][j];
                }
            }
        }
    }
    
    public int solution(int[][] board) {
        initBoardSum(board);
        
        int maxLen = 0;
        for(int y = 0; y < yLen; y++){
            for(int x = 0; x < xLen; x++){
                if(board[y][x] == 0) continue;
                int value = checkMaxLen(maxLen, y, x);
                maxLen = Math.max(maxLen, value);
            }
        }
        
        return maxLen * maxLen;
    }
}
```
풀이법은 바로 생각했는데 누적합을 아직도 제대로 구현하지 못함... 
구현력이 아직 떨어지는 듯