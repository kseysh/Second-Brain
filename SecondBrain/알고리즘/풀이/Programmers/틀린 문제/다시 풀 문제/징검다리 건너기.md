```cpp
#include <bits/stdc++.h>
using namespace std;
multiset <int> s;

int solution(vector<int> a,int k) {
    int ans = 1e9;
    for(int i = 0;i < k-1;i++) {
       s.insert(a[i]);
    }
    for(int i = k-1;i < a.size();i++) {
       s.insert(a[i]);
       auto it = s.end(); --it; // 최댓값 찾기
       ans = min(ans,*it);
       s.erase(s.find(a[i-(k-1)])); // 윈도우에서 벗어난 원소 삭제
    }
    return ans;
}
```
슬라이딩 윈도우를 이용해서 뛸 수 있는 범위를 정해놓고, 최솟값을 찾아 구함;;


## 다시 풀어서 틀린 풀이
```cpp
#include <string>
#include <vector>
#include <climits>
using namespace std;

int solution(vector<int> stones, int k) {
    
    int answer = INT_MAX;
    
    for(int i = 0; i <= stones.size() - k; i++){
        int maxValue = 0;
        int maxIdx = -1;
        for(int j = 0; j < k; j++){
            if(maxValue < stones[i + j]){
                maxValue = stones[i + j];
                maxIdx = i + j;
            }
        }
        i = maxIdx;
        answer = min(answer, maxValue);
    }
    
    
    return answer;
}
```
이 풀이는 정답 풀이와 다르게 max 값을 구하기 위해 for문을 이용해 O(n)의 시간 복잡도로 풀어야했던 문제입니다.
하지만, 정답 풀이에서는 multiset을 활용해 최솟값, 최댓값을 더 빠른 시간 복잡도로 구할 수 있도록했습니다.

multiset은 보통 RB tree로 구현된다.
여기서 priority_queue가 아닌 multiset을 활용한 이유는 priority_queue는 루트 원소만 정렬을 보장하기 때문에 임의 원소를 탐색하기 어렵다.
하지만, multiset의 경우 모든 원소를 정렬하므로 임의의 원소를 삭제하기가 용이한 장점이 있다.