# 다른 사람의 풀이
```cpp
#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>

using namespace std;

vector<int> solution(vector<string> gems) {
    int n = gems.size();
    if (n == 0) return {0, 0};

    // 서로 다른 보석 종류 수
    unordered_set<string> kinds(gems.begin(), gems.end());
    int K = (int)kinds.size();

    unordered_map<string, int> cnt; // 현재 윈도우 내 빈도
    int l = 0;
    int bestL = 0, bestR = n - 1;
    int bestLen = n; // (right - left) 기준: 차이가 작을수록 좋음

    for (int r = 0; r < n; ++r) {
        cnt[gems[r]]++;

        // 현재 윈도우가 모든 종류를 포함하면 왼쪽을 줄여본다
        while ((int)cnt.size() == K && l <= r) {
            // 길이 비교: (r - l) 이 작으면 갱신
            if (r - l < bestLen) {
                bestLen = r - l;
                bestL = l;
                bestR = r;
            }
            // 왼쪽 줄이기
            
            if (cnt[gems[l]] == 1) break;
            cnt[gems[l]]--;
            ++l;
        }
    }

    return { bestL + 1, bestR + 1 };
}

```

```cpp
#include <string>
#include <vector>
#include <set>
#include <unordered_map>

using namespace std;

vector<int> solution(vector<string> gems) {
    vector<int> answer;
    set<string> gems_kinds;
    unordered_map<string, int> current_gems;

    // 시작 위치
    int start_gems_pos = 0;
    // 찾은 보석들의 최소 길이
    int min = gems.size();

    for (int i = 0; i < gems.size(); i++) {
        gems_kinds.insert(gems[i]);
    }
    int gemTypeCount = gems_kinds.size();

    for (int i = 0; i < gems.size(); i++) {
        // 현재 젬을 추가해 current_gems에 업데이트 해줌
        current_gems[gems[i]]++;

        // current set에 모두 다 있는 경우 - gems_pos에 시작 점을 적음
        if (current_gems.size() == gemTypeCount) {
            // 스타트 포지션에 있는 보석이 map 크기가 2이상인 경우 map크기 1 줄인 후 스타트 포지션을 올려줌 1이면 탈출
            while (current_gems[gems[start_gems_pos]] > 1) {
                current_gems[gems[start_gems_pos]]--;
                start_gems_pos++;
            }

            // 최소 범위로 들어가 있는 경우 현재까지 발견된 최소 길이와 비교함
            if (i - start_gems_pos < min) {
                min = i - start_gems_pos;
                answer = { start_gems_pos + 1, i + 1 };
            }
        }
    }

    return answer;
}
```

## 내가 접근했던 방식
나는 보석을 다 넣어두고 하나씩 빼려고 하는 접근을 택했었다.
만약, 보석을 다 가지지 못하는 상황은 제외할 수 있도록
하지만 이 방식은 다 빼고 나서 다시 원점으로 되돌려둬야 하는 문제가 있어 복잡해지고 시간 복잡도도 오래 걸린다.