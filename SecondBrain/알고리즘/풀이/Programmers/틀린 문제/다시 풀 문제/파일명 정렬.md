# 나의 풀이
```cpp
#include <string>
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

struct file{
    string head;
    int number;
    int idx;
    
    file(string h, int n, int i){
        this->head = h;
        this->number = n;
        this->idx = i;
    }
    
    bool operator < (const file &f) const {
        if(this->head < f.head){
            return true;
        }else if(this->head > f.head){
            return false;
        }

        if(this->number < f.number){
            return true;
        }else if(this->number > f.number){
            return false;
        }

        if(this->idx < f.idx){
            return true;
        }
        return false;
    }
    
};

vector<file> f;
vector<string> answer;

bool isnum(char c){
    return c >= '0' && c <= '9';
}

pair<string, string> getHeadAndNumber(string s){
    pair<string, string> result;
    int startNumberIdx = 0;
    for(int i = 0; i < s.size(); i++){
        if(startNumberIdx != 0){ // head는 찾음
            if(!isnum(s[i])){ // 문자가 나오면 stop
                result.second = s.substr(startNumberIdx, i - startNumberIdx);
                return result;
            }
        }else{ // head 못 찾음
            if(isnum(s[i])){ // 문자가 안나오면 stop
                startNumberIdx = i;
                result.first = s.substr(0, startNumberIdx);
            }
        }
    }
    result.second = s.substr(startNumberIdx);
    return result;
}

string convertHead(string s){
    string result = "";
    for(char c : s){
        if(c >= 'A' && c <= 'Z') result += tolower(c);
        else result += c;
    }
    return result;
}

vector<string> solution(vector<string> files) {
    for(int i = 0; i < files.size(); i++){
        pair<string, string> headAndNumber = getHeadAndNumber(files[i]);
        string head = convertHead(headAndNumber.first);

        int number = stoi(headAndNumber.second);
        
        f.push_back(file(head, number, i));
    }
    sort(f.begin(), f.end());
    
    for(auto ff : f){
        answer.push_back(files[ff.idx]);
    }
    
    return answer;
}
```
## 틀린 점
연산자 오버로딩 하는 법은 제대로 알지 못함


```cpp
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <cctype>
using namespace std;

int findNumIdx(const string &str)
{
    int i;
    for (i = 0; i < str.length(); i++)
    {
        if (str[i] >= '0' && str[i] <= '9')
            break;
    }
    return i;
}
int getNumber(string str)
{
    return std::stoi(str.substr( findNumIdx(str) ));
}
string getHeader(string str)
{
    string rtn = str.substr(0, findNumIdx(str));

    std::transform(rtn.begin(), rtn.end(), rtn.begin(), tolower);

    return rtn;
}

bool numComp(string str1, string str2) { return getNumber(str1) < getNumber(str2); }
bool headComp(string str1, string str2) { return getHeader(str1).compare(getHeader(str2)) < 0; }

vector<string> solution(vector<string> files)
{   
    std::stable_sort(files.begin(), files.end(), numComp);

    std::stable_sort(files.begin(), files.end(), headComp);

    return files;
}
```
stable_sort를 활용하였다.
