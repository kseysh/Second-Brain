## 나의 풀이 (틀림)
```cpp
#include <string>
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

int maxWinCount;
vector<int> answer;
vector<vector<int>> dice;
vector<int> selectedDices;
vector<int> unselectedDices;
int sds;
int winCount = 0;

void chooseUnselectedDices(int sscore){ // 여기서 결국 해결하지 못함
    int uscore = 0;
    
    for(int i = 0; i < 6; i++){
        uscore += dice[unselectedDices[0]][i];
        for(int j = 0; j < 6; j++){
            if(sds < 2) continue;
            uscore += dice[unselectedDices[1]][j];
            for(int k = 0; k < 6; k++){
                if(sds < 3) continue;
                uscore += dice[unselectedDices[2]][k];
                for(int ii = 0; ii < 6; ii++){
                    if(sds < 4) continue;
                    uscore += dice[unselectedDices[3]][ii];
                    for(int jj = 0; jj < 6; jj++){
                        if(sds < 5) continue;
                        uscore += dice[unselectedDices[4]][jj];
                        if(sscore > uscore) winCount++;
                        uscore -= dice[unselectedDices[4]][jj];
                    }
                    uscore -= dice[unselectedDices[3]][ii];    
                }
                uscore -= dice[unselectedDices[2]][k];    
            }
            uscore -= dice[unselectedDices[1]][j];    
        }
        uscore -= dice[unselectedDices[0]][i];    
    }
}

void chooseSelectedDices(int count, int sscore){
    for(int sdi = 0; sdi < 6; sdi++){
        if(count + 1 == sds){
            chooseUnselectedDices(sscore + dice[selectedDices[count]][sdi]);
        }else{
            chooseSelectedDices(count + 1, sscore + dice[selectedDices[count]][sdi]);    
        }
    }
    return;
}

void caculateWinRate(){
    winCount = 0;
    chooseSelectedDices(0, 0);
    if(maxWinCount < winCount){
        maxWinCount = winCount;
        for(int i = 0; i < sds; i++){
            answer[i] = selectedDices[i] + 1;
        }
    }
}

void fillUnselectedDices(){
    int sdi = 0;
    int udi = 0;
    for(int i = 0; i < dice.size(); i++){
        if(selectedDices[sdi] == i){
            sdi++;
        }else{
            unselectedDices[udi] = i;
            udi++;    
        }
    }
}

void game(){ // 주사위 절반을 고른다.
    if(selectedDices.size() == sds){
        fillUnselectedDices();
        caculateWinRate();  
        return;
    }
    
    for(int i = 0; i < dice.size(); i++){
        if(selectedDices.size() >= 1 && selectedDices[selectedDices.size() - 1] >= i) continue;
        selectedDices.push_back(i);
        game();
        selectedDices.pop_back();
    }
}

vector<int> solution(vector<vector<int>> d) {
    dice = d;
    
    for(vector<int> &dd : dice){
        sort(dd.begin(), dd.end(), greater<>());
    }

    sds = d.size() / 2;
    unselectedDices = vector<int>(sds, 0);
    answer = vector<int>(sds, 0);
    game();
    
    sort(answer.begin(), answer.end());
    return answer;
}
```
어이없게도 시간 복잡도 계산을 잘못함...

## 다른 사람의 풀이
```cpp
#include <vector>
#include <map>
#include <algorithm>
#include <cmath>

using namespace std;

long long GetWinCount(const vector<int> &a, const vector<int> &b, const vector<vector<int>> &dice)
{
    long long size = pow(6, a.size()); // 모든 경우의 수 생성
    long long winCount = 0;
    map<long long, long long> anum, bnum;   //num[n] : a/b의 주사위의 합이 n이 나오는 경우의 수
    for(long long i = 0; i<size; i++) {// i를 6진법으로 계산했을 때, 각 자릿수는 각 주사위의 눈의 순번 번호이다.
        long long asum = 0;
        long long bsum = 0;
        for(long long j = 1, k = 0; k < a.size(); j*=6, k++) {
	        // A와 B의 주사위 눈의 합을 저장해둔다.
            asum += dice[a[k]-1][(i/j)%6];
            bsum += dice[b[k]-1][(i/j)%6];
        }
        anum[asum]++;
        bnum[bsum]++;
    }
    for(const auto &[an, ac] : anum) // an: a의 주사위 합, ac: an이 나오는 겨
    {
        for(const auto &[bn, bc] : bnum)
        {
            if(an <= bn)
                break;
            winCount += ac*bc;
        }
    }
    return winCount;
}

vector<int> solution(vector<vector<int>> dice) {
    vector<int> own(dice.size(), 1);    //주사위별 소유 플레이어. 0은 A, 1은 B의 소유
    for(int i = 0;i<dice.size()/2;i++) own[i] = 0;

    long long max_win_count = 0;
    vector<int> answer;
    do
    {
        vector<int> a, b;
        for(int i = 0;i<own.size();i++)
        {
            if(own[i] == 0)
                a.push_back(i+1);
            else
                b.push_back(i+1);
        }
        long long wc = GetWinCount(a, b, dice);
        if(wc > max_win_count)
        {
            max_win_count = wc;
            answer = a;
        }
    }while(next_permutation(own.begin(), own.end()));
    return answer;
}
```