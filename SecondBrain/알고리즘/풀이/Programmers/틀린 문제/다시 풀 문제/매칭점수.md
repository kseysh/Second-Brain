# 다른 사람의 풀이
```cpp
#include <string>
#include <vector>
#include <iostream>
#include <set>
#include <unordered_map>

using namespace std;

char ifUpperSwapLower(char c) {
    return 'A' <= c && c <= 'Z' ? c - 'A' + 'a' : c;
}

int solution(string word, vector<string> pages) {

    // word 소문자로 치환
    for (int i = 0; i < word.size(); i++) {
        word[i] = ifUpperSwapLower(word[i]);
    }

    int N = pages.size();
    unordered_map<string, int> linkAndWebIndexMap; // 링크, web 인덱스
    vector<pair<int, vector<string>>> web(N, { 0, vector<string>() }); //(기본 점수, 링크 리스트 )
    for (int i = 0; i < N; i++) {
        string html = pages[i];
        int j = 0;

        /*
         * head - 내부링크 찾기
         */

        string nowLink = "";
        int ind = 0;
        while (nowLink == "") {
            // <meta ~ 시작 인덱스 찾기
            ind = html.find("<meta") + 5; // <meta 다음부터 찾기 위해 5를 더함
            int last = html.substr(ind).find(">"); // 가장 먼저 나오는 >를 찾음
            html = html.substr(ind);
            ind = html.find("https://");
            if (last < ind) // meta 안에 들어있는 https가 아니면 패스
                continue;
            while (html[ind] != '\"') { // https부터 "가 나올 때까지 nowLink에 추가
                nowLink += html[ind++];
            }
            linkAndWebIndexMap[nowLink] = i;
        }

        //body 찾기
        int startBodyInd = html.find("<body>") + 6;
        int lastBodyInd = html.find("</body>");

        // 기본 점수 구하기
        string tmp = "";
        bool nowInBracket = false; // 태그 내부에 있는지
        for (int j = startBodyInd; j < lastBodyInd; j++) {
            char nowC = ifUpperSwapLower(html[j]);
            if (nowInBracket) { // 태그 내부에 있으면 pass
                if (nowC == '>') nowInBracket = false; // 태그 내부에서 >를 만나면 끝남
            } else if (nowC == ' ' || !('a'<=nowC && nowC <= 'z')) { // 띄어쓰기 또는 기호 => 모두 띄어쓰기라고 생각
                if(tmp == word) web[i].first++; // 기본 점수 추가
                tmp = "";
                if (nowC == '<') nowInBracket = true;
            }
            else { // 영문자면 tmp에 추가
                tmp += nowC;
            }
        }
        if (tmp == word) web[i].first++; // 기본 점수 추가


        // 링크 점수 구하기
        tmp = html.substr(startBodyInd);
        ind = tmp.find("<a href"); 
        while (ind != string::npos) { // find 함수는 못 찾을 시 npos를 반환
            tmp = tmp.substr(ind + 7);
            tmp = tmp.substr(tmp.find("https://"));
            web[i].second.push_back(tmp.substr(0, tmp.find("\""))); // 이렇게도 사용할 수 있는 것 알아두자
            ind = tmp.find("<a href"); // 다음 존재하는 a 태그가 있는지 확인
        }
    }

    // 매칭 점수
    vector<double> matchingScore(N, 0);
    for (int i=0;i<N;i++) {
        matchingScore[i] += web[i].first;
        double linkScore = 0;
        if (web[i].second.size() != 0)
            linkScore = (double)web[i].first / (double)web[i].second.size();
        for (int j = 0; j < web[i].second.size(); j++) {
            if(linkAndWebIndexMap.find(web[i].second[j])!=linkAndWebIndexMap.end()){
            int linkInd = linkAndWebIndexMap[web[i].second[j]];
            matchingScore[linkInd] += linkScore;
            }
        }
    }

    int answer = 0;
    for (int i = 0; i < N; i++) {
        if(matchingScore[answer] < matchingScore[i]){
            answer = i;
        }
    }

    return answer;
}
```
# 알아두기
find함수로 string에서 index 찾고 활용하는 방법 (못찾을시 string::npos를 반환)
