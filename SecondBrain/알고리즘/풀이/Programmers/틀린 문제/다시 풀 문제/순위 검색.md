## 다른 사람의 풀이
```cpp
#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>
#include <sstream>

using namespace std;

const string ALL = "-";
unordered_map<string, vector<int>> map;

void insert(string* key, int mask, int point) {
    string s = "";
    for (int i = 0; i < 4; i++) {
        s += (mask & (1 << i)) ? ALL : key[i];
        map[s].push_back(point);
    }
}

vector<int> solution(vector<string> info, vector<string> query) {
    vector<int> answer;
    string key[4], tmp;
    int point;

    for (auto& inf : info) {
        istringstream iss(inf);
        iss >> key[0] >> key[1] >> key[2] >> key[3] >> point;
        for (int mask = 0; mask < 16; mask++){ // 0000 ~ 1111 까지 ALL 부분을 포함해서 insert 하기 위함
	        insert(key, mask, point);
        } 
    }

    for (auto& m : map) {
	    sort(m.second.begin(), m.second.end());
    }

    for (auto& que : query) {
        istringstream iss(que);
        iss >> key[0] >> tmp >> key[1] >> tmp >> key[2] >> tmp >> key[3] >> point;
        string s = key[0] + key[1] + key[2] + key[3];
        vector<int>& v = map[s];
        answer.push_back(v.end() - lower_bound(v.begin(), v.end(), point));
    }

    return answer;
}
```
### 알아두어야 할 것
lower_bound는 이진 탐색으로 원소를 탐색한다.
찾으려는 key 값보다 같거나 큰 숫자가 배열 몇 번째에서 처음 등장하는지 찾기 위함
=> 탐색을 진행할 배열 또는 벡터가 오름차순 정렬되어 있어야 한다.

## 틀린 이유
풀이 과정 자체는 떠올린 것 같은데, 풀이법을 헤맸다.
비트 마스킹을 통해 데이터를 가리는 방식과 lower_bound를 통해 이진 탐색 하는 방법에 대해서 알아두어야 한다.