```cpp
#include <string>
#include <vector>
#include <algorithm>
#include <stack>
#include <unordered_map>
#include <iostream>

using namespace std;

bool comp (vector<string> a, vector<string> b) {
    return a[1] < b[1]; // 시간은 string 비교를 해도 된다.
}

int getTime (string s) {
    int h = stoi(s.substr(0, 2)); // substr 함수 기억해두기
    int m = stoi(s.substr(3));
    return h * 60 + m;
}

vector<string> solution(vector<vector<string>> plans) {
    sort(plans.begin(), plans.end(), comp); // 배열은 시간순으로 정렬되어 있지 않으므로 정렬

    unordered_map<string, int> remainTime;
    for (vector<string> plan : plans) remainTime[plan[0]] = stoi(plan[2]);

    stack<vector<string>> stk; // 가장 최근에 멈춘 과제부터 시작해야 하므로 stack사용
    stk.push(plans[0]);

    int nextIdx = 1;
    int time = getTime(plans[0][1]);

    vector<string> answer;
    while (!stk.empty()) {
        time++;
        string sub = stk.top()[0];
        remainTime[sub]--;

        if (remainTime[sub] == 0) {
            stk.pop();
            answer.push_back(sub);
        }

        // 스택이 비어있거나, 다음 plan을 시작할 시간이 되었다면, 다음 plan 시작
        if (nextIdx < plans.size() && (time == getTime(plans[nextIdx][1]) || stk.empty())) {
            stk.push(plans[nextIdx]);
            time = getTime(plans[nextIdx][1]); // 스택이 비어있다면, 다음 시작 시간으로 넘김
            nextIdx++;
        } 
    }
    return answer;
}
```
## 배운 점
string은 stoi를 사용해서 int로 변경가능
string.substr을 사용해 string 깎기
문제 잘 읽기 (배열이 시간 순으로 정렬되어 있지 않았음, 가장 최근에 멈춘 과제부터 시작했음)
시간은 string 비교를 해도 된다.

## 다시 푼 풀이
```cpp
#include <string>
#include <vector>
#include <algorithm>
#include <stack>

using namespace std;

struct Task{
    string name;
    int start, playtime;
    
    Task(string n, int s, int p){
        name = n;
        start = s;
        playtime = p;
    }
};

vector<Task> v;

int convertMin(string s){
    int h = stoi(s.substr(0, 2)) * 60;
    int m = stoi(s.substr(3, 2));
    return h + m;
}

bool compare(const Task &t1, const Task &t2){
    return t1.start < t2.start;
}

vector<string> solution(vector<vector<string>> plans) {
    for(const vector<string> &plan : plans){
        v.push_back(Task(plan[0], convertMin(plan[1]), stoi(plan[2])));    
    }
    sort(v.begin(), v.end(), compare);
    vector<string> answer;
    stack<Task> stk;
    for(int i = 0; i < v.size(); i++){
        Task curTask = v[i];
        if(i == v.size() - 1){
            stk.push(curTask);
            while(!stk.empty()){
                answer.push_back(stk.top().name);
                stk.pop();
            }
            return answer;
        }
        int end = curTask.start + curTask.playtime;
        int nstart = v[i + 1].start;
        if(end > nstart) { // 현재 과제를 stack에 넣어야 함
            curTask.playtime = end - nstart;
            stk.push(curTask);
            continue; // 다음 과제로 넘어간다.
        }else{ // 현재 과제를 다 끝내고 멈춘 과제들을 한다.
            answer.push_back(curTask.name);
            int time = end;
            while(!stk.empty()){
                Task rtask = stk.top(); stk.pop();
                if(nstart < time + rtask.playtime){
                    rtask.playtime = time + rtask.playtime - nstart;
                    stk.push(rtask);
                    break;
                }
                time += rtask.playtime;
                answer.push_back(rtask.name);
            }
        }
    }
    
    return answer;
}
```