## 다른 사람의 풀이
```cpp
#include <bits/stdc++.h>
 using namespace std;
bool possi(vector<int> &vec,int now){
    for(int i=0;i<vec.size();i++)
        if((vec[i] & now) == vec[i])return false; // (vec[i] & now) == vec[i] => 최소성을 만족하지 못한다.
    return true;
}
int solution(vector<vector<string>> relation) {
    int n=relation.size();
    int m=relation[0].size();
    vector<int> ans;
    for(int i = 1; i < (1 << m); i++){ // 2m개의 상황 존재
        set<string> s;
        for(int j=0;j<n;j++){
            string now="";
            for(int k=0;k<m;k++){ // 선택된 후보키만 더해서 구한다.
                if(i & (1 << k)) now+=relation[j][k];
            }
            s.insert(now);
        }
        if(s.size() == n && possi(ans,i)) ans.push_back(i);
    }
    return ans.size();
}
```
손도 못대버렸다..

## 자바 풀이
```java
import java.util.*;

class Solution {
    public int solution(String[][] relation) {
        int r = relation.length;
        int c = relation[0].length;
        List<Integer> answer = new ArrayList<>();
        
        for(int bit = 1; bit < (1 << c); bit++){
            Set<String> set = new HashSet<>();
            for(int y = 0; y < r; y++){
                StringJoiner sj = new StringJoiner("&");
                for(int x = 0; x < c; x++){
                    if((bit & (1 << x)) != 0) sj.add(relation[y][x]);
                }
                set.add(sj.toString());
            }
            if(set.size() == r && isMinimum(answer, bit)){
                answer.add(bit);
            } 
        }
        
        return answer.size();    
    }
    
    boolean isMinimum(List<Integer> answer, int bit){
        for(int i : answer){
            if((i & bit) == i) return false;
        }
        return true;
    }

}
```