## 답을 본 풀이

```java
class Solution {
    int[] dx = {0, 0, -1, 1};
    int[] dy = {-1, 1, 0, 0};

    int n, m;

    public int solution(int[][] board, int[] aloc, int[] bloc) {
        n = board.length;
        m = board[0].length;

        return recursive(board, aloc, bloc);
    }

	// 현재 차례 플레이어의 결과 이동 횟수를 return한다.
	// return 값 홀수: 이김
	// return 값 짝수: 짐
    private int recursive(int[][] board, int[] aloc, int[] bloc) { 
        int cy = aloc[0];
        int cx = aloc[1];
        if (board[cy][cx] == 0) return 0; // 이미 방문한 타일이면 끝

        int moveCount = 0; // 내가 못 움직이면 moveCount도 0

        for (int i = 0; i < 4; i++) {
            int nx = cx + dx[i];
            int ny = cy + dy[i];

            if (outOfBounds(ny, nx) || board[ny][nx] == 0) continue;

            board[cy][cx] = 0;

            int opponentMove = recursive(board, bloc, new int[]{ny, nx}) + 1;

            board[cy][cx] = 1;

            if (moveCount % 2 == 0 && opponentMove % 2 == 1) { 
	            // 현재 지고 있지만, 이길 수 있는 선택지가 새로 등장
                moveCount = opponentMove;
            } else if (moveCount % 2 == 0 && opponentMove % 2 == 0) { 
	            // 질 수 밖에 없으므로 최대한 오래 버티는 수 선택
                moveCount = Math.max(moveCount, opponentMove);
            } else if (moveCount % 2 == 1 && opponentMove % 2 == 1) {
	            // 이기는 방법 중 최대한 빨리 이기는 수 선택
                moveCount = Math.min(moveCount, opponentMove);
            }
        }
        return moveCount;
    }

    public boolean outOfBounds(int y, int x) {
        return y < 0 || y >= n || x < 0 || x >= m;
    }
}
```