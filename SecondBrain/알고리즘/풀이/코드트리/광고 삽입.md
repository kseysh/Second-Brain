## 내 풀이..
```cpp
#include <string>
#include <vector>
#include <iostream>

using namespace std;

int v[400'000]; // 누적합 구하는 배열
int at, pt;


int logToSec(const string &log){
    int h = stoi(log.substr(0,2));
    int m = stoi(log.substr(3,2));
    int s = stoi(log.substr(6,2));
    
    return ((60 * h) + m) * 60 + s;
}

string secToLog(int sec){
    int s = sec % 60;
    sec /= 60;
    string ss = s < 10 ? "0" + to_string(s) : to_string(s);
    int m = sec % 60;
    string sm = m < 10 ? "0" + to_string(m) : to_string(m);
    int h = sec / 60;
    string sh = h < 10 ? "0" + to_string(h) : to_string(h);
    
    return sh + ":" + sm + ":" + ss;
}

string solution(string play_time, string adv_time, vector<string> logs) {
    at = logToSec(adv_time);
    pt = logToSec(play_time);
    
    for(const string &s : logs){
        int startSecond = logToSec(s.substr(0,8));
        int endSecond = logToSec(s.substr(9,8));
        
        v[startSecond]++;
        v[endSecond]--; // 끝은 포함하지 않는답니다...
    }
    
    for(int i = 1; i <= pt; i++){
        v[i] += v[i - 1];
    }
    
    long long window = 0; // window는 300'000 x 360'000임
    int optimalTime = 0;
    for(int i = 0; i < at; i++){
        window += v[i];
    }
    long long maxTime = window;
    
    for(int i = 0; i <= pt - at; i++){
        window -= v[i];
        window += v[i + at];
        if(maxTime < window){
            maxTime = window;
            optimalTime = i + 1;
        }
    }
    
    return secToLog(optimalTime);
}
```

누적합 + 슬라이딩 윈도우로 참 잘 풀었다 생각했지만...

## 틀린 이유
- maxTime이 300'000 x 360'000임을 간과함
- endTime은 포함하지 않아야 했는데 그러지 못함
