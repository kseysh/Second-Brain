```cpp
#include <iostream>
#include <algorithm>
#include <climits>

using namespace std;

int row, col;
int grid[5][5];

int getSum(int sx, int sy, int ex, int ey) {
    int result = 0;
    for (int y = sy; y < ey; y++) {
        for (int x = sx; x < ex; x++) {
            result += grid[y][x];
        }
    }
    return result;
}

int main() {
    cin >> row >> col;

    for (int i = 0; i < row; i++) {
        for (int j = 0; j < col; j++) {
            cin >> grid[i][j];
        }
    }

    int result = INT_MIN;

    for (int y1 = 0; y1 < row; y1++) {
        for (int x1 = 0; x1 < col; x1++) {
            for (int h1 = 1; h1 <= row; h1++) {
                for (int w1 = 1; w1 <= col; w1++) {
                    int sx1 = x1, sy1 = y1;
                    int ex1 = x1 + w1, ey1 = y1 + h1;
                    if (ex1 > col || ey1 > row) continue;

                    for (int y2 = 0; y2 < row; y2++) {
                        for (int x2 = 0; x2 < col; x2++) {
                            for (int h2 = 1; h2 <= row; h2++) {
                                for (int w2 = 1; w2 <= col; w2++) {
                                    int sx2 = x2, sy2 = y2;
                                    int ex2 = x2 + w2, ey2 = y2 + h2;
                                    if (ex2 > col || ey2 > row) continue;

                                    // 겹치는 경우 건너뜀`
                                    if((sx2 < ex1 && sy2 < ey1)) continue;

                                    // 합 계산
                                    int sum = getSum(sx1, sy1, ex1, ey1) + getSum(sx2, sy2, ex2, ey2);
                                    result = max(result, sum);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    cout << result;
    return 0;
}
```
무려 8중 for문...
겹치는 경우에 대해서 다시 한 번 고민해보자.
```cpp
if (ex1 <= sx2 || ex2 <= sx1 || ey1 <= sy2 || ey2 <= sy1) {
    // 직사각형이 겹치지 않는 경우
}
```

## 틀린 부분
겹치는 부분에 대해 잘 못 설정하였다.
height와 width의 조건을 1~row로 설정해야 하는데 row-1까지로 설정했다.

## 정답으로 제시한 코드
```cpp
#include <iostream>
#include <algorithm>
#include <climits>

#define MAX_NUM 5

using namespace std;

int n, m;
int grid[MAX_NUM][MAX_NUM];
int board[MAX_NUM][MAX_NUM];

void ClearBoard() {
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            board[i][j] = 0;
}

void Draw(int x1, int y1, int x2, int y2) {
    for(int i = x1; i <= x2; i++)
        for(int j = y1; j <= y2; j++)
            board[i][j]++;
}

bool CheckBoard() {
    // 동일한 칸을 2개의 직사각형이 모두 포함한다면
    // 겹치게 됩니다.
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            if(board[i][j] >= 2)
                return true;
    return false;
}

// (x1, y1), (x2, y2) 그리고
// (x3, y3), (x4, y4) 로 이루어져있는
// 두 직사각형이 겹치는지 확인하는 함수
bool Overlapped(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {
    ClearBoard();
    Draw(x1, y1, x2, y2);
    Draw(x3, y3, x4, y4);
    return CheckBoard();
}

int RectSum(int x1, int y1, int x2, int y2) {
    int sum_of_nums = 0;
    for(int i = x1; i <= x2; i++)
        for(int j = y1; j <= y2; j++)
            sum_of_nums += grid[i][j];
    
    return sum_of_nums;
}

// 첫 번째 직사각형이 (x1, y1), (x2, y2)를 양쪽 꼭지점으로 할 때
// 두 번째 직사각형을 겹치지 않게 잘 잡아
// 최대 합을 반환하는 함수
int FindMaxSum(int x1, int y1, int x2, int y2) {
    int max_sum = INT_MIN;
    
    // (i, j), (k, l)을 양쪽 꼭지점으로 하는
    // 두 번째 직사각형을 정하여
    // 겹치지 않았을 때 중
    // 최댓값을 찾아 반환합니다.
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            for(int k = i; k < n; k++)
                for(int l = j; l < m; l++) {
                    if(!Overlapped(x1, y1, x2, y2, i, j, k, l))
                        max_sum = max(max_sum, 
                                      RectSum(x1, y1, x2, y2) +
                                      RectSum(i, j, k, l));
                }
    
    return max_sum;
}

// 두 직사각형을 잘 잡았을 때의 최대 합을 반환하는 함수
int FindMaxSum() {
    int max_sum = INT_MIN;
    
	// (i, j), (k, l)을 양쪽 꼭지점으로 하는
    // 첫 번째 직사각형을 정하여
    // 그 중 최댓값을 찾아 반환합니다.
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            for(int k = i; k < n; k++)
                for(int l = j; l < m; l++)
                    max_sum = max(max_sum, FindMaxSum(i, j, k, l));
    return max_sum;
}

int main() {
	cin >> n >> m;
	
	for(int i = 0; i < n; i++)
		for(int j = 0; j < m; j++)
			cin >> grid[i][j];
	
	int ans = FindMaxSum();
	cout << ans;
	
	return 0;
}

```
위 함수처럼 첫 번째 직사각형을 잡고, 두 번째 직사각형을 잡는 함수를 두 가지로 나눈다면 8중 for문이 되는 참사를 피할 수 있었을 것..
Draw와 CheckBoard, ClearBoard보다 내가 사용한 방식인 경계를 확인하는 방식으로 함수를 짜는 것이 더 나았을 것 같다.

### 다시 푼 풀이
```java
import java.util.*;
import java.io.*;

public class Main {
    public static final int MAX_N = 5;
    public static final int MAX_M = 5;

    public static int n;
    public static int m;
    public static int[][] grid = new int[MAX_N][MAX_M];
    public static int[][] sum = new int[MAX_N][MAX_M];

    public static int getSum(int y, int x, int r, int c){
        int ey = y + r - 1;
        int ex = x + c - 1;

        if(ey == n - 1 && ex == m - 1){
            return sum[y][x];
        }else if(ey == n - 1){
            return sum[y][x] - sum[y][ex + 1];
        }else if(ex == m - 1){
            return sum[y][x] - sum[ey + 1][x];
        }

        return sum[y][x] + sum[ey + 1][ex + 1] - sum[ey + 1][x] - sum[y][ex + 1];
    }

    public static boolean inRange(int y, int x){
        return y < n && x < m && y >= 0 && x >= 0;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                grid[i][j] = sc.nextInt();
                sum[i][j] = grid[i][j];
            }
        }
        
        for(int y = n - 1; y >= 0; y--){
            for(int x = m - 1; x >= 0; x--){
                if(x - 1 >= 0) sum[y][x - 1] += sum[y][x];
                if(y - 1 >= 0) sum[y - 1][x] += sum[y][x];
                if(x - 1 >= 0 && y - 1 >= 0) sum[y - 1][x - 1] -= sum[y][x];
            }
        }

        int answer = -50000;
        for(int y1 = 0; y1 < n; y1++){
            for(int x1 = 0; x1 < m; x1++){
                for(int r1 = 1; r1 <= n; r1++){
                    for(int c1 = 1; c1 <= m; c1++){
                        int ey1 = y1 + r1 - 1; // 첫 번째 직사각형의 끝 y
                        int ex1 = x1 + c1 - 1; // 첫 번째 직사각형의 끝 x
                        if(!inRange(ey1, ex1)) continue;
                        for(int y2 = 0; y2 < n; y2++){
                            for(int x2 = 0; x2 < m; x2++){
                                if(ex1 >= x2 && ey1 >= y2) continue; // 겹치는 경우 발생
                                for(int r2 = 1; r2 <= n; r2++){
                                    for(int c2 = 1; c2 <= m; c2++){
                                        int ey2 = y2 + r2 - 1; // 두 번째 직사각형의 끝 y
                                        int ex2 = x2 + c2 - 1; // 두 번째 직사각형의 끝 x
                                        if(!inRange(ey2, ex2)) continue;

                                        int sum1 = getSum(y1, x1, r1, c1);
                                        int sum2 = getSum(y2, x2, r2, c2);

                                        answer = Math.max(answer, sum1 + sum2);
                                    }
                                }
                            }
                        }

                    }
                }
            }
        }
        System.out.println(answer);
    }
}
```

```java
for(int y = n - 1; y >= 0; y--){
	for(int x = m - 1; x >= 0; x--){ // 이 부분을 n으로 봐서 엄청 오래걸렸다.
```
또한, 2D 누적합 구하는 공식을 까먹어서 오래걸렸다.