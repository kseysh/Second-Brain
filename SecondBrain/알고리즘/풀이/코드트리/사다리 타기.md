```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <climits>
using namespace std;
#define MAX_N 11
int n, m;
vector<pair<int, int>> originLines;
vector<pair<int, int>> selectedLines;
int originNum[MAX_N];
int tempNum[MAX_N];
int ans = INT_MAX;

bool possible(){
    for(int i = 0; i < n; i++){
        if(originNum[i] != tempNum[i]) return false;
    }
    return true;
}

void initStartNum(int num[]){
    for(int i = 0; i < n; i++){
        num[i] = i;
    }
}

void caculateNum(int num[], const vector<pair<int, int>> &lines){
    initStartNum(num);
    int lineSize = lines.size();
    for(int i = 0; i < lineSize; i++){
        int idx = lines[i].second;
        swap(num[idx], num[idx+1]);
    }
}

void findMinLines(int count){
    if(count == m){
        caculateNum(tempNum, selectedLines);
        if(possible()){
            ans = min(ans, (int)selectedLines.size());
        }
        return;
    }
    selectedLines.push_back(originLines[count]);
    findMinLines(count + 1);
    selectedLines.pop_back();
    findMinLines(count + 1);
}

int main() {
    cin >> n >> m;
    for(int i = 1; i <= m; i++){
        int a, b;
        cin >> a >> b;
        originLines.push_back({b, a - 1});
    }
    sort(originLines.begin(), originLines.end());
    caculateNum(originNum, originLines);
    findMinLines(0);
    cout << ans;
    return 0;
}
```
접근도 못한 문제 사디리를 타는 풀이과정에 대해서 잘 확인해보자


## 또 틀림
문제를 제대로 파악하지 못함
주어진 사다리만을 사용하는 문제였음
```java
import java.util.*;
import java.io.*;

public class Main {

    public static class Ladder implements Comparable<Ladder>{
        int a, b;

        Ladder(int a, int b){
            this.a = a;
            this.b = b;
        }

        @Override
        public int compareTo(Ladder ladder){
            return (this.b < ladder.b) ? 1 : -1;
        }
    }

    public static int minLadderCount;
    public static int n;
    public static int m;

    public static List<Ladder> ladders = new ArrayList<>();
    public static List<Ladder> selectedLadders = new ArrayList<>();
    public static boolean[] isUsed;
    public static List<Integer> order = new ArrayList<>();

    public static void swap(int idx, List<Integer> list){
        Integer temp = list.get(idx);
        list.set(idx, list.get(idx + 1));
        list.set(idx + 1, temp);
    }

    public static void checkSameResult(){
        List<Integer> curOrder = new ArrayList<>();
        for(int i = 0; i <= n; i++){
            curOrder.add(i);
        }

        int useLadderCount = selectedLadders.size();
        
        for(Ladder ladder : selectedLadders){
            swap(ladder.a, curOrder);
        }

        for(int i = 1; i <= n; i++){
            if(order.get(i) != curOrder.get(i)) return;
        }

        minLadderCount = (minLadderCount > useLadderCount) ? useLadderCount : minLadderCount;
    }

    public static void backtracking(int curCount){
        if(m == curCount){
            checkSameResult();
            return;
        }

        selectedLadders.add(ladders.get(curCount));
        backtracking(curCount + 1);
        selectedLadders.remove(selectedLadders.size() - 1);
        backtracking(curCount + 1);
        
        // for(int i = 0; i < m; i++){
        //     if(isUsed[i]) continue;
        //     isUsed[i] = true;
        //     backtracking(targetCount, curUseCount + 1);
        //     isUsed[i] = false;
        // }
        // 위 풀이로 했을 때는 틀렸음
        // 생각해보니 위 풀이는 조합이 아니라 순열이기 때문에 2^m 방식이 아닌, m! 방식을 사용하기 때문에 틀린 것
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();

        for(int i = 0; i <= n; i++){
            order.add(i);
        }

        isUsed = new boolean[m];
        for(int i = 0; i < m; i++){
            int a = sc.nextInt();
            int b = sc.nextInt();
            ladders.add(new Ladder(a, b));
            isUsed[i] = false;
        }
        Collections.sort(ladders);

        for(Ladder ladder : ladders){
            swap(ladder.a, order);
        }

        minLadderCount = m;
        backtracking(0);

        System.out.println(minLadderCount);
    }
}
```
풀었지만, 시간초과로 인해 수정함

1. 백트래킹에서 조합(2^m)과 순열(m!)을 잘 구분하자
2. 객체 sort시에는 객체에 Comparable<T>를 구현해서 사용할 수 있다.