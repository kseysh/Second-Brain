```cpp
#include <iostream>
#include <cstring>
using namespace std;

int n, m, k;
int arr[101][101];
int temp[101][101];

void output() {
    int result = 0;
    for (int y = 1; y <= n; y++) {
        for (int x = 1; x <= n; x++) {
            if (arr[y][x] != 0) result++;
        }
    }
    cout << result;
}

void convertZero(int x, int startY, int endY) {
    for (int y = startY; y <= endY; y++) {
        arr[y][x] = 0;
    }
}

bool bomb() {
    bool flag = false;
    for (int x = 1; x <= n; x++) {
        int prev = arr[1][x];
        int startY = 1;
        for (int y = 2; y <= n; y++) {
            int cur = arr[y][x];
            if (cur != prev) {
                if (y - startY >= m && prev != 0) {
                    convertZero(x, startY, y - 1);
                    flag = true;
                }
                startY = y;
                prev = cur;
            }
        }
        if (n - startY + 1 >= m && prev != 0) {
            convertZero(x, startY, n);
            flag = true;
        }
    }
    return flag;
}

void fall() {
    memset(temp, 0, sizeof(temp)); // temp 배열 초기화
    for (int x = 1; x <= n; x++) {
        int tempY = n;
        for (int y = n; y > 0; y--) {
            if (arr[y][x] != 0) {
                temp[tempY--][x] = arr[y][x];
            }
        }
    }
    memcpy(arr, temp, sizeof(arr)); // temp를 arr로 복사
}

void rotate() {
    memset(temp, 0, sizeof(temp)); // temp 배열 초기화
    for (int y = 1; y <= n; y++) {
        for (int x = 1; x <= n; x++) {
            temp[x][n + 1 - y] = arr[y][x];
        }
    }
    memcpy(arr, temp, sizeof(arr)); // temp를 arr로 복사
}

void solution() {
    while (bomb()) {
        fall();
    }
    rotate();
    fall();
}

int main() {
    cin >> n >> m >> k;
    for (int y = 1; y <= n; y++) {
        for (int x = 1; x <= n; x++) {
            cin >> arr[y][x];
        }
    }

    for (int i = 0; i < k; i++) {
        solution();
    }
    while (bomb()) {
        fall();
    }
    output();
    return 0;
}
```

## 알아두기
arr init 하기 = `memset(arr, temp, sizeof(arr))`
tempToArr copy 하기 = `memcpy(arr, temp, sizeof(arr))`

## 틀린 이유
rotate함수에서 fall 이후에 오는 temp는 무조건 arr과 같을 것이라고 가정하고 풀었는데, n = 1일 때 bomb()을 하지 않으면 fall()을 하지 않아 temp가 초기화되지 않은 문제였음...
![[Pasted image 20250117221624.png]]

## 또 틀림
```java
import java.util.*;
import java.io.*;

public class Main {
    public static final int MAX_N = 100;
    public static final int EMPTY = 0;

    public static int n;
    public static int m;
    public static int[][] temp = new int[MAX_N][MAX_N];
    public static int[][] grid = new int[MAX_N][MAX_N];

    public static void debug(){
        for(int y = 0; y < n; y++){
            for(int x = 0; x < n; x++){
                System.out.print(grid[y][x] + " ");
            }
            System.out.println();
        }
        System.out.println();
    }

    public static void initTemp(){
        for(int y = 0; y < n; y++){
            for(int x = 0; x < n; x++){
                temp[y][x] = EMPTY;
            }
        }
    }

    public static boolean explode(){
        boolean isExplode = false;
        for (int x = 0; x < n; x++) {
            int curValue = -1;
            int curCount = 0;
            for (int y = 0; y < n; y++) {
                if (grid[y][x] != curValue) {
                    if (curCount >= m && curValue != EMPTY) {
                        for (int i = 1; i <= curCount; i++) {
                            grid[y - i][x] = EMPTY;
                            isExplode = true;
                        }
                    }
                    curValue = grid[y][x];
                    curCount = 1;
                } else {
                    curCount++;
                }
            }

            if (curCount >= m && curValue != EMPTY) {
                for (int i = 1; i <= curCount; i++) {
                    grid[n - i][x] = EMPTY;
                    isExplode = true;
                }
            }
        }

        return isExplode;
    }

    public static void rotate(){
        for(int y = 0; y < n; y++){
            for(int x = 0; x < n; x++){
                temp[x][n - 1 - y] = grid[y][x];
            }
        }

        for(int y = 0; y < n; y++){
            for(int x = 0; x < n; x++){
                grid[y][x] = temp[y][x];
            }
        }
    }

    public static void gravity(){
        for(int x = 0; x < n; x++){
            for(int y = n - 1; y >= 0; y--){
                if(grid[y][x] == EMPTY) continue;
                
                int emptyYPos = y + 1;
                for(; emptyYPos < n; emptyYPos++){
                    if(grid[emptyYPos][x] != EMPTY) break;
                }
                
                if(emptyYPos - 1 != y){
                    grid[emptyYPos - 1][x] = grid[y][x];
                    grid[y][x] = EMPTY;
                }
            }
        }
    }

    public static int getRemainBombCount(){
        int count = 0;

        for(int y = 0; y < n; y++){
            for(int x = 0; x < n; x++){
                if(grid[y][x] != EMPTY) count++;
            }
        }

        return count;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();
        int k = sc.nextInt();
        
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                grid[i][j] = sc.nextInt();
    

        while(k-->0){
            while (explode()) {
                gravity();
            }
            rotate();
            gravity();
        }

        while(explode()){
            gravity();
        }
            
        System.out.println(getRemainBombCount());
    }
}
```

```java
while (explode()) {
	gravity();
}
```
위처럼 while문을 적용하지 않음
explode시 `grid[y][x] == EMPTY`에서 continue를 호출하는 바람에 그 전에 모아둔 curValue와 curCount를 터뜨려주거나 초기화 해주지 못했다.