# 나의 풀이
```cpp
#include <string>
#include <vector>
#include <queue>
#include <tuple>

#define MAX_N 100
#define WALL -111
#define EMPTY 100000
using namespace std;

int b[MAX_N][MAX_N][2];
int n;

int dy[4] = {0, 1, 0, -1};
int dx[4] = {1, 0, -1, 0};

int dyTurnWhenHorizontal[4] = {0, 0, 1, 1};
int dxTurnWhenHorizontal[4] = {-1, 0, -1, 0};
int dyTurnWhenVertical[4] = {-1, -1, 0, 0};
int dxTurnWhenVertical[4] = {0, 1, 0, 1};

void init(const vector<vector<int>> &board){
    n = board.size();    
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            if(board[i][j] == 1){
                b[i][j][0] = WALL;
                b[i][j][1] = WALL;
            }else{
                b[i][j][0] = EMPTY;
                b[i][j][1] = EMPTY;
            }
        }
    }
}

bool inRange(int y, int x){
    return y >= 0 && x >= 0 && y < n && x < n;
}

bool checkIsEmpty(int sy, int ey, int sx, int ex){
    for(int y = sy; y <= ey; y++){
        for(int x = sx; x <= ex; x++){
            if(!inRange(y, x)) return false;
            if(b[y][x][0] == WALL) return false;
        }
    }
    
    return true;
}

int solution(vector<vector<int>> board) {
    init(board);
    
    int hy = 0;
    int hx = 1;
    bool isHorizontal = true;
    int nhy, nhx, nty, ntx;
    bool turnedDistance;
    
    queue<tuple<int, int, bool>> q;
    b[hy][hx][isHorizontal] = 0;
    q.push(make_tuple(hy, hx, isHorizontal));
    
    while(!q.empty()){
        auto [hy, hx, isHorizontal] = q.front(); q.pop();
        int curTime = b[hy][hx][isHorizontal];
        
        // 상, 하, 좌, 우로 이동한다.
        for(int d = 0; d < 4; d++){
            nhy = hy + dy[d];
            nhx = hx + dx[d];
            if(!inRange(nhy, nhx)) continue; // head가 격자 안에 존재함
            if(b[nhy][nhx][isHorizontal] == WALL) continue; // head가 벽에 부딫히지 않음
            
            nty = isHorizontal ? nhy : nhy - 1;
            ntx = isHorizontal ? nhx - 1 : nhx;
            if(!inRange(nty, ntx)) continue; // tail이 격자 안에 존재함
            if(b[nty][ntx][isHorizontal] == WALL) continue; // tail이 벽에 부딫히지 않음
            
            if(b[nhy][nhx][isHorizontal] <= curTime + 1) continue;
            b[nhy][nhx][isHorizontal] = curTime + 1;
            q.push(make_tuple(nhy, nhx, isHorizontal));
        }
        
        // 4 방향으로 회전한다.
        for(int d = 0; d < 4; d++){
            nhy = isHorizontal ? hy + dyTurnWhenHorizontal[d] : hy + dyTurnWhenVertical[d];
            nhx = isHorizontal ? hx + dxTurnWhenHorizontal[d] : hx + dxTurnWhenVertical[d];
            
            if(isHorizontal){
                if(d <= 1){
                    if(!checkIsEmpty(hy - 1, hy, hx - 1, hx)) continue;
                }else{
                    if(!checkIsEmpty(hy, hy + 1, hx - 1, hx)) continue;
                }
            }else{
                if(d % 2 == 0){
                    if(!checkIsEmpty(hy - 1, hy, hx - 1, hx)) continue;
                    
                }else{
                    if(!checkIsEmpty(hy - 1, hy, hx, hx + 1)) continue;
                }
            }
            
            if(b[nhy][nhx][!isHorizontal] <= curTime + 1) continue;
            b[nhy][nhx][!isHorizontal] = curTime + 1;
            q.push(make_tuple(nhy, nhx, !isHorizontal));
        }
        
    }

    return min(b[n - 1][n - 1][0], b[n - 1][n - 1][1]);
}
```

풀이는 괜찮은데 너무 오래걸렸다.
