# 상속관계 매핑
관계형 데이터베이스는 상속 관계가 없다.
슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사하다.
상속관계 매핑 : 객체의 상속과 구조와 db의 슈퍼타입 서브타입 관계를 매핑한다.

## 조인 전략
엔티티 각각을 모두 테이블로 만들고, 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략
주로 조회시에 사용한다.

### 주의할 점
객체는 타입으로 구분할 수 있지만, 테이블은 타입의 개념이 없기 때문에 타입을 구분하는 컬럼을 추가해야 한다.
![[Pasted image 20231105211024.png]]
> DTYPE이 구분 컬럼으로 사용된다.

### 장점
- 테이블이 정규화됨
- 외래 키 참조 무결성 제약조건을 활용 가능
- 저장공간의 효율적인 사용
### 단점
- 조회할 때 조인이 많이 사용 ⇒ 성능이 저하될 수 있음
- 조회 쿼리의 복잡성
- 데이터를 등록할 INSERT SQL이 2번 실행됨

jPA 표준 명세는 구분 컬럼을 사용하도록 하지만 하이버네이트를 포함한 몇몇 구현체는 구분 컬럼(`@DiscriminatorColumn`) 없이도 동작한다.

>기본적으로 정석이라고 생각해도 괜찮다.
=> 객체랑도 잘 맞고 정규화도 잘 되어 설계가 잘 되기 때문.
### 부모 클래스
#### @Inheritance
부모 클래스에 상속 매핑임을 명시해주기 위한 어노테이션
`@Inheritance(strategy = InheritanceType.JOINED)`
#### @DiscriminatorColumn
부모 클래스에 구분 컬럼 지정. 이 컬럼으로 저장된 자식 테이블을 구분할 수 있다. → default : DTYPE
`@DiscriminatorColumn(name = "DTYPE")`
> DTYPE은 항상 있는 것이 좋다.
### 자식 클래스
#### @DiscriminatorValue
default => 엔티티의 클래스 이름


## 단일 테이블 전략
테이블을 하나만 사용해서 구분 컬럼(DTYPE)으로 어떤 자식 데이터가 저장되었는지 구분한다. 조회 시 조인을 사용하지 않으므로 일반적으로 가장 빠르다!
JPA에서 기본으로 적용하는 전
### 주의할 점
자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다.

![[Pasted image 20231105210639.png]]

ex. Book 엔티티 저장 시, AUTHOR, ISBN을 제외한 나머지 컬럼은 사용하지 않으므로 null이 입력된다.

`@Inheritance(strategy = InheritanceType.**SINGLE_TABLE**)` 로 지정

이때 테이블 하나에 모든 것을 통합하므로 구분 컬럼을 필수로 사용해야 한다.
### 장점
- 조인 필요X ⇒ 일반적으로 조회 성능 FAST
- 조회 쿼리가 단순함
### 단점
- 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 함 => 치명적 단점
- 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있음 상황에 따라서는 조회 성능이 오히려 느려지기도 함

### 부모 클래스
#### @Inheritance
부모 클래스에 상속 매핑임을 명시해주기 위한 어노테이션
`@Inheritance(strategy = InheritanceType.SINGLE_TABLE)`
## 구현 클래스마다 테이블 전략
부모 엔티티는 테이블로 구현하지 않고, 자식 엔티티마다 모두 각각의 테이블로 만드는 전략. → 사용하면 안되는 전략
![[Pasted image 20231105210755.png]]
### 장점
- 서브 타입을 구분해서 처리할 때 효과적
- not null 제약조건 사용 가능
### 단점
- 여러 자식 테이블을 함께 조회할 때 성능이 느림(SQL에 UNION을 사용)
- 자식 테이블을 통합해서 쿼리하기가 어려움

구분 컬럼(`@DiscriminatorColumn`)을 사용하지 X
=> 어차피 테이블별로 구분되어 있으므로