사실 객체에서의 양방향 연관관계는 서로 다른 단방향 연관관계가 서로 두 개가 있는 것으로 테이블 연관관계와는 약간 다르다.
![[Pasted image 20231027221853.png]]

![[Pasted image 20231027222127.png]]

![[Pasted image 20231027222153.png]]
어떤 것으로 외래키를 관리할지 애매하므로 룰을 정함
=> 연관관계의 주인

> 1:N관계에서  N이 1을 참조해야 한다.
> 이는 mappedBy 속성을 사용하여 지정할 수 있는데, 주인이 아닌 쪽에서 주인을 지정한다고 생각하면 좋다. (mappedBy의 단어 자체가 매핑당한다는 의미이므로)

따라서 양방향 연관관계는 연관관계의 주인이 외래 키를 관리한다.

양방향 연관관계가 주인이 아닌 쪽에서 수정이 안됨 

> 양방향 매핑시 가장 많이 하는 실수
> => 연관관계의 주인에 값을 입력하지 않음

ex)
```java
// 회원에 팀을 저장할 때 
member.setTeam(team) // 연관관계 설정(연관관계의 주인) 
// 팀에 회원을 저장할 때 
team.getMembers().add(member); // 무시(연관관계의 주인X)
```


![[Pasted image 20231105111212.png]]
![[Pasted image 20231105111910.png]]


## 양방향 연관관계시에 주의해야할 점
### 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자
순수한 객체로서의 연관관계까지 고려한다면, 객체 관점에서는 위와 같이 양쪽 방향에 모두 값을 입력해주는 것이 가장 안전하다. 양쪽 방향 모두 값을 입력하지 않으면 JPA를 사용하지 않는 순수한 객체 상태에서 심각한 문제가 발생할 수 있다.
### 연관관계 편의 메서드를 생성하자
```java
public void changeTeam(Team team){
	this.team = team;
	team.getMembers().add(this);
}
```
이렇게 만들어서 항상 양쪽에 값을 설정해줄 수 있도록 하자!

`setTeam`이라는 네이밍은 setter명령어와 혼동될 수 있으므로 `changeTeam`으로 네이밍을 하는 것을 고려한다.
연관관계 편의 메서드는 로직이 들어간 함수이므로 setter와 혼동되지 않도록 하는 것이 권장된다.
### 양방향 매핑시에 무한 루프를 조심하자
#### toString
Team이 members를 호출 -> members가 team을 호출 -> team이 members를 호출하며 무한 루프에 빠질 수 있다.
#### lombok
#### JSON 생성 라이브러리


## 정리
### 단방향 매핑만으로도 이미 연관관계 매핑은 완료
처음에 설계시에 양방향 연관관계를 최대한 사용하지 않고 단방향 매핑만으로 설계한다.
### 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색)기능이 추가된 것 뿐이다.
### JPQL에서 역방향으로 탐색할 일이 많다.
### 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 된다. (테이블에 영향을 주지 않는다.)
