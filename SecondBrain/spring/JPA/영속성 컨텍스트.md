>엔티티를 영구 저장하는 환경

## 요청이 들어왔을 때 DB에 접근하는 과정
![[Pasted image 20231006111430.png]]
EntityManagerFactory는 하나만 생성해서 애플리케이션 전체에서 공유해야 한다.
엔티티 매니저는 쓰레드간에 공유하면 안된다. (사용하고 바로 닫는다.)
- 엔티티 매니저 팩토리는 엔티티 매니저를 생성한다.
- 엔티티 매니저는 커넥션풀을 이용해 DB를 사용한다.

# 영속성 컨텍스트
- 영속성 컨텍스트는 논리적인 개념
- 눈에 보이지 않는다.
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근한다,
- `EntityManager.persist(entity)`는 저장하겠다는 의미가 아닌 객체를 영속성컨텍스트라는 곳에 저장하겠다는 의

## 엔티티의 생명주기
![[Pasted image 20231006112007.png]]

![[Pasted image 20231006112028.png]]

### 비영속상태
JPA와 딱히 관련이 없는 상태
![[Pasted image 20231006112104.png]]
### 영속상태
![[Pasted image 20231006112147.png]]
em.persist(member)를 한다고 바로 DB에 저장되는 것이 아니라,
트랜잭션을 커밋하는 순간에 영속성컨텍스트에 있는 것이 DB에 쿼리로 실행된다.

### 준영속, 삭제
![[Pasted image 20231006112536.png]]

## 영속성 컨텍스트의 이점

### 엔티티 조회, 1차 캐시
![[Pasted image 20231006113228.png]]
1차 캐시에서 조회할 때는 다시 DB에 쿼리를 날리지 않아도 되어서 조금의 속도 향상을 할 수 있다. 
### 동일성 보장
동일한 DB에서 가져온 인스턴스들은 동일성 비교가 true로 나온다.
1차 캐시로 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공한다. 
> 하지만 같은 트랜잭션 내에서만 허용된다.
### 트랜잭션을 지원하는 쓰기 지연
`em.persist(member)`를 해도, INSERT SQL을 데이터베이스에 보내지 않는다.
`transaction.commit()`을 해야 그 때 데이터베이스 INSERT SQL을 보낸다. (쓰기 지연)
![[Pasted image 20231006114013.png]]
### 변경 감지
`member.setName("name")`이후에 
`em.persist(member)` 이 코드가 필요하지 않다.
엔티티는 변경감지라는 기능을 제공하는데, 컬렉션처럼 값을 바꾸고 다시 DB에 넣지 않아도 값이 변경된다.
![[Pasted image 20231006115040.png]]
## 영속성 컨텍스트를 [[플러시]]하는 방법
![[Pasted image 20231006115558.png]]
`em.flush()` : 쿼리를 미리 DB에 반영하고 싶거나, 쿼리가 날아가는 것을 미리 보고 싶으면 사용할 수 있다.

### JPQL 쿼리 실행시 플러시가 자동 호출되는 이유
![[Pasted image 20231006115919.png]]
persist이후 중간에 JPQL을 실행하는 모습을 보면 아직 commit하지 않고  JPQL을 실행해서 memberA,B,C가 조회되지 않을 수 있다. 따라서 JPQL 쿼리 실행시에는 플러시를 자동호출하여 JPQL이 제대로 작동할 수 있게 한다.