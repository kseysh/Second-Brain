# @Transactional을 서비스 계층에서 사용하는 이유
트랜잭션 시작 시점에 DB 커넥션을 할당받으므로 트랜잭션 범위가 길어지면 안된다.
물리 트랜잭션은 개수의 한계가 있고, 트랜잭션 범위가 짧아야 DB 커넥션을 빨리 반납한다. 그러므로 트랜잭션 범위를 짧게 설정하기 위해 서비스 단에서도 필요한 부분에만 설정하는 것이 좋다.

# 트랜잭션을 적용해야 할 때
### 여러 로직이 섞여있을 때
여러 로직들이 섞여 있을 때 발생하는 문제는 데이터를 영속함에 있다.
한 메서드에서 예외가 발생했을 때, 이전에 호출한 메서드에서 영속한 데이터를 되돌려야 한다.
그렇지 않으면, 예외가 발생한 잘못된 요청임에도 정합성이 맞지 않는 문제가 발생한다.
### DB에 관련된 메서드를 여러번 호출할 때
트랜잭션을 적용하는 이유는 데이터의 정합성을 보장하는 것도 있지만, 핵심은 일련의 작업을 하나의 논리적인 작업으로 묶음에 있다.
이로 인해 여러 작업을 하나의 작업으로 묶어 성능을 개선할 수 있다.
```java
@Service
class MyService() {

    public Response updateData(Request request) {
        Member member = memberDao.findById(request.memberId());
        member.setNickname(request.nickname());
        memberDao.update(member);
        memberHistoryDao.save(new MemberHistory(member));
    }
}
```
위에서 데이터베이스에 요청하는 개수는 3번이어서 커넥션 풀을 사용하지 않으면 데이터베이스 커넥션이 3번 맺어진다.
이 때, 트랜잭션을 적용한다면 트랜잭션 범위안에 있는 모든 데이터베이스의 요청들은 하나의 커넥션을 공유하여 사용한다.
## 트랜잭션을 적용하지 않아야 할 때
