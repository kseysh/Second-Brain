## DB에서의 저장 방식
본래 DB는 Insert된 순서대로 저장된다는 보장을 할 수 없다. Delete를 사용하지 않는다면 그럴 수 있지만, 레코드가 삭제되면 삭제된 공간에 Insert된 값을 저장하는 구조라서 순서대로 저장된다는 보장을 할 수 없다.

하지만, InnoDB는 클러스터링 인덱스를 지원하기 때문에, PK가 비슷한 값을 최대한 모아 저장한다.
InnoDB는 PK를  주소처럼 ROWID로 사용한다.
따라서 세컨더리 인덱스를 사용하려면, 아래의 과정을 거친다.
세컨더리 인덱스를 이용해 PK 찾기 -> PK 인덱스를 이용해 데이터 찾기
# B-Tree 인덱스
### 인덱스 키 추가
B-Tree의 특성상 상대적으로 쓰기 작업의 비용이 많이 든다.
대략적으로 **레코드를 추가하는 비용을 1이라 할 때, 인덱스에 키를 추가하는 비용을 1.5로 계산**한다.
ex) 인덱스가 없을 때 1이라면 인덱스가 3개일 때는 5.5로 예측
이 비용은 대부분이 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야해서 걸리는 시간이다.
### 인덱스 키 삭제
B-Tree의 리프 노드를 찾아서 삭제 마크만 하면 되기 때문에 간단하다.
### 인덱스 키 변경
키 삭제 -> 키 추가의 작업으로 이루어진다.
### 지연처리
인덱스 키 추가, 삭제, 변경 모두 체인지 버퍼를 활용해 지연처리 될 수 있다.
### 인덱스 키 검색
## B-Tree 인덱스 사용에 영향을 미치는 요소
### 인덱스 키 값의 크기
	`Page : InnoDB에서 디스크에 데이터를 저장하는 기본 단위
	버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다.

인덱스 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고 그만큼 느려진다.(인덱스는 페이지단위로 디스크에서 읽으므로)
또한 전체적인 인덱스 크기가 커지면서 메모리에 캐시해 둘 수 있는 레코드 수는 줄어들고 자연히 메모리의 효율이 떨어지는 결과를 가져온다.
### B-Tree 깊이
중요하지만 제어할 방법은 없다.
MySQL에서 값을 검색할 때 몇 번이나 랜덤 IO를 해야하는지와 직결되는 문제이다.
### 선택도(기수성)
모든 인덱스 값 가운데 유니크한 값의 수를 의미한다
전체 인덱스 키 값은 1000인데 그 중에서 유니크한 값의 수는 10개라면 기수성은 100이다.
인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어진다.
기수성이 높을수록 검색 대상이 줄어들어 빨리 처리된다.
그러나 기수성이 좋지 않더라도 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 것이 나은 경우도 많다.
### 읽어야 하는 레코드의 건수
일반적인 **DBMS 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4-5배 정도 비용이 더 많이 드는 작업인 것으로 예측**한다.
따라서 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20-25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방법으로 처리하는 것이 좋다,.
## B-Tree 인덱스를 통한 데이터 읽기
### 인덱스 레인지 스캔
검색해야할 인덱스의 범위가 결정되었을 때 사용하는 방식
인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요한데, 이 때 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어올 때 레코드 한 건 한 건 단위로 랜덤 IO가 한 번씩 일어난다.
그래서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류된다.
1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉읽는다 (인덱스 스캔)
3. 2번에서 읽어들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고 최종 레코드를 읽어온다.
### 인덱스 풀 스캔
인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만 인덱스 레인지 스캔과는 달리 인덱스의 처음부터 끝까지 모드 읽는 방식
즉, 커버링 인덱스가 가능한 인덱스를 모두 읽을 때 테이블 풀 스캔보다 빠르다고 한 것이다.
=> 즉 인덱스를 효율적으로 사용하지 못하는 경우이긴 하다.
### 루스 인덱스 스캔
인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시(SKIP)하고 다음으로 넘어가는 형태로 처리한다.
일반적으로 GROUP BY 또는 집합 함수 가운데 MAX,MIN에 대해 최적화를 하는 경우에 사용된다.
ex) 인덱스가 (dept_no, emp_no)이고 dept_no가 20인 엔티티의 합계를 구하고 싶을 때, dept_no만을 이용해 인덱스를 넘어가도 무방하다 따라서 옵티마이저가 필요없는 emp_no는 스캔하지 않고 dept_no만 비교해가면서 확인하는 스캔 최적화 방식이다,
### 인덱스 스킵 스캔
만약, 인덱스가 (gender, birth_date)로 걸려있을 때 옵티마이저가 gender 칼럼을 건너뛰어서 birth_date 컬럼만으로도 인덱스 검색이 가능하게 해주는 최적화 기능
인덱스 스킵 스캔은 인덱스의 선행 컬럼이 가진 유니크한 값의 개수가 소량일 때만 적용 가능한 최적화이다. (= cardinality가 적을 때)

ex)
`where birth_date>='2002-01-25'`라는 sql문을 내부적으로 아래 2개의 쿼리를 실행하는 것과 비슷한 형태의 최적화를 실행한다.
`where gender = 'M' AND birth_date>='2002-01-25'`
`where gender = 'F' AND birth_date>='2002-01-25'`
## B-Tree 인덱스의 정렬 및 스캔 방향
### InnoDB에서 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느릴 수 밖에 없는 이유
- 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조
![[Pasted image 20250227160003.png|300]]
많은 쿼리가 인덱스의 특정 순서로 집중적으로 읽어 인덱스의 특정 페이지 잠금이 병목이 될 것으로 예상된다면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는데 도움이 된다.
## B-Tree 인덱스의 가용성과 효율성
### 작업 범위 결정 조건 vs 필터링 조건
case A: INDEX(dept_no, emp_no)
case B: INDEX(emp_no, dept_no)
case A에서 (dept_no='d002'와 emp_no>=10144)와 같이 작업의 범위를 결정하는 조건을 작업 범위 결정 조건이라 한다.
case B에서 dept_no='d002'와 같이 비교 작업의 범위를 줄이지 못하고 단순히 필터링 역할만 하는 것을 필터링 조건이라 한다.
작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능을 높이지만 체크 조건은 많다고 해서 처리 성능을 높이기 어렵다. 오히려 성능을 느리게 할 때가 많다.
### 가용성과 효율성 판단
B-Tree의 특성상 아래의 조건은 작업 범위 결정 조건으로 사용할 수 없다.
- NOT_EQUAL로 비교된 경우
- LIKE '%??'으로 뒷부분 일치 문자열 패턴이 비교된 경우
- 인덱스 컬럼이 변형된 후 비교된 경우
MySQL에서는 NULL 값도 인덱스에 저장되어 작업 범위 결정조건으로 사용된다.
## 함수 기반 인덱스
### 가상 컬럼을 이용한 인덱스
가상 컬럼을 추가하고 그 가상 컬럼에 인덱스를 생성할 수 있다.
### 함수를 이용한 인덱스
함수를 직접 사용하는 인덱스는 테이블의 구조는 변경하지 않고, 계산된 결과값의 검색을 빠르게 만들어준다.
함수 기반 인덱스를 제대로 활용하려면 반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용되어야 한다.
## 클러스터링 인덱스
PK가 비슷한 레코드끼리 묶어서 저장하는 것
=>PK 값에 의해 레코드의 저장 위치가 결정된다.
### 장점
PK 기반 검색이 빠르다
세컨더리 인덱스가 클러스터링 키를 가지기 때문에 커버링 인덱스의 확률이 높아진다.
### 단점
세컨더리 인덱스가 클러스터링 키를 가지기 때문에 클러스터링 키가 크면 전체적인 인덱스의 크기가 커진다
세컨더리 인덱스를 통해 검색할 때 PK로 다시 검색해야 해서 처리 성능이 느리다.
레코드의 저장이나 PK 변경이 느리다.
## 클러스터링 테이블 사용시 주의 사항
### 클러스터링 인덱스 키의 크기
PK가 커지면 세컨더리 인덱스의 크기도 커진다.
### PK는 되도록 AUTO-INCREMENT보다 업무적인 컬럼으로 생성
InnoDB의 PK는 클러스터링 키로 작동해 검색시 빠른 조회를 보장한다.
PK는 의미만큼이나 중요한 역할을 하여 검색에서 상당히 빈번하게 사용되는데, 그러므로 컬럼의 크기가 크더라도 해당 레코드를 대표할 수 있다면 그 컬럼을 PK로 설정하는 것이 좋다.
### PK는 반드시 명시할 것
InnoDB 테이블에서 PK를 정의하지 않으면 InnoDB 스토리지 엔진이 내부적으로 일련번호 컬럼을 추가한다.
자동으로 추가된 컬럼은 사용자에게 보이지 않기 때문에 사용자가 접근할 수 없어 PK는 명시하는 것이 좋다,
### AUTO-INCREMENT 컬럼을 인조 식별자로 사용할 경우
PK의 크기가 길어도 세컨더리 인덱스가 필요하지 않다면 그대로 PK를 사용하는 것이 좋다.
세컨더리 인덱스도 필요하고 PK의 크기도 길다면 AUTO_INCREMENT 컬럼을 추가하고, 이를 PK로 설정한다
로그 테이블처럼 INSERT 위주의 테이블은 AUTO_INCREMENT를 PK로 설정하는 것이 성능 향상에 좋다.
## 유니크 인덱스
유니크는 인덱스라기 보다 제약사항에 가깝다.
### 인덱스 쓰기
유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요하다.
그래서 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다.
또한 중복된 값 체크시 읽기 잠금, 쓰기 잠금을 사용하는데 이 과정에서 데드락이 빈번하게 발생한다
또한 InnoDB 스토리지 엔진에는 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼가 사용된다. 하지만, 유니크 인덱스는 반드시 중복 체크를 해야하므로 작업 자체를 버퍼링 하지 못해 느리다.

유일성이 꼭 보장되어야 하는 컬럼에 대해서는 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 유니크 인덱스 보다는 유니크하지 않은 세컨더리 인덱스를 생성하는 방법도 고려하자.
## 외래키
### 자식 테이블의 변경이 대기하는 경우
- 자식 테이블의 외래 키 컬럼의 변경은 부모 테이블의 확인이 필요한데, 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 기다린다.
- 자식 테이블의 외래키가 아닌 컬럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않는다.
### 부모 테이블의 변경 작업이 대기하는 경우
- 물리적으로 외래키를 생성하면 자식 테이블에 레코드가 추가되는 경우 해당 참조키가 부모 테이블에 있는지 확인한다
	- 물리적인 외래키의 고려 사항은 이러한 체크를 위해 연관 테이블에 읽기 잠금을 걸어야 한다는 것이다.
- 잠금이 다른 테이블로 확장되면 그만큼 전체적으로 쿼리의 동시 처리에 영향을 미친다.