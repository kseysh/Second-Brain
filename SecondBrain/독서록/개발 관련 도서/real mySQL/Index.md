## DB에서의 저장 방식
본래 DB는 Insert된 순서대로 저장된다는 보장을 할 수 없다. Delete를 사용하지 않는다면 그럴 수 있지만, 레코드가 삭제되면 삭제된 공간에 Insert된 값을 저장하는 구조라서 순서대로 저장된다는 보장을 할 수 없다.

하지만, InnoDB는 클러스터링 인덱스를 지원하기 때문에, PK가 비슷한 값을 최대한 모아 저장한다.
InnoDB는 PK를  주소처럼 ROWID로 사용한다.
따라서 세컨더리 인덱스를 사용하려면, 아래의 과정을 거친다.
세컨더리 인덱스를 이용해 PK 찾기 -> PK 인덱스를 이용해 데이터 찾기
# B-Tree 인덱스
### 인덱스 키 추가
B-Tree의 특성상 상대적으로 쓰기 작업의 비용이 많이 든다.
대략적으로 레코드를 추가하는 비용을 1이라 할 때, 인덱스에 키를 추가하는 비용을 1.5로 계산한다.
ex) 인덱스가 없을 때 1이라면 인덱스가 3개일 때는 5.5로 예측
이 비용은 대부분이 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야해서 걸리는 시간이다.
### 인덱스 키 삭제
B-Tree의 리프 노드를 찾아서 삭제 마크만 하면 되기 때문에 간단하다.
### 인덱스 키 변경
키 삭제 -> 키 추가의 작업으로 이루어진다.
### 지연처리
인덱스 키 추가, 삭제, 변경 모두 체인지 버퍼를 활용해 지연처리 될 수 있다.
### 인덱스 키 검색
## B-Tree 인덱스 사용에 영향을 미치는 요소
### 인덱스 키 값의 크기
	`Page : InnoDB에서 디스크에 데이터를 저장하는 기본 단위
	버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다.

인덱스 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고 그만큼 느려진다.(인덱스는 페이지단위로 디스크에서 읽으므로)
또한 전체적인 인덱스 크기가 커지면서 메모리에 캐시해 둘 수 있는 레코드 수는 줄어들고 자연히 메모리의 효율이 떨어지는 결과를 가져온다.
### B-Tree 깊이
중요하지만 제어할 방법은 없다.
MySQL에서 값을 검색할 때 몇 번이나 랜덤 IO를 해야하는지와 직결되는 문제이다.
### 선택도(기수성)
모든 인덱스 값 가운데 유니크한 값의 수를 의미한다
전체 인덱스 키 값은 1000인데 그 중에서 유니크한 값의 수는 10개라면 기수성은 100이다.
인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어진다.
기수성이 높을수록 검색 대상이 줄어들어 빨리 처리된다.
그러나 기수성이 좋지 않더라도 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 것이 나은 경우도 많다.
### 읽어야 하는 레코드의 건수
일반적인 DBMS 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4-5배 정도 비용이 더 많이 드는 작업인 것으로 예측한다.
따라서 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20-25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방법으로 처리하는 것이 좋다,.
## B-Tree 인덱스를 통한 데이터 읽기
### 인덱스 레인지 스캔
