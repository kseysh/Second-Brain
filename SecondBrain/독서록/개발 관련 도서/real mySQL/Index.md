## DB에서의 저장 방식
본래 DB는 Insert된 순서대로 저장된다는 보장을 할 수 없다. Delete를 사용하지 않는다면 그럴 수 있지만, 레코드가 삭제되면 삭제된 공간에 Insert된 값을 저장하는 구조라서 순서대로 저장된다는 보장을 할 수 없다.

하지만, InnoDB는 클러스터링 인덱스를 지원하기 때문에, PK가 비슷한 값을 최대한 모아 저장한다.
InnoDB는 PK를  주소처럼 ROWID로 사용한다.
따라서 세컨더리 인덱스를 사용하려면, 아래의 과정을 거친다.
세컨더리 인덱스를 이용해 PK 찾기 -> PK 인덱스를 이용해 데이터 찾기
# B-Tree 인덱스
### 인덱스 키 추가
B-Tree의 특성상 상대적으로 쓰기 작업의 비용이 많이 든다.
대략적으로 레코드를 추가하는 비용을 1이라 할 때, 인덱스에 키를 추가하는 비용을 1.5로 계산한다.
ex) 인덱스가 없을 때 1이라면 인덱스가 3개일 때는 5.5로 예측
이 비용은 대부분이 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야해서 걸리는 시간이다.
### 인덱스 키 삭제
B-Tree의 리프 노드를 찾아서 삭제 마크만 하면 되기 때문에 간단하다.
### 인덱스 키 변경
키 삭제 -> 키 추가의 작업으로 이루어진다.
### 지연처리
인덱스 키 추가, 삭제, 변경 모두 체인지 버퍼를 활용해 지연처리 될 수 있다.
### 인덱스 키 검색
## B-Tree 인덱스 사용에 영향을 미치는 요소
### 인덱스 키 값의 크기
Page : InnoDB에서 디스크에 데이터를 저장하는 기본 단위
버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다.

인덱스 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고 그만큼 느려진다.(인덱스는 페이지단위로 디스크에서 읽으므로)
또한 전체적인 인덱스 크기가 커지면서 메모리에 캐시해 둘 수 있는 레코드 수는 줄어들고 자연히 메모리의 효율이 떨어지는 결과를 가져온다.
### B-Tree 깊이
중요하지만 제어할 방법은 없다.
MySQL에서 값을 검색할 때 몇 번이나 랜덤 IO를 해야하는지와 직결되는 문제이다.
### 선택도(기수성)
모든 인덱스 값 가운데 유니크한 값의 수를 의미하며