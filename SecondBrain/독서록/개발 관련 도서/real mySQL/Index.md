## DB에서의 저장 방식
본래 DB는 Insert된 순서대로 저장된다는 보장을 할 수 없다. Delete를 사용하지 않는다면 그럴 수 있지만, 레코드가 삭제되면 삭제된 공간에 Insert된 값을 저장하는 구조라서 순서대로 저장된다는 보장을 할 수 없다.

하지만, InnoDB는 클러스터링 인덱스를 지원하기 때문에, PK가 비슷한 값을 최대한 모아 저장한다.
InnoDB는 PK를  주소처럼 ROWID로 사용한다.
따라서 세컨더리 인덱스를 사용하려면, 아래의 과정을 거친다.
세컨더리 인덱스를 이용해 PK 찾기 -> PK 인덱스를 이용해 데이터 찾기
# B-Tree 인덱스
### 인덱스 키 추가
B-Tree의 특성상 상대적으로 쓰기 작업의 비용이 많이 든다.
대략적으로 레코드를 추가하는 비용을 1이라 할 때, 인덱스에 키를 추가하는 비용을 1.5로 계산한다.
ex) 인덱스가 없을 때 1이라면 인덱스가 3개일 때는 5.5로 예측
이 비용은 대부분이 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야해서 걸리는 시간이다.
### 인덱스 키 삭제
B-Tree의 리프 노드를 찾아서 삭제 마크만 하면 되기 때문에 간단하다.
### 인덱스 키 변경
키 삭제 -> 키 추가의 작업으로 이루어진다.
### 지연처리
인덱스 키 추가, 삭제, 변경 모두 체인지 버퍼를 활용해 지연처리 될 수 있다.
### 인덱스 키 검색
## B-Tree 인덱스 사용에 영향을 미치는 요소
### 인덱스 키 값의 크기
	`Page : InnoDB에서 디스크에 데이터를 저장하는 기본 단위
	버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다.

인덱스 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고 그만큼 느려진다.(인덱스는 페이지단위로 디스크에서 읽으므로)
또한 전체적인 인덱스 크기가 커지면서 메모리에 캐시해 둘 수 있는 레코드 수는 줄어들고 자연히 메모리의 효율이 떨어지는 결과를 가져온다.
### B-Tree 깊이
중요하지만 제어할 방법은 없다.
MySQL에서 값을 검색할 때 몇 번이나 랜덤 IO를 해야하는지와 직결되는 문제이다.
### 선택도(기수성)
모든 인덱스 값 가운데 유니크한 값의 수를 의미한다
전체 인덱스 키 값은 1000인데 그 중에서 유니크한 값의 수는 10개라면 기수성은 100이다.
인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어진다.
기수성이 높을수록 검색 대상이 줄어들어 빨리 처리된다.
그러나 기수성이 좋지 않더라도 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 것이 나은 경우도 많다.
### 읽어야 하는 레코드의 건수
일반적인 DBMS 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4-5배 정도 비용이 더 많이 드는 작업인 것으로 예측한다.
따라서 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20-25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방법으로 처리하는 것이 좋다,.
## B-Tree 인덱스를 통한 데이터 읽기
### 인덱스 레인지 스캔
검색해야할 인덱스의 범위가 결정되었을 때 사용하는 방식
인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요한데, 이 때 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어올 때 레코드 한 건 한 건 단위로 랜덤 IO가 한 번씩 일어난다.
그래서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류된다.
1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉읽는다 (인덱스 스캔)
3. 2번에서 읽어들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고 최종 레코드를 읽어온다.
### 인덱스 풀 스캔
인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만 인덱스 레인지 스캔과는 달리 인덱스의 처음부터 끝까지 모드 읽는 방식
즉, 커버링 인덱스가 가능한 인덱스를 모두 읽을 때 테이블 풀 스캔보다 빠르다고 한 것이다.
=> 즉 인덱스를 효율적으로 사용하지 못하는 경우이긴 하다.
### 루스 인덱스 스캔
인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시(SKIP)하고 다음으로 넘어가는 형태로 처리한다.
일반적으로 GROUP BY 또는 집합 함수 가운데 MAX,MIN에 대해 최적화를 하는 경우에 사용된다.
ex) 인덱스가 (dept_no, emp_no)이고 dept_no가 20인 엔티티의 합계를 구하고 싶을 때, dept_no만을 이용해 인덱스를 넘어가도 무방하다 따라서 옵티마이저가 필요없는 emp_no는 스캔하지 않고 dept_no만 비교해가면서 확인하는 스캔 최적화 방식이다,
### 인덱스 스킵 스캔
만약, 인덱스가 (gender, birth_date)로 걸려있을 때 옵티마이저가 gender 칼럼을 건너뛰어서 birth_date 컬럼만으로도 인덱스 검색이 가능하게 해주는 최적화 기능
인덱스 스킵 스캔은 인덱스의 선행 컬럼이 가진 유니크한 값의 개수가 소량일 때만 적용 가능한 최적화이다.

ex)
`where birth_date>='2002-01-25'`라는 sql문을 내부적으로 아래 2개의 쿼리를 실행하는 것과 비슷한 형태의 최적화를 실행한다.
`where gender = 'M' AND birth_date>='2002-01-25'`
`where gender = 'F' AND birth_date>='2002-01-25'`
## B-Tree 인덱스의 정렬 및 스캔 방향
### InnoDB에서 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느릴 수 밖에 없는 이유
- 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조
![[Pasted image 20250227160003.png|300]]
많은 쿼리가 인덱스의 특정 순서로 집중적으로 읽어 인덱스의 특정 페이지 잠금이 병목이 될 것으로 예상된다면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는데 도움이 된다.
