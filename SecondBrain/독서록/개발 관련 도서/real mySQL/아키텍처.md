## mySQL의 메모리 영역
- 글로벌 메모리 영역 (모든 스레드 공유)
	- InnoDB 버퍼 풀
		- 디스크에 있는 데이터 파일/인덱스 정보/undo log를 메모리에 캐싱
	- InnoDB 리두 로그 버퍼
		- 데이터 변경 사항이 디스크에 기록되기 전 보관하는 버퍼
	- 데이터 딕셔너리 캐시
		- 테이블의 컬럼, 인덱스, 제약 조건 등과 같은 메타데이터를 저장하는 캐시
- 세션/스레드 메모리 영역 (각 스레드마다 생성)
	- Sort Buffer
		- 정렬 작업 수행 시 사용
	- Join Buffer
		- 인덱스를 사용하지 못하는 Join이 발생했을 때 조인 대상 테이블의 행들을 임시로 저장
	- Read Buffer
		- Full Table Scan이 사용되는 버퍼
	- Thread Stack
		- 각 스레드의 상태 정보ㅡ 로컬 변수를 저장하는 기본적인 스택 공간
## Undo log
변경되기 이전 데이터를 백업
1. 트랜잭션 롤백: 트랜잭션 실패 시 롤백
2. MVCC: repeatable read 이상의 트랜잭션 격리 수준에서 이미 commit된 시점의 데이터를 읽기 위함
## Redo log
변경된 데이터를 백업
1. 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전 장치 (데이터 영속성 보장)
2. 거의 모든 DBMS에서 데이터 파일이 쓰기보다 읽기 성능을 고려한 자료구조를 가짐
	1. 쓰기 비용이 낮은 자료 구조
		1. 순환 버퍼 구조를 사용하여 데이터를 뒤에 append만 함으로써 랜덤 I/O를 순차 I/O로 변경할 수 있음
### Undo log / redo log가 InnoDB 버퍼 풀 뿐만 아니라 디스크(undo tablespace)에도 저장되는 이유
- 장기 실행 트랜잭션이 있으면, 원본 값이 한 시간 내내 유지되어야 해서 위험하기 때문
- 서버 장애 복구시에 트랜잭션을 롤백하기 위함
## InnoDB에서 데이터가 디스크에 저장되는 방법
page라는 16KB의 기본 블록 단위로 관리
각 페이지는 파일 헤더, 페이지 헤더, 사용자 레코드(실제 데이터). 파일 트레일러 등 정해진 구조를 가짐

## 쿼리 캐시가 삭제된 이유
데이터가 변경되면 쿼리 캐시도 삭제해야하는데, 삭제될 때 쿼리 캐시에 접근하는 스레드에 락을 걸어야 해서 성능 저하가 발생함 (8.0부터 삭제)
## 어댑티브 해시 인덱스
사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스 (캐시라고 보면 쉽다)
B-Tree Index의 고유 번호와 B-Tree Index에서 실제 키 값의 조합으로 생성 (InnoDB 스토리지 엔진에서 어댑티브 해시 인덱스는 하나만 존재하기 때문)
### 단점
- 활성화 시 어댑티브 해시 인덱스를 항상 거쳐야 하는 오버헤드가 발생함
- 어댑티브 해시 인덱스만큼의 메모리가 추가로 필요함
어댑티브 해시 인덱스의 통계 정보를 확인하여 캐시 히트율을 확인하고 히트율이 낮을 시 비활성화 하는 것이 좋다.