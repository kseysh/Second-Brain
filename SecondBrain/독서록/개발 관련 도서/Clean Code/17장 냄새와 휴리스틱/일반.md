## 1. 한 소스 파일에 여러 언어를 사용하지 않아야 한다.
이상적으로는 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다. 각별한 노력을 기울여 소스 파일에서 언어 수와 범위를 최대한 줄이도록 애써야 한다.

## 2. 당연한 동작을 구현해야 한다.
최소 놀람의 원칙에 의거해 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다.

## 3. 경계를 올바로 처리하지 않는다.
부지런함을 대신할 지름길은 없다. 모든 경계 조건, 모든 구석진 곳, 모든 예외는 우아하고 직관적인 알고리즘을 좌초시킬 암초다. 스스로의 직관에 의존하지 마라. 모든 경계 조건을 찾아내고, 모든 경계 조건을 테스트 하는 테스트 케이스를 작성하라.

## 4. 안전 절차 무시
실패하는 테스트 케이스를 일단 제껴두고 나중으로 미루는 태도는 신용카드가 공짜 돈이라는 생각만큼 위험하다.

## 5. 중복
이 책에 나오는 가장 중요한 규칙.
코드에서 중복을 발견할 때마다 추상화 할 기회로 간주하라. 중복된 코드를 하위 루틴이나 다른 클래스로 분리하라. 
이렇듯 추상화로 중복을 정리하면 설계 언어의 어휘가 늘어난다.
### 중복 유형
1. 여러 모듈에서 일련의 switch/case나 if/else 문으로 똑같은 조건을 거듭 확인하는 중복이다. 이런 중복은 다형성으로 대체해야 한다.
2. 알고리즘이 유사하나 코드가 서로 다른 중복이다. 중복은 중복이므로 TEMPLATE METHOD 패턴이나 STRATEGY 패턴으로 중복을 제거한다.
## 6. 추상화 수준이 올바르지 못하다.
추상화는 저차원 상세 개념에서 고차원 일반 개념을 분리한다.
모든 저차원 개념은 파생 클래스에 넣고, 모든 고차원 개념은 기초 클래스에 넣는다.
ex) 세부 구현과 관련한 상수, 변수, 유틸리티 함수는 기초 클래스에 넣으면 안 된다. 기초 클래스는 구현 정보에 무지해야 마땅하다.

## 7. 기초 클래스가 파생 클래스에 의존한다.
기초 클래스가 파생 클래스를 사용한다면 뭔가 문제가 있다는 말이다.
일반적으로 기초 클래스는 파생 클래스를 아예 몰라야 마땅하다.

## 8. 과도한 정보
잘 정의된 모듈은 인터페이스가 아주 작다. 하지만 작은 인터페이스로도 많은 동작이 가능하다.
잘 정의된 인터페이스는 많은 함수를 제공하지 않는다. 