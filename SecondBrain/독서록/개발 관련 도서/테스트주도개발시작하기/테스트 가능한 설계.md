# 테스트가 어려운 코드
## 하드 코딩된 경로
![[Pasted image 20231117182325.png]]
![[Pasted image 20231117182333.png]]
코드를 테스트하기 위해서는 하드 코딩된 경로에 파일이 반드시 위치해야 하는데, 이를 테스트하려면 경로를 알맞게 수정해야해서 어렵다. (대표적인 예시로 window와 맥은 다른 파일 경로를 사용한다.)
하드 코딩된 경로뿐만 아니라 하드 코딩된 IP주소, 포트 번호도 테스트를 어렵게 만든다.

## 의존 객체를 직접 생성
![[Pasted image 20231117182308.png]]
코드를 테스트하기 위해 의존 대상이 올바르게 동작하는데 필요한 모든 환경을 구성해야 한다. DB도 준비해야 하고, 필요한 테이블도 만들어야 한다.
테스트를 실행하면 데이터가 DB에 추가되므로 같은 테스트를 다시 실행하기 전에 기존에 들어간 데이터를 삭제해야한다.

## 정적 메서드 사용
![[Pasted image 20231117182619.png]]
AuthUtil 클래스가 인증 서버와 통신하는 경우 이 코드를 테스트 하려면 동작하고 있는 인증 서버가 필요하다. AuthUtil 클래스가 통신할 인증 서버 정보를 시스템 프로퍼티에서 가져온다면 시스템 프로퍼티도 테스트 환경에 맞게 설정해야 한다. 게다가 다양한 상황을 테스트하려면 인증 서버에 저장되어 있는 유효한 아이디와 암호를 사용해야한다.
## 실행 시점에 따라 달라지는 결과
`localDate.now()`처럼 할 때마다 실행 결과가 달라지는 코드가 있다면 테스트에 대한 신뢰도가 떨어질 수 있다.

## 역할이 섞여 있는 코드
> 이래서 테스트코드를 짜기가 어렵다면 그 것은 역할 분리가 제대로 되지 않았을 수도 있다는 것임!

## 이외에 테스트가 어려운 코드
- 메서드 중간에 소켓 통신 코드가 포함된 코드
- 콘솔에서 입력을 받거나 결과를 콘솔에 출력하는 코드
- 테스트 대상이 사용하는 의존 대상 클래스나 메서드가 final이다. 이 경우 대역으로 대체가 어렵다.
- 테스트 대상의 소스를 소유하고 있지 않아 수정이 어렵다.
# 테스트 가능한 설계
## 하드 코딩된 상수를 생성자나 메서드 파라미터로 받기
하드 코딩된 경로가 테스트가 어려운 이유는 테스트 환경에 따라 경로를 다르게 줄 수 있는 수단이 없기 때문이다. 
하드 코딩된 상수 때문에 테스트가 힘들다면 해당 상수를 교체할 수 있는 기능을 추가하면 된다. 쉬운 방법은 `생성자`나 `setter`를 사용해서 경로를 전달받는 것이다.
## 의존 대상을 주입 받기
생성자나 세터를 통해 의존 대상을 교체할 수 있게 되면 실제 구현 대신에 대역을 사용할 수 있어 테스트를 보다 원활하게 작성할 수 있다.
## 테스트하고 싶은 코드를 분리하기
기능의 일부만 테스트하고 싶다면 코드를 별도 기능으로 분리해서 테스트를 진행할 수 있다.
## 시간이나 임의 값 생성 기능 분리하기
테스트 대상이 시간이나 임의 값을 사용하면 테스트 시점에 따라 테스트 결과가 달라진다. 이 경우 테스트 대상이 사용하는 시간이나 임의 값을 제공하는 기능을 별도로 분리해서 테스트 가능성을 높일 수 있다.
임의 값도 임의 값을 제공하는 라이브러리를 직접 사용하지 말고 별도로 분리한 타입을 사용해서 대역으로 처리할 수 있어야 테스트 가능하게 만들 수 있다.
## 외부 라이브러리는 직접 사용하지 말고 감싸서 사용하기
테스트 대상이 사용하는 외부 라이브러리를 쉽게 대체할 수 없는 경우 
=> 외부 라이브러리가 정적 메서드를 제공하는 경우

대역으로 대체하기 어려운 외부 라이브러리가 있다면 외부 라이브러리를 직접 사용하지 말고 외부 라이브러리와 연동하기 위한 타입을 따로 만든다. 
그리고 테스트 대상이 분리한 타입을 사용하게 바꾼다. 테스트 대상 코드는 새로 분리한 타입을 사용함으로써 외부 연동이 필요한 기능을 쉽게 대역으로 대체할 수 있게 된다.







