## 변수나 필드를 사용해서 기댓값 표현하지 않기
테스트에 통과하지 못하면 실패 메시지는 아래와 같이 나오게 된다.
![[Pasted image 20240510164837.png]]
이 테스트 메시지를 보고 기대한 값이 왜 3인지 보려면 다른 필드를 또 확인해야 한다.
테스트에 성공하더라도 테스트 코드를 처음 보는 사람은 변수와 필드를 오가며 테스트 코드를 이해해야 한다.

변수나 필드를 사용하지 않고 기댓값을 직접 상수로 표현하면 코드 가독성이 좋아져서 테스트 코드를 더욱 쉽게 파악할 수 있다. 객체를 생성할 때 사용한 값이 무엇인지 알아보기 위해 필드와 변수를 참조하지 않아도 된다. 단언할 때 사용한 값이 무엇인지 알기 위해 필드와 변수를 오갈 필요도 없다.

## 두 개 이상을 검증하지 않기
한 테스트에서 검증하는 내용이 두 개 이상이면 테스트 결과를 확인할 때 집중도가 떨어진다. 
만약 첫 번째 검증에 실패하면 테스트는 거기서 멈춘다. 첫 번째 검증 대상을 통과시켜야 비로소 두 번째 검증이 성공했는지 여부를 확인할 수 있다. 또한, 테스트에 실패했을 때 두 가지 검증 대상 중 무엇이 실패했는지 확인해야 한다.

한 테스트가 한 가지만 검증해야 테스트에 실패했을 때 무엇이 잘못되었는지 빨리 알 수 있고 검증 대상이 한정되어 있으므로 테스트도 빨리 통과시킬 수 있다.

## 정확하게 일치하는 값으로 모의 객체 설정하지 않기
`Mockito.any()`를 사용하여 임의의 값을 인자로 전달해도 테스트가 깨지지 않도록 구성한다.
모의 객체는 가능한 범용적인 값을 사용해서 기술해야 한다. 
한정된 값에 일치하도록 모의 객체를 사용하면 약간의 코드 수정만으로도 테스트가 실패하게 된다.
테스트의 의도를 해치지 않는 범위에서 특정한 값 보다는 범용적인 값을 사용해야 한다.

## 과도하게 구현 검증하지 않기
테스트 코드를 작성할 때 주의할 점은 테스트 대상의 내부 구현을 검증하는 것이다.
모의 객체를 이용해서 내부 구현을 검증하는 코드의 작성은 결과적으로 테스트 코드 유지보수에 도움이 되지 않을 수도 있다.

내부 구현을 검증하는 것이 나쁜 것은 아니지만, 구현을 조금만 변경해도 테스트가 깨질 가능성이 커진다.
내부 구현은 언제든지 바뀔 수 있기 때문에 테스트 코드는 내부 구현보다 실행 결과를 검증해야 한다.

### 내부 구현을 검증하는 경우
이미 존재하는 코드에 단위 테스트를 추가하면 어쩔 수 없이 내부 구현을 검증해야 할 때도 있다.
레거시 코드에서 DAO는 다양한 update, select 메서드를 정의하고 있는 경우가 많기 때문에 레거시 코드에 대한 테스트 코드를 작성할 때는 모의 객체를 많이 활용한다.
![[Pasted image 20240510171257.png]]
이 코드는 이메일을 수정했는지 확인하기 위해 모의 객체의 updateEmail() 메서드가 호출됐는지 확인한다. 모의 객체를 호출하는지 여부를 확인하는 것은 구현을 검증하는 것이지만 이메일이 변경되는지 확인할 수 있는 수단이 이것 뿐이기 때문이다.
![[Pasted image 20240510171400.png]]

## 셋업을 이용해서 중복된 상황을 설정하지 않기
